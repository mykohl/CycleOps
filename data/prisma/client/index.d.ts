
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Claim
 * 
 */
export type Claim = $Result.DefaultSelection<Prisma.$ClaimPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model BrandMember
 * 
 */
export type BrandMember = $Result.DefaultSelection<Prisma.$BrandMemberPayload>
/**
 * Model ProductLine
 * 
 */
export type ProductLine = $Result.DefaultSelection<Prisma.$ProductLinePayload>
/**
 * Model PropertyGroup
 * 
 */
export type PropertyGroup = $Result.DefaultSelection<Prisma.$PropertyGroupPayload>
/**
 * Model PropertyGroupMembership
 * 
 */
export type PropertyGroupMembership = $Result.DefaultSelection<Prisma.$PropertyGroupMembershipPayload>
/**
 * Model PropertyType
 * 
 */
export type PropertyType = $Result.DefaultSelection<Prisma.$PropertyTypePayload>
/**
 * Model PropertyLookup
 * 
 */
export type PropertyLookup = $Result.DefaultSelection<Prisma.$PropertyLookupPayload>
/**
 * Model PartClass
 * 
 */
export type PartClass = $Result.DefaultSelection<Prisma.$PartClassPayload>
/**
 * Model PartClassMembership
 * 
 */
export type PartClassMembership = $Result.DefaultSelection<Prisma.$PartClassMembershipPayload>
/**
 * Model PartType
 * 
 */
export type PartType = $Result.DefaultSelection<Prisma.$PartTypePayload>
/**
 * Model PartGroup
 * 
 */
export type PartGroup = $Result.DefaultSelection<Prisma.$PartGroupPayload>
/**
 * Model PartGroupMembership
 * 
 */
export type PartGroupMembership = $Result.DefaultSelection<Prisma.$PartGroupMembershipPayload>
/**
 * Model Part
 * 
 */
export type Part = $Result.DefaultSelection<Prisma.$PartPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model WheelSpoke
 * 
 */
export type WheelSpoke = $Result.DefaultSelection<Prisma.$WheelSpokePayload>
/**
 * Model Wheel
 * 
 */
export type Wheel = $Result.DefaultSelection<Prisma.$WheelPayload>
/**
 * Model BuildPart
 * 
 */
export type BuildPart = $Result.DefaultSelection<Prisma.$BuildPartPayload>
/**
 * Model Build
 * 
 */
export type Build = $Result.DefaultSelection<Prisma.$BuildPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<ExtArgs>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs>;

  /**
   * `prisma.brandMember`: Exposes CRUD operations for the **BrandMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BrandMembers
    * const brandMembers = await prisma.brandMember.findMany()
    * ```
    */
  get brandMember(): Prisma.BrandMemberDelegate<ExtArgs>;

  /**
   * `prisma.productLine`: Exposes CRUD operations for the **ProductLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductLines
    * const productLines = await prisma.productLine.findMany()
    * ```
    */
  get productLine(): Prisma.ProductLineDelegate<ExtArgs>;

  /**
   * `prisma.propertyGroup`: Exposes CRUD operations for the **PropertyGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyGroups
    * const propertyGroups = await prisma.propertyGroup.findMany()
    * ```
    */
  get propertyGroup(): Prisma.PropertyGroupDelegate<ExtArgs>;

  /**
   * `prisma.propertyGroupMembership`: Exposes CRUD operations for the **PropertyGroupMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyGroupMemberships
    * const propertyGroupMemberships = await prisma.propertyGroupMembership.findMany()
    * ```
    */
  get propertyGroupMembership(): Prisma.PropertyGroupMembershipDelegate<ExtArgs>;

  /**
   * `prisma.propertyType`: Exposes CRUD operations for the **PropertyType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyTypes
    * const propertyTypes = await prisma.propertyType.findMany()
    * ```
    */
  get propertyType(): Prisma.PropertyTypeDelegate<ExtArgs>;

  /**
   * `prisma.propertyLookup`: Exposes CRUD operations for the **PropertyLookup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyLookups
    * const propertyLookups = await prisma.propertyLookup.findMany()
    * ```
    */
  get propertyLookup(): Prisma.PropertyLookupDelegate<ExtArgs>;

  /**
   * `prisma.partClass`: Exposes CRUD operations for the **PartClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartClasses
    * const partClasses = await prisma.partClass.findMany()
    * ```
    */
  get partClass(): Prisma.PartClassDelegate<ExtArgs>;

  /**
   * `prisma.partClassMembership`: Exposes CRUD operations for the **PartClassMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartClassMemberships
    * const partClassMemberships = await prisma.partClassMembership.findMany()
    * ```
    */
  get partClassMembership(): Prisma.PartClassMembershipDelegate<ExtArgs>;

  /**
   * `prisma.partType`: Exposes CRUD operations for the **PartType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartTypes
    * const partTypes = await prisma.partType.findMany()
    * ```
    */
  get partType(): Prisma.PartTypeDelegate<ExtArgs>;

  /**
   * `prisma.partGroup`: Exposes CRUD operations for the **PartGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartGroups
    * const partGroups = await prisma.partGroup.findMany()
    * ```
    */
  get partGroup(): Prisma.PartGroupDelegate<ExtArgs>;

  /**
   * `prisma.partGroupMembership`: Exposes CRUD operations for the **PartGroupMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartGroupMemberships
    * const partGroupMemberships = await prisma.partGroupMembership.findMany()
    * ```
    */
  get partGroupMembership(): Prisma.PartGroupMembershipDelegate<ExtArgs>;

  /**
   * `prisma.part`: Exposes CRUD operations for the **Part** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parts
    * const parts = await prisma.part.findMany()
    * ```
    */
  get part(): Prisma.PartDelegate<ExtArgs>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs>;

  /**
   * `prisma.wheelSpoke`: Exposes CRUD operations for the **WheelSpoke** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WheelSpokes
    * const wheelSpokes = await prisma.wheelSpoke.findMany()
    * ```
    */
  get wheelSpoke(): Prisma.WheelSpokeDelegate<ExtArgs>;

  /**
   * `prisma.wheel`: Exposes CRUD operations for the **Wheel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wheels
    * const wheels = await prisma.wheel.findMany()
    * ```
    */
  get wheel(): Prisma.WheelDelegate<ExtArgs>;

  /**
   * `prisma.buildPart`: Exposes CRUD operations for the **BuildPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuildParts
    * const buildParts = await prisma.buildPart.findMany()
    * ```
    */
  get buildPart(): Prisma.BuildPartDelegate<ExtArgs>;

  /**
   * `prisma.build`: Exposes CRUD operations for the **Build** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Builds
    * const builds = await prisma.build.findMany()
    * ```
    */
  get build(): Prisma.BuildDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.7.1
   * Query Engine version: 0ca5ccbcfa6bdc81c003cf549abe4269f59c41e5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Claim: 'Claim',
    Brand: 'Brand',
    BrandMember: 'BrandMember',
    ProductLine: 'ProductLine',
    PropertyGroup: 'PropertyGroup',
    PropertyGroupMembership: 'PropertyGroupMembership',
    PropertyType: 'PropertyType',
    PropertyLookup: 'PropertyLookup',
    PartClass: 'PartClass',
    PartClassMembership: 'PartClassMembership',
    PartType: 'PartType',
    PartGroup: 'PartGroup',
    PartGroupMembership: 'PartGroupMembership',
    Part: 'Part',
    Property: 'Property',
    WheelSpoke: 'WheelSpoke',
    Wheel: 'Wheel',
    BuildPart: 'BuildPart',
    Build: 'Build'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'claim' | 'brand' | 'brandMember' | 'productLine' | 'propertyGroup' | 'propertyGroupMembership' | 'propertyType' | 'propertyLookup' | 'partClass' | 'partClassMembership' | 'partType' | 'partGroup' | 'partGroupMembership' | 'part' | 'property' | 'wheelSpoke' | 'wheel' | 'buildPart' | 'build'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: Prisma.$ClaimPayload<ExtArgs>
        fields: Prisma.ClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>,
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>,
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      BrandMember: {
        payload: Prisma.$BrandMemberPayload<ExtArgs>
        fields: Prisma.BrandMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandMemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandMemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandMemberPayload>
          }
          findFirst: {
            args: Prisma.BrandMemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandMemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandMemberPayload>
          }
          findMany: {
            args: Prisma.BrandMemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandMemberPayload>[]
          }
          create: {
            args: Prisma.BrandMemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandMemberPayload>
          }
          createMany: {
            args: Prisma.BrandMemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BrandMemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandMemberPayload>
          }
          update: {
            args: Prisma.BrandMemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandMemberPayload>
          }
          deleteMany: {
            args: Prisma.BrandMemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BrandMemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BrandMemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandMemberPayload>
          }
          aggregate: {
            args: Prisma.BrandMemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBrandMember>
          }
          groupBy: {
            args: Prisma.BrandMemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BrandMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandMemberCountArgs<ExtArgs>,
            result: $Utils.Optional<BrandMemberCountAggregateOutputType> | number
          }
        }
      }
      ProductLine: {
        payload: Prisma.$ProductLinePayload<ExtArgs>
        fields: Prisma.ProductLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductLineFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductLineFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductLinePayload>
          }
          findFirst: {
            args: Prisma.ProductLineFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductLineFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductLinePayload>
          }
          findMany: {
            args: Prisma.ProductLineFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductLinePayload>[]
          }
          create: {
            args: Prisma.ProductLineCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductLinePayload>
          }
          createMany: {
            args: Prisma.ProductLineCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductLineDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductLinePayload>
          }
          update: {
            args: Prisma.ProductLineUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductLinePayload>
          }
          deleteMany: {
            args: Prisma.ProductLineDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductLineUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductLineUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductLinePayload>
          }
          aggregate: {
            args: Prisma.ProductLineAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductLine>
          }
          groupBy: {
            args: Prisma.ProductLineGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductLineCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductLineCountAggregateOutputType> | number
          }
        }
      }
      PropertyGroup: {
        payload: Prisma.$PropertyGroupPayload<ExtArgs>
        fields: Prisma.PropertyGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyGroupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyGroupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          findFirst: {
            args: Prisma.PropertyGroupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyGroupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          findMany: {
            args: Prisma.PropertyGroupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>[]
          }
          create: {
            args: Prisma.PropertyGroupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          createMany: {
            args: Prisma.PropertyGroupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PropertyGroupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          update: {
            args: Prisma.PropertyGroupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          deleteMany: {
            args: Prisma.PropertyGroupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyGroupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PropertyGroupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          aggregate: {
            args: Prisma.PropertyGroupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePropertyGroup>
          }
          groupBy: {
            args: Prisma.PropertyGroupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PropertyGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyGroupCountArgs<ExtArgs>,
            result: $Utils.Optional<PropertyGroupCountAggregateOutputType> | number
          }
        }
      }
      PropertyGroupMembership: {
        payload: Prisma.$PropertyGroupMembershipPayload<ExtArgs>
        fields: Prisma.PropertyGroupMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyGroupMembershipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyGroupMembershipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupMembershipPayload>
          }
          findFirst: {
            args: Prisma.PropertyGroupMembershipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyGroupMembershipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupMembershipPayload>
          }
          findMany: {
            args: Prisma.PropertyGroupMembershipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupMembershipPayload>[]
          }
          create: {
            args: Prisma.PropertyGroupMembershipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupMembershipPayload>
          }
          createMany: {
            args: Prisma.PropertyGroupMembershipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PropertyGroupMembershipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupMembershipPayload>
          }
          update: {
            args: Prisma.PropertyGroupMembershipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupMembershipPayload>
          }
          deleteMany: {
            args: Prisma.PropertyGroupMembershipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyGroupMembershipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PropertyGroupMembershipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupMembershipPayload>
          }
          aggregate: {
            args: Prisma.PropertyGroupMembershipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePropertyGroupMembership>
          }
          groupBy: {
            args: Prisma.PropertyGroupMembershipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PropertyGroupMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyGroupMembershipCountArgs<ExtArgs>,
            result: $Utils.Optional<PropertyGroupMembershipCountAggregateOutputType> | number
          }
        }
      }
      PropertyType: {
        payload: Prisma.$PropertyTypePayload<ExtArgs>
        fields: Prisma.PropertyTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          findFirst: {
            args: Prisma.PropertyTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          findMany: {
            args: Prisma.PropertyTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>[]
          }
          create: {
            args: Prisma.PropertyTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          createMany: {
            args: Prisma.PropertyTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PropertyTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          update: {
            args: Prisma.PropertyTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          deleteMany: {
            args: Prisma.PropertyTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PropertyTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyTypePayload>
          }
          aggregate: {
            args: Prisma.PropertyTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePropertyType>
          }
          groupBy: {
            args: Prisma.PropertyTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PropertyTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<PropertyTypeCountAggregateOutputType> | number
          }
        }
      }
      PropertyLookup: {
        payload: Prisma.$PropertyLookupPayload<ExtArgs>
        fields: Prisma.PropertyLookupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyLookupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyLookupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyLookupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyLookupPayload>
          }
          findFirst: {
            args: Prisma.PropertyLookupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyLookupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyLookupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyLookupPayload>
          }
          findMany: {
            args: Prisma.PropertyLookupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyLookupPayload>[]
          }
          create: {
            args: Prisma.PropertyLookupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyLookupPayload>
          }
          createMany: {
            args: Prisma.PropertyLookupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PropertyLookupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyLookupPayload>
          }
          update: {
            args: Prisma.PropertyLookupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyLookupPayload>
          }
          deleteMany: {
            args: Prisma.PropertyLookupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyLookupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PropertyLookupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyLookupPayload>
          }
          aggregate: {
            args: Prisma.PropertyLookupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePropertyLookup>
          }
          groupBy: {
            args: Prisma.PropertyLookupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PropertyLookupGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyLookupCountArgs<ExtArgs>,
            result: $Utils.Optional<PropertyLookupCountAggregateOutputType> | number
          }
        }
      }
      PartClass: {
        payload: Prisma.$PartClassPayload<ExtArgs>
        fields: Prisma.PartClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartClassFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartClassFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassPayload>
          }
          findFirst: {
            args: Prisma.PartClassFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartClassFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassPayload>
          }
          findMany: {
            args: Prisma.PartClassFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassPayload>[]
          }
          create: {
            args: Prisma.PartClassCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassPayload>
          }
          createMany: {
            args: Prisma.PartClassCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PartClassDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassPayload>
          }
          update: {
            args: Prisma.PartClassUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassPayload>
          }
          deleteMany: {
            args: Prisma.PartClassDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PartClassUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PartClassUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassPayload>
          }
          aggregate: {
            args: Prisma.PartClassAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePartClass>
          }
          groupBy: {
            args: Prisma.PartClassGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PartClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartClassCountArgs<ExtArgs>,
            result: $Utils.Optional<PartClassCountAggregateOutputType> | number
          }
        }
      }
      PartClassMembership: {
        payload: Prisma.$PartClassMembershipPayload<ExtArgs>
        fields: Prisma.PartClassMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartClassMembershipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartClassMembershipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassMembershipPayload>
          }
          findFirst: {
            args: Prisma.PartClassMembershipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartClassMembershipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassMembershipPayload>
          }
          findMany: {
            args: Prisma.PartClassMembershipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassMembershipPayload>[]
          }
          create: {
            args: Prisma.PartClassMembershipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassMembershipPayload>
          }
          createMany: {
            args: Prisma.PartClassMembershipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PartClassMembershipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassMembershipPayload>
          }
          update: {
            args: Prisma.PartClassMembershipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassMembershipPayload>
          }
          deleteMany: {
            args: Prisma.PartClassMembershipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PartClassMembershipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PartClassMembershipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartClassMembershipPayload>
          }
          aggregate: {
            args: Prisma.PartClassMembershipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePartClassMembership>
          }
          groupBy: {
            args: Prisma.PartClassMembershipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PartClassMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartClassMembershipCountArgs<ExtArgs>,
            result: $Utils.Optional<PartClassMembershipCountAggregateOutputType> | number
          }
        }
      }
      PartType: {
        payload: Prisma.$PartTypePayload<ExtArgs>
        fields: Prisma.PartTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartTypePayload>
          }
          findFirst: {
            args: Prisma.PartTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartTypePayload>
          }
          findMany: {
            args: Prisma.PartTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartTypePayload>[]
          }
          create: {
            args: Prisma.PartTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartTypePayload>
          }
          createMany: {
            args: Prisma.PartTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PartTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartTypePayload>
          }
          update: {
            args: Prisma.PartTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartTypePayload>
          }
          deleteMany: {
            args: Prisma.PartTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PartTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PartTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartTypePayload>
          }
          aggregate: {
            args: Prisma.PartTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePartType>
          }
          groupBy: {
            args: Prisma.PartTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PartTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<PartTypeCountAggregateOutputType> | number
          }
        }
      }
      PartGroup: {
        payload: Prisma.$PartGroupPayload<ExtArgs>
        fields: Prisma.PartGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartGroupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartGroupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupPayload>
          }
          findFirst: {
            args: Prisma.PartGroupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartGroupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupPayload>
          }
          findMany: {
            args: Prisma.PartGroupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupPayload>[]
          }
          create: {
            args: Prisma.PartGroupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupPayload>
          }
          createMany: {
            args: Prisma.PartGroupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PartGroupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupPayload>
          }
          update: {
            args: Prisma.PartGroupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupPayload>
          }
          deleteMany: {
            args: Prisma.PartGroupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PartGroupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PartGroupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupPayload>
          }
          aggregate: {
            args: Prisma.PartGroupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePartGroup>
          }
          groupBy: {
            args: Prisma.PartGroupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PartGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartGroupCountArgs<ExtArgs>,
            result: $Utils.Optional<PartGroupCountAggregateOutputType> | number
          }
        }
      }
      PartGroupMembership: {
        payload: Prisma.$PartGroupMembershipPayload<ExtArgs>
        fields: Prisma.PartGroupMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartGroupMembershipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartGroupMembershipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupMembershipPayload>
          }
          findFirst: {
            args: Prisma.PartGroupMembershipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartGroupMembershipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupMembershipPayload>
          }
          findMany: {
            args: Prisma.PartGroupMembershipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupMembershipPayload>[]
          }
          create: {
            args: Prisma.PartGroupMembershipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupMembershipPayload>
          }
          createMany: {
            args: Prisma.PartGroupMembershipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PartGroupMembershipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupMembershipPayload>
          }
          update: {
            args: Prisma.PartGroupMembershipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupMembershipPayload>
          }
          deleteMany: {
            args: Prisma.PartGroupMembershipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PartGroupMembershipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PartGroupMembershipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartGroupMembershipPayload>
          }
          aggregate: {
            args: Prisma.PartGroupMembershipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePartGroupMembership>
          }
          groupBy: {
            args: Prisma.PartGroupMembershipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PartGroupMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartGroupMembershipCountArgs<ExtArgs>,
            result: $Utils.Optional<PartGroupMembershipCountAggregateOutputType> | number
          }
        }
      }
      Part: {
        payload: Prisma.$PartPayload<ExtArgs>
        fields: Prisma.PartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          findFirst: {
            args: Prisma.PartFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          findMany: {
            args: Prisma.PartFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartPayload>[]
          }
          create: {
            args: Prisma.PartCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          createMany: {
            args: Prisma.PartCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PartDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          update: {
            args: Prisma.PartUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          deleteMany: {
            args: Prisma.PartDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PartUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PartUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          aggregate: {
            args: Prisma.PartAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePart>
          }
          groupBy: {
            args: Prisma.PartGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PartGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartCountArgs<ExtArgs>,
            result: $Utils.Optional<PartCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>,
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      WheelSpoke: {
        payload: Prisma.$WheelSpokePayload<ExtArgs>
        fields: Prisma.WheelSpokeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WheelSpokeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelSpokePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WheelSpokeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelSpokePayload>
          }
          findFirst: {
            args: Prisma.WheelSpokeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelSpokePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WheelSpokeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelSpokePayload>
          }
          findMany: {
            args: Prisma.WheelSpokeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelSpokePayload>[]
          }
          create: {
            args: Prisma.WheelSpokeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelSpokePayload>
          }
          createMany: {
            args: Prisma.WheelSpokeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WheelSpokeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelSpokePayload>
          }
          update: {
            args: Prisma.WheelSpokeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelSpokePayload>
          }
          deleteMany: {
            args: Prisma.WheelSpokeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WheelSpokeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WheelSpokeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelSpokePayload>
          }
          aggregate: {
            args: Prisma.WheelSpokeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWheelSpoke>
          }
          groupBy: {
            args: Prisma.WheelSpokeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WheelSpokeGroupByOutputType>[]
          }
          count: {
            args: Prisma.WheelSpokeCountArgs<ExtArgs>,
            result: $Utils.Optional<WheelSpokeCountAggregateOutputType> | number
          }
        }
      }
      Wheel: {
        payload: Prisma.$WheelPayload<ExtArgs>
        fields: Prisma.WheelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WheelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WheelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelPayload>
          }
          findFirst: {
            args: Prisma.WheelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WheelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelPayload>
          }
          findMany: {
            args: Prisma.WheelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelPayload>[]
          }
          create: {
            args: Prisma.WheelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelPayload>
          }
          createMany: {
            args: Prisma.WheelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WheelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelPayload>
          }
          update: {
            args: Prisma.WheelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelPayload>
          }
          deleteMany: {
            args: Prisma.WheelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WheelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WheelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WheelPayload>
          }
          aggregate: {
            args: Prisma.WheelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWheel>
          }
          groupBy: {
            args: Prisma.WheelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WheelGroupByOutputType>[]
          }
          count: {
            args: Prisma.WheelCountArgs<ExtArgs>,
            result: $Utils.Optional<WheelCountAggregateOutputType> | number
          }
        }
      }
      BuildPart: {
        payload: Prisma.$BuildPartPayload<ExtArgs>
        fields: Prisma.BuildPartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildPartFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildPartFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPartPayload>
          }
          findFirst: {
            args: Prisma.BuildPartFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildPartFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPartPayload>
          }
          findMany: {
            args: Prisma.BuildPartFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPartPayload>[]
          }
          create: {
            args: Prisma.BuildPartCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPartPayload>
          }
          createMany: {
            args: Prisma.BuildPartCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildPartDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPartPayload>
          }
          update: {
            args: Prisma.BuildPartUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPartPayload>
          }
          deleteMany: {
            args: Prisma.BuildPartDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildPartUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildPartUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPartPayload>
          }
          aggregate: {
            args: Prisma.BuildPartAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuildPart>
          }
          groupBy: {
            args: Prisma.BuildPartGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildPartGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildPartCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildPartCountAggregateOutputType> | number
          }
        }
      }
      Build: {
        payload: Prisma.$BuildPayload<ExtArgs>
        fields: Prisma.BuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          findFirst: {
            args: Prisma.BuildFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          findMany: {
            args: Prisma.BuildFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>[]
          }
          create: {
            args: Prisma.BuildCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          createMany: {
            args: Prisma.BuildCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          update: {
            args: Prisma.BuildUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          deleteMany: {
            args: Prisma.BuildDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildPayload>
          }
          aggregate: {
            args: Prisma.BuildAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuild>
          }
          groupBy: {
            args: Prisma.BuildGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    claims: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | UserCountOutputTypeCountClaimsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }



  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    labelMemberships: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labelMemberships?: boolean | BrandCountOutputTypeCountLabelMembershipsArgs
  }

  // Custom InputTypes

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountLabelMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandMemberWhereInput
  }



  /**
   * Count Type ProductLineCountOutputType
   */

  export type ProductLineCountOutputType = {
    labelMemberships: number
    items: number
  }

  export type ProductLineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labelMemberships?: boolean | ProductLineCountOutputTypeCountLabelMembershipsArgs
    items?: boolean | ProductLineCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes

  /**
   * ProductLineCountOutputType without action
   */
  export type ProductLineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineCountOutputType
     */
    select?: ProductLineCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductLineCountOutputType without action
   */
  export type ProductLineCountOutputTypeCountLabelMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandMemberWhereInput
  }


  /**
   * ProductLineCountOutputType without action
   */
  export type ProductLineCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartWhereInput
  }



  /**
   * Count Type PropertyGroupCountOutputType
   */

  export type PropertyGroupCountOutputType = {
    propertyTypes: number
  }

  export type PropertyGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyTypes?: boolean | PropertyGroupCountOutputTypeCountPropertyTypesArgs
  }

  // Custom InputTypes

  /**
   * PropertyGroupCountOutputType without action
   */
  export type PropertyGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupCountOutputType
     */
    select?: PropertyGroupCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PropertyGroupCountOutputType without action
   */
  export type PropertyGroupCountOutputTypeCountPropertyTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyGroupMembershipWhereInput
  }



  /**
   * Count Type PropertyTypeCountOutputType
   */

  export type PropertyTypeCountOutputType = {
    groups: number
    properties: number
    lookupValues: number
  }

  export type PropertyTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | PropertyTypeCountOutputTypeCountGroupsArgs
    properties?: boolean | PropertyTypeCountOutputTypeCountPropertiesArgs
    lookupValues?: boolean | PropertyTypeCountOutputTypeCountLookupValuesArgs
  }

  // Custom InputTypes

  /**
   * PropertyTypeCountOutputType without action
   */
  export type PropertyTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTypeCountOutputType
     */
    select?: PropertyTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PropertyTypeCountOutputType without action
   */
  export type PropertyTypeCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyGroupMembershipWhereInput
  }


  /**
   * PropertyTypeCountOutputType without action
   */
  export type PropertyTypeCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * PropertyTypeCountOutputType without action
   */
  export type PropertyTypeCountOutputTypeCountLookupValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyLookupWhereInput
  }



  /**
   * Count Type PartClassCountOutputType
   */

  export type PartClassCountOutputType = {
    partTypes: number
  }

  export type PartClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partTypes?: boolean | PartClassCountOutputTypeCountPartTypesArgs
  }

  // Custom InputTypes

  /**
   * PartClassCountOutputType without action
   */
  export type PartClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassCountOutputType
     */
    select?: PartClassCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PartClassCountOutputType without action
   */
  export type PartClassCountOutputTypeCountPartTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartClassMembershipWhereInput
  }



  /**
   * Count Type PartTypeCountOutputType
   */

  export type PartTypeCountOutputType = {
    propertyTypes: number
    classes: number
  }

  export type PartTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyTypes?: boolean | PartTypeCountOutputTypeCountPropertyTypesArgs
    classes?: boolean | PartTypeCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes

  /**
   * PartTypeCountOutputType without action
   */
  export type PartTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartTypeCountOutputType
     */
    select?: PartTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PartTypeCountOutputType without action
   */
  export type PartTypeCountOutputTypeCountPropertyTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyGroupMembershipWhereInput
  }


  /**
   * PartTypeCountOutputType without action
   */
  export type PartTypeCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartClassMembershipWhereInput
  }



  /**
   * Count Type PartGroupCountOutputType
   */

  export type PartGroupCountOutputType = {
    parts: number
  }

  export type PartGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parts?: boolean | PartGroupCountOutputTypeCountPartsArgs
  }

  // Custom InputTypes

  /**
   * PartGroupCountOutputType without action
   */
  export type PartGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupCountOutputType
     */
    select?: PartGroupCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PartGroupCountOutputType without action
   */
  export type PartGroupCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartGroupMembershipWhereInput
  }



  /**
   * Count Type PartCountOutputType
   */

  export type PartCountOutputType = {
    wheelHubs: number
    wheelRims: number
    wheelSpokes: number
    properties: number
    claims: number
    groups: number
    builds: number
  }

  export type PartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wheelHubs?: boolean | PartCountOutputTypeCountWheelHubsArgs
    wheelRims?: boolean | PartCountOutputTypeCountWheelRimsArgs
    wheelSpokes?: boolean | PartCountOutputTypeCountWheelSpokesArgs
    properties?: boolean | PartCountOutputTypeCountPropertiesArgs
    claims?: boolean | PartCountOutputTypeCountClaimsArgs
    groups?: boolean | PartCountOutputTypeCountGroupsArgs
    builds?: boolean | PartCountOutputTypeCountBuildsArgs
  }

  // Custom InputTypes

  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartCountOutputType
     */
    select?: PartCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountWheelHubsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WheelWhereInput
  }


  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountWheelRimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WheelWhereInput
  }


  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountWheelSpokesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WheelSpokeWhereInput
  }


  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }


  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartGroupMembershipWhereInput
  }


  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountBuildsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildPartWhereInput
  }



  /**
   * Count Type WheelCountOutputType
   */

  export type WheelCountOutputType = {
    spokes: number
  }

  export type WheelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spokes?: boolean | WheelCountOutputTypeCountSpokesArgs
  }

  // Custom InputTypes

  /**
   * WheelCountOutputType without action
   */
  export type WheelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelCountOutputType
     */
    select?: WheelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WheelCountOutputType without action
   */
  export type WheelCountOutputTypeCountSpokesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WheelSpokeWhereInput
  }



  /**
   * Count Type BuildCountOutputType
   */

  export type BuildCountOutputType = {
    parts: number
  }

  export type BuildCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parts?: boolean | BuildCountOutputTypeCountPartsArgs
  }

  // Custom InputTypes

  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildCountOutputType
     */
    select?: BuildCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BuildCountOutputType without action
   */
  export type BuildCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildPartWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    nameLast: string | null
    nameFirst: string | null
    providerId: string | null
    provider: string | null
    roles: string | null
    registered: Date | null
    lastLogIn: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    nameLast: string | null
    nameFirst: string | null
    providerId: string | null
    provider: string | null
    roles: string | null
    registered: Date | null
    lastLogIn: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    nameLast: number
    nameFirst: number
    providerId: number
    provider: number
    roles: number
    registered: number
    lastLogIn: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    nameLast?: true
    nameFirst?: true
    providerId?: true
    provider?: true
    roles?: true
    registered?: true
    lastLogIn?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    nameLast?: true
    nameFirst?: true
    providerId?: true
    provider?: true
    roles?: true
    registered?: true
    lastLogIn?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    nameLast?: true
    nameFirst?: true
    providerId?: true
    provider?: true
    roles?: true
    registered?: true
    lastLogIn?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string | null
    nameLast: string | null
    nameFirst: string | null
    providerId: string
    provider: string | null
    roles: string | null
    registered: Date | null
    lastLogIn: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameLast?: boolean
    nameFirst?: boolean
    providerId?: boolean
    provider?: boolean
    roles?: boolean
    registered?: boolean
    lastLogIn?: boolean
    claims?: boolean | User$claimsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    nameLast?: boolean
    nameFirst?: boolean
    providerId?: boolean
    provider?: boolean
    roles?: boolean
    registered?: boolean
    lastLogIn?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | User$claimsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      claims: Prisma.$ClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      nameLast: string | null
      nameFirst: string | null
      providerId: string
      provider: string | null
      roles: string | null
      registered: Date | null
      lastLogIn: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    claims<T extends User$claimsArgs<ExtArgs> = {}>(args?: Subset<T, User$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly nameLast: FieldRef<"User", 'String'>
    readonly nameFirst: FieldRef<"User", 'String'>
    readonly providerId: FieldRef<"User", 'String'>
    readonly provider: FieldRef<"User", 'String'>
    readonly roles: FieldRef<"User", 'String'>
    readonly registered: FieldRef<"User", 'DateTime'>
    readonly lastLogIn: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.claims
   */
  export type User$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Claim
   */

  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    partId: number | null
  }

  export type ClaimSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    partId: number | null
  }

  export type ClaimMinAggregateOutputType = {
    id: number | null
    claimType: string | null
    acquired: Date | null
    condition: string | null
    notes: string | null
    ownerId: number | null
    partId: number | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: number | null
    claimType: string | null
    acquired: Date | null
    condition: string | null
    notes: string | null
    ownerId: number | null
    partId: number | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    claimType: number
    acquired: number
    condition: number
    notes: number
    ownerId: number
    partId: number
    _all: number
  }


  export type ClaimAvgAggregateInputType = {
    id?: true
    ownerId?: true
    partId?: true
  }

  export type ClaimSumAggregateInputType = {
    id?: true
    ownerId?: true
    partId?: true
  }

  export type ClaimMinAggregateInputType = {
    id?: true
    claimType?: true
    acquired?: true
    condition?: true
    notes?: true
    ownerId?: true
    partId?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    claimType?: true
    acquired?: true
    condition?: true
    notes?: true
    ownerId?: true
    partId?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    claimType?: true
    acquired?: true
    condition?: true
    notes?: true
    ownerId?: true
    partId?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithAggregationInput | ClaimOrderByWithAggregationInput[]
    by: ClaimScalarFieldEnum[] | ClaimScalarFieldEnum
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _avg?: ClaimAvgAggregateInputType
    _sum?: ClaimSumAggregateInputType
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }

  export type ClaimGroupByOutputType = {
    id: number
    claimType: string | null
    acquired: Date | null
    condition: string | null
    notes: string | null
    ownerId: number | null
    partId: number | null
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimType?: boolean
    acquired?: boolean
    condition?: boolean
    notes?: boolean
    ownerId?: boolean
    partId?: boolean
    owner?: boolean | Claim$ownerArgs<ExtArgs>
    part?: boolean | Claim$partArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectScalar = {
    id?: boolean
    claimType?: boolean
    acquired?: boolean
    condition?: boolean
    notes?: boolean
    ownerId?: boolean
    partId?: boolean
  }

  export type ClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Claim$ownerArgs<ExtArgs>
    part?: boolean | Claim$partArgs<ExtArgs>
  }


  export type $ClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Claim"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      part: Prisma.$PartPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      claimType: string | null
      acquired: Date | null
      condition: string | null
      notes: string | null
      ownerId: number | null
      partId: number | null
    }, ExtArgs["result"]["claim"]>
    composites: {}
  }


  type ClaimGetPayload<S extends boolean | null | undefined | ClaimDefaultArgs> = $Result.GetResult<Prisma.$ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaimFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Claim that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaimFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Claim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClaimFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
    **/
    create<T extends ClaimCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Claims.
     *     @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     *     @example
     *     // Create many Claims
     *     const claim = await prisma.claim.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaimCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
    **/
    delete<T extends ClaimDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaimUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaimDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaimUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
    **/
    upsert<T extends ClaimUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Claim model
   */
  readonly fields: ClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    owner<T extends Claim$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Claim$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    part<T extends Claim$partArgs<ExtArgs> = {}>(args?: Subset<T, Claim$partArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Claim model
   */ 
  interface ClaimFieldRefs {
    readonly id: FieldRef<"Claim", 'Int'>
    readonly claimType: FieldRef<"Claim", 'String'>
    readonly acquired: FieldRef<"Claim", 'DateTime'>
    readonly condition: FieldRef<"Claim", 'String'>
    readonly notes: FieldRef<"Claim", 'String'>
    readonly ownerId: FieldRef<"Claim", 'Int'>
    readonly partId: FieldRef<"Claim", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Claim findUnique
   */
  export type ClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim findFirst
   */
  export type ClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data?: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }


  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
  }


  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }


  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
  }


  /**
   * Claim.owner
   */
  export type Claim$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Claim.part
   */
  export type Claim$partArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
  }


  /**
   * Claim without action
   */
  export type ClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
  }



  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandSumAggregateOutputType = {
    id: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    nameShort: string | null
    nameAbbreviation: string | null
    notes: string | null
    webAddress: string | null
  }

  export type BrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    nameShort: string | null
    nameAbbreviation: string | null
    notes: string | null
    webAddress: string | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    nameShort: number
    nameAbbreviation: number
    notes: number
    webAddress: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    id?: true
  }

  export type BrandSumAggregateInputType = {
    id?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    nameShort?: true
    nameAbbreviation?: true
    notes?: true
    webAddress?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    nameShort?: true
    nameAbbreviation?: true
    notes?: true
    webAddress?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    nameShort?: true
    nameAbbreviation?: true
    notes?: true
    webAddress?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: number
    name: string | null
    nameShort: string | null
    nameAbbreviation: string | null
    notes: string | null
    webAddress: string | null
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameShort?: boolean
    nameAbbreviation?: boolean
    notes?: boolean
    webAddress?: boolean
    labelMemberships?: boolean | Brand$labelMembershipsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
    nameShort?: boolean
    nameAbbreviation?: boolean
    notes?: boolean
    webAddress?: boolean
  }

  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labelMemberships?: boolean | Brand$labelMembershipsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      labelMemberships: Prisma.$BrandMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      nameShort: string | null
      nameAbbreviation: string | null
      notes: string | null
      webAddress: string | null
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }


  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BrandFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Brand that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BrandFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BrandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
    **/
    create<T extends BrandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandCreateArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Brands.
     *     @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     *     @example
     *     // Create many Brands
     *     const brand = await prisma.brand.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BrandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
    **/
    delete<T extends BrandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BrandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BrandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BrandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
    **/
    upsert<T extends BrandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    labelMemberships<T extends Brand$labelMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$labelMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Brand model
   */ 
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'Int'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly nameShort: FieldRef<"Brand", 'String'>
    readonly nameAbbreviation: FieldRef<"Brand", 'String'>
    readonly notes: FieldRef<"Brand", 'String'>
    readonly webAddress: FieldRef<"Brand", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data?: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }


  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
  }


  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }


  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
  }


  /**
   * Brand.labelMemberships
   */
  export type Brand$labelMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    where?: BrandMemberWhereInput
    orderBy?: BrandMemberOrderByWithRelationInput | BrandMemberOrderByWithRelationInput[]
    cursor?: BrandMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrandMemberScalarFieldEnum | BrandMemberScalarFieldEnum[]
  }


  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
  }



  /**
   * Model BrandMember
   */

  export type AggregateBrandMember = {
    _count: BrandMemberCountAggregateOutputType | null
    _avg: BrandMemberAvgAggregateOutputType | null
    _sum: BrandMemberSumAggregateOutputType | null
    _min: BrandMemberMinAggregateOutputType | null
    _max: BrandMemberMaxAggregateOutputType | null
  }

  export type BrandMemberAvgAggregateOutputType = {
    id: number | null
    productLineId: number | null
    brandId: number | null
  }

  export type BrandMemberSumAggregateOutputType = {
    id: number | null
    productLineId: number | null
    brandId: number | null
  }

  export type BrandMemberMinAggregateOutputType = {
    id: number | null
    productLineId: number | null
    brandId: number | null
  }

  export type BrandMemberMaxAggregateOutputType = {
    id: number | null
    productLineId: number | null
    brandId: number | null
  }

  export type BrandMemberCountAggregateOutputType = {
    id: number
    productLineId: number
    brandId: number
    _all: number
  }


  export type BrandMemberAvgAggregateInputType = {
    id?: true
    productLineId?: true
    brandId?: true
  }

  export type BrandMemberSumAggregateInputType = {
    id?: true
    productLineId?: true
    brandId?: true
  }

  export type BrandMemberMinAggregateInputType = {
    id?: true
    productLineId?: true
    brandId?: true
  }

  export type BrandMemberMaxAggregateInputType = {
    id?: true
    productLineId?: true
    brandId?: true
  }

  export type BrandMemberCountAggregateInputType = {
    id?: true
    productLineId?: true
    brandId?: true
    _all?: true
  }

  export type BrandMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BrandMember to aggregate.
     */
    where?: BrandMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrandMembers to fetch.
     */
    orderBy?: BrandMemberOrderByWithRelationInput | BrandMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrandMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrandMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BrandMembers
    **/
    _count?: true | BrandMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMemberMaxAggregateInputType
  }

  export type GetBrandMemberAggregateType<T extends BrandMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateBrandMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrandMember[P]>
      : GetScalarType<T[P], AggregateBrandMember[P]>
  }




  export type BrandMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandMemberWhereInput
    orderBy?: BrandMemberOrderByWithAggregationInput | BrandMemberOrderByWithAggregationInput[]
    by: BrandMemberScalarFieldEnum[] | BrandMemberScalarFieldEnum
    having?: BrandMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandMemberCountAggregateInputType | true
    _avg?: BrandMemberAvgAggregateInputType
    _sum?: BrandMemberSumAggregateInputType
    _min?: BrandMemberMinAggregateInputType
    _max?: BrandMemberMaxAggregateInputType
  }

  export type BrandMemberGroupByOutputType = {
    id: number
    productLineId: number | null
    brandId: number | null
    _count: BrandMemberCountAggregateOutputType | null
    _avg: BrandMemberAvgAggregateOutputType | null
    _sum: BrandMemberSumAggregateOutputType | null
    _min: BrandMemberMinAggregateOutputType | null
    _max: BrandMemberMaxAggregateOutputType | null
  }

  type GetBrandMemberGroupByPayload<T extends BrandMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandMemberGroupByOutputType[P]>
            : GetScalarType<T[P], BrandMemberGroupByOutputType[P]>
        }
      >
    >


  export type BrandMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productLineId?: boolean
    brandId?: boolean
    productLine?: boolean | BrandMember$productLineArgs<ExtArgs>
    brand?: boolean | BrandMember$brandArgs<ExtArgs>
  }, ExtArgs["result"]["brandMember"]>

  export type BrandMemberSelectScalar = {
    id?: boolean
    productLineId?: boolean
    brandId?: boolean
  }

  export type BrandMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productLine?: boolean | BrandMember$productLineArgs<ExtArgs>
    brand?: boolean | BrandMember$brandArgs<ExtArgs>
  }


  export type $BrandMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BrandMember"
    objects: {
      productLine: Prisma.$ProductLinePayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productLineId: number | null
      brandId: number | null
    }, ExtArgs["result"]["brandMember"]>
    composites: {}
  }


  type BrandMemberGetPayload<S extends boolean | null | undefined | BrandMemberDefaultArgs> = $Result.GetResult<Prisma.$BrandMemberPayload, S>

  type BrandMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BrandMemberFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BrandMemberCountAggregateInputType | true
    }

  export interface BrandMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BrandMember'], meta: { name: 'BrandMember' } }
    /**
     * Find zero or one BrandMember that matches the filter.
     * @param {BrandMemberFindUniqueArgs} args - Arguments to find a BrandMember
     * @example
     * // Get one BrandMember
     * const brandMember = await prisma.brandMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BrandMemberFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BrandMemberFindUniqueArgs<ExtArgs>>
    ): Prisma__BrandMemberClient<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BrandMember that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BrandMemberFindUniqueOrThrowArgs} args - Arguments to find a BrandMember
     * @example
     * // Get one BrandMember
     * const brandMember = await prisma.brandMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BrandMemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandMemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BrandMemberClient<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BrandMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandMemberFindFirstArgs} args - Arguments to find a BrandMember
     * @example
     * // Get one BrandMember
     * const brandMember = await prisma.brandMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BrandMemberFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandMemberFindFirstArgs<ExtArgs>>
    ): Prisma__BrandMemberClient<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BrandMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandMemberFindFirstOrThrowArgs} args - Arguments to find a BrandMember
     * @example
     * // Get one BrandMember
     * const brandMember = await prisma.brandMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BrandMemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandMemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BrandMemberClient<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BrandMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandMemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BrandMembers
     * const brandMembers = await prisma.brandMember.findMany()
     * 
     * // Get first 10 BrandMembers
     * const brandMembers = await prisma.brandMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandMemberWithIdOnly = await prisma.brandMember.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BrandMemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandMemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BrandMember.
     * @param {BrandMemberCreateArgs} args - Arguments to create a BrandMember.
     * @example
     * // Create one BrandMember
     * const BrandMember = await prisma.brandMember.create({
     *   data: {
     *     // ... data to create a BrandMember
     *   }
     * })
     * 
    **/
    create<T extends BrandMemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandMemberCreateArgs<ExtArgs>>
    ): Prisma__BrandMemberClient<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BrandMembers.
     *     @param {BrandMemberCreateManyArgs} args - Arguments to create many BrandMembers.
     *     @example
     *     // Create many BrandMembers
     *     const brandMember = await prisma.brandMember.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BrandMemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandMemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BrandMember.
     * @param {BrandMemberDeleteArgs} args - Arguments to delete one BrandMember.
     * @example
     * // Delete one BrandMember
     * const BrandMember = await prisma.brandMember.delete({
     *   where: {
     *     // ... filter to delete one BrandMember
     *   }
     * })
     * 
    **/
    delete<T extends BrandMemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BrandMemberDeleteArgs<ExtArgs>>
    ): Prisma__BrandMemberClient<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BrandMember.
     * @param {BrandMemberUpdateArgs} args - Arguments to update one BrandMember.
     * @example
     * // Update one BrandMember
     * const brandMember = await prisma.brandMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BrandMemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandMemberUpdateArgs<ExtArgs>>
    ): Prisma__BrandMemberClient<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BrandMembers.
     * @param {BrandMemberDeleteManyArgs} args - Arguments to filter BrandMembers to delete.
     * @example
     * // Delete a few BrandMembers
     * const { count } = await prisma.brandMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BrandMemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandMemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BrandMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BrandMembers
     * const brandMember = await prisma.brandMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BrandMemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BrandMemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BrandMember.
     * @param {BrandMemberUpsertArgs} args - Arguments to update or create a BrandMember.
     * @example
     * // Update or create a BrandMember
     * const brandMember = await prisma.brandMember.upsert({
     *   create: {
     *     // ... data to create a BrandMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BrandMember we want to update
     *   }
     * })
    **/
    upsert<T extends BrandMemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BrandMemberUpsertArgs<ExtArgs>>
    ): Prisma__BrandMemberClient<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BrandMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandMemberCountArgs} args - Arguments to filter BrandMembers to count.
     * @example
     * // Count the number of BrandMembers
     * const count = await prisma.brandMember.count({
     *   where: {
     *     // ... the filter for the BrandMembers we want to count
     *   }
     * })
    **/
    count<T extends BrandMemberCountArgs>(
      args?: Subset<T, BrandMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BrandMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandMemberAggregateArgs>(args: Subset<T, BrandMemberAggregateArgs>): Prisma.PrismaPromise<GetBrandMemberAggregateType<T>>

    /**
     * Group by BrandMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandMemberGroupByArgs['orderBy'] }
        : { orderBy?: BrandMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BrandMember model
   */
  readonly fields: BrandMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BrandMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    productLine<T extends BrandMember$productLineArgs<ExtArgs> = {}>(args?: Subset<T, BrandMember$productLineArgs<ExtArgs>>): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    brand<T extends BrandMember$brandArgs<ExtArgs> = {}>(args?: Subset<T, BrandMember$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BrandMember model
   */ 
  interface BrandMemberFieldRefs {
    readonly id: FieldRef<"BrandMember", 'Int'>
    readonly productLineId: FieldRef<"BrandMember", 'Int'>
    readonly brandId: FieldRef<"BrandMember", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BrandMember findUnique
   */
  export type BrandMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    /**
     * Filter, which BrandMember to fetch.
     */
    where: BrandMemberWhereUniqueInput
  }


  /**
   * BrandMember findUniqueOrThrow
   */
  export type BrandMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    /**
     * Filter, which BrandMember to fetch.
     */
    where: BrandMemberWhereUniqueInput
  }


  /**
   * BrandMember findFirst
   */
  export type BrandMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    /**
     * Filter, which BrandMember to fetch.
     */
    where?: BrandMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrandMembers to fetch.
     */
    orderBy?: BrandMemberOrderByWithRelationInput | BrandMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BrandMembers.
     */
    cursor?: BrandMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrandMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrandMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BrandMembers.
     */
    distinct?: BrandMemberScalarFieldEnum | BrandMemberScalarFieldEnum[]
  }


  /**
   * BrandMember findFirstOrThrow
   */
  export type BrandMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    /**
     * Filter, which BrandMember to fetch.
     */
    where?: BrandMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrandMembers to fetch.
     */
    orderBy?: BrandMemberOrderByWithRelationInput | BrandMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BrandMembers.
     */
    cursor?: BrandMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrandMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrandMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BrandMembers.
     */
    distinct?: BrandMemberScalarFieldEnum | BrandMemberScalarFieldEnum[]
  }


  /**
   * BrandMember findMany
   */
  export type BrandMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    /**
     * Filter, which BrandMembers to fetch.
     */
    where?: BrandMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BrandMembers to fetch.
     */
    orderBy?: BrandMemberOrderByWithRelationInput | BrandMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BrandMembers.
     */
    cursor?: BrandMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BrandMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BrandMembers.
     */
    skip?: number
    distinct?: BrandMemberScalarFieldEnum | BrandMemberScalarFieldEnum[]
  }


  /**
   * BrandMember create
   */
  export type BrandMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a BrandMember.
     */
    data?: XOR<BrandMemberCreateInput, BrandMemberUncheckedCreateInput>
  }


  /**
   * BrandMember createMany
   */
  export type BrandMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BrandMembers.
     */
    data: BrandMemberCreateManyInput | BrandMemberCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BrandMember update
   */
  export type BrandMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a BrandMember.
     */
    data: XOR<BrandMemberUpdateInput, BrandMemberUncheckedUpdateInput>
    /**
     * Choose, which BrandMember to update.
     */
    where: BrandMemberWhereUniqueInput
  }


  /**
   * BrandMember updateMany
   */
  export type BrandMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BrandMembers.
     */
    data: XOR<BrandMemberUpdateManyMutationInput, BrandMemberUncheckedUpdateManyInput>
    /**
     * Filter which BrandMembers to update
     */
    where?: BrandMemberWhereInput
  }


  /**
   * BrandMember upsert
   */
  export type BrandMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the BrandMember to update in case it exists.
     */
    where: BrandMemberWhereUniqueInput
    /**
     * In case the BrandMember found by the `where` argument doesn't exist, create a new BrandMember with this data.
     */
    create: XOR<BrandMemberCreateInput, BrandMemberUncheckedCreateInput>
    /**
     * In case the BrandMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandMemberUpdateInput, BrandMemberUncheckedUpdateInput>
  }


  /**
   * BrandMember delete
   */
  export type BrandMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    /**
     * Filter which BrandMember to delete.
     */
    where: BrandMemberWhereUniqueInput
  }


  /**
   * BrandMember deleteMany
   */
  export type BrandMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BrandMembers to delete
     */
    where?: BrandMemberWhereInput
  }


  /**
   * BrandMember.productLine
   */
  export type BrandMember$productLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    where?: ProductLineWhereInput
  }


  /**
   * BrandMember.brand
   */
  export type BrandMember$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }


  /**
   * BrandMember without action
   */
  export type BrandMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
  }



  /**
   * Model ProductLine
   */

  export type AggregateProductLine = {
    _count: ProductLineCountAggregateOutputType | null
    _avg: ProductLineAvgAggregateOutputType | null
    _sum: ProductLineSumAggregateOutputType | null
    _min: ProductLineMinAggregateOutputType | null
    _max: ProductLineMaxAggregateOutputType | null
  }

  export type ProductLineAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductLineSumAggregateOutputType = {
    id: number | null
  }

  export type ProductLineMinAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    nameShort: string | null
    nameAbbreviation: string | null
    notes: string | null
    webAddress: string | null
  }

  export type ProductLineMaxAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    nameShort: string | null
    nameAbbreviation: string | null
    notes: string | null
    webAddress: string | null
  }

  export type ProductLineCountAggregateOutputType = {
    id: number
    type: number
    name: number
    nameShort: number
    nameAbbreviation: number
    notes: number
    webAddress: number
    _all: number
  }


  export type ProductLineAvgAggregateInputType = {
    id?: true
  }

  export type ProductLineSumAggregateInputType = {
    id?: true
  }

  export type ProductLineMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    nameShort?: true
    nameAbbreviation?: true
    notes?: true
    webAddress?: true
  }

  export type ProductLineMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    nameShort?: true
    nameAbbreviation?: true
    notes?: true
    webAddress?: true
  }

  export type ProductLineCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    nameShort?: true
    nameAbbreviation?: true
    notes?: true
    webAddress?: true
    _all?: true
  }

  export type ProductLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductLine to aggregate.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: ProductLineOrderByWithRelationInput | ProductLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductLines
    **/
    _count?: true | ProductLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductLineMaxAggregateInputType
  }

  export type GetProductLineAggregateType<T extends ProductLineAggregateArgs> = {
        [P in keyof T & keyof AggregateProductLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductLine[P]>
      : GetScalarType<T[P], AggregateProductLine[P]>
  }




  export type ProductLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductLineWhereInput
    orderBy?: ProductLineOrderByWithAggregationInput | ProductLineOrderByWithAggregationInput[]
    by: ProductLineScalarFieldEnum[] | ProductLineScalarFieldEnum
    having?: ProductLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductLineCountAggregateInputType | true
    _avg?: ProductLineAvgAggregateInputType
    _sum?: ProductLineSumAggregateInputType
    _min?: ProductLineMinAggregateInputType
    _max?: ProductLineMaxAggregateInputType
  }

  export type ProductLineGroupByOutputType = {
    id: number
    type: string | null
    name: string | null
    nameShort: string | null
    nameAbbreviation: string | null
    notes: string | null
    webAddress: string | null
    _count: ProductLineCountAggregateOutputType | null
    _avg: ProductLineAvgAggregateOutputType | null
    _sum: ProductLineSumAggregateOutputType | null
    _min: ProductLineMinAggregateOutputType | null
    _max: ProductLineMaxAggregateOutputType | null
  }

  type GetProductLineGroupByPayload<T extends ProductLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductLineGroupByOutputType[P]>
            : GetScalarType<T[P], ProductLineGroupByOutputType[P]>
        }
      >
    >


  export type ProductLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    nameShort?: boolean
    nameAbbreviation?: boolean
    notes?: boolean
    webAddress?: boolean
    labelMemberships?: boolean | ProductLine$labelMembershipsArgs<ExtArgs>
    items?: boolean | ProductLine$itemsArgs<ExtArgs>
    _count?: boolean | ProductLineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productLine"]>

  export type ProductLineSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    nameShort?: boolean
    nameAbbreviation?: boolean
    notes?: boolean
    webAddress?: boolean
  }

  export type ProductLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labelMemberships?: boolean | ProductLine$labelMembershipsArgs<ExtArgs>
    items?: boolean | ProductLine$itemsArgs<ExtArgs>
    _count?: boolean | ProductLineCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductLine"
    objects: {
      labelMemberships: Prisma.$BrandMemberPayload<ExtArgs>[]
      items: Prisma.$PartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      name: string | null
      nameShort: string | null
      nameAbbreviation: string | null
      notes: string | null
      webAddress: string | null
    }, ExtArgs["result"]["productLine"]>
    composites: {}
  }


  type ProductLineGetPayload<S extends boolean | null | undefined | ProductLineDefaultArgs> = $Result.GetResult<Prisma.$ProductLinePayload, S>

  type ProductLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductLineFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProductLineCountAggregateInputType | true
    }

  export interface ProductLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductLine'], meta: { name: 'ProductLine' } }
    /**
     * Find zero or one ProductLine that matches the filter.
     * @param {ProductLineFindUniqueArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductLineFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductLineFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProductLine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductLineFindUniqueOrThrowArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductLineFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductLineFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProductLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineFindFirstArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductLineFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductLineFindFirstArgs<ExtArgs>>
    ): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProductLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineFindFirstOrThrowArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductLineFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductLineFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProductLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductLines
     * const productLines = await prisma.productLine.findMany()
     * 
     * // Get first 10 ProductLines
     * const productLines = await prisma.productLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productLineWithIdOnly = await prisma.productLine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductLineFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductLineFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProductLine.
     * @param {ProductLineCreateArgs} args - Arguments to create a ProductLine.
     * @example
     * // Create one ProductLine
     * const ProductLine = await prisma.productLine.create({
     *   data: {
     *     // ... data to create a ProductLine
     *   }
     * })
     * 
    **/
    create<T extends ProductLineCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductLineCreateArgs<ExtArgs>>
    ): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProductLines.
     *     @param {ProductLineCreateManyArgs} args - Arguments to create many ProductLines.
     *     @example
     *     // Create many ProductLines
     *     const productLine = await prisma.productLine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductLineCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductLineCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductLine.
     * @param {ProductLineDeleteArgs} args - Arguments to delete one ProductLine.
     * @example
     * // Delete one ProductLine
     * const ProductLine = await prisma.productLine.delete({
     *   where: {
     *     // ... filter to delete one ProductLine
     *   }
     * })
     * 
    **/
    delete<T extends ProductLineDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductLineDeleteArgs<ExtArgs>>
    ): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProductLine.
     * @param {ProductLineUpdateArgs} args - Arguments to update one ProductLine.
     * @example
     * // Update one ProductLine
     * const productLine = await prisma.productLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductLineUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductLineUpdateArgs<ExtArgs>>
    ): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProductLines.
     * @param {ProductLineDeleteManyArgs} args - Arguments to filter ProductLines to delete.
     * @example
     * // Delete a few ProductLines
     * const { count } = await prisma.productLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductLineDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductLineDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductLines
     * const productLine = await prisma.productLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductLineUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductLineUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductLine.
     * @param {ProductLineUpsertArgs} args - Arguments to update or create a ProductLine.
     * @example
     * // Update or create a ProductLine
     * const productLine = await prisma.productLine.upsert({
     *   create: {
     *     // ... data to create a ProductLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductLine we want to update
     *   }
     * })
    **/
    upsert<T extends ProductLineUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductLineUpsertArgs<ExtArgs>>
    ): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProductLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineCountArgs} args - Arguments to filter ProductLines to count.
     * @example
     * // Count the number of ProductLines
     * const count = await prisma.productLine.count({
     *   where: {
     *     // ... the filter for the ProductLines we want to count
     *   }
     * })
    **/
    count<T extends ProductLineCountArgs>(
      args?: Subset<T, ProductLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductLineAggregateArgs>(args: Subset<T, ProductLineAggregateArgs>): Prisma.PrismaPromise<GetProductLineAggregateType<T>>

    /**
     * Group by ProductLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductLineGroupByArgs['orderBy'] }
        : { orderBy?: ProductLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductLine model
   */
  readonly fields: ProductLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    labelMemberships<T extends ProductLine$labelMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, ProductLine$labelMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandMemberPayload<ExtArgs>, T, 'findMany'> | Null>;

    items<T extends ProductLine$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductLine$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProductLine model
   */ 
  interface ProductLineFieldRefs {
    readonly id: FieldRef<"ProductLine", 'Int'>
    readonly type: FieldRef<"ProductLine", 'String'>
    readonly name: FieldRef<"ProductLine", 'String'>
    readonly nameShort: FieldRef<"ProductLine", 'String'>
    readonly nameAbbreviation: FieldRef<"ProductLine", 'String'>
    readonly notes: FieldRef<"ProductLine", 'String'>
    readonly webAddress: FieldRef<"ProductLine", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ProductLine findUnique
   */
  export type ProductLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine findUniqueOrThrow
   */
  export type ProductLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine findFirst
   */
  export type ProductLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: ProductLineOrderByWithRelationInput | ProductLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLines.
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLines.
     */
    distinct?: ProductLineScalarFieldEnum | ProductLineScalarFieldEnum[]
  }


  /**
   * ProductLine findFirstOrThrow
   */
  export type ProductLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: ProductLineOrderByWithRelationInput | ProductLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLines.
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLines.
     */
    distinct?: ProductLineScalarFieldEnum | ProductLineScalarFieldEnum[]
  }


  /**
   * ProductLine findMany
   */
  export type ProductLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    /**
     * Filter, which ProductLines to fetch.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: ProductLineOrderByWithRelationInput | ProductLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductLines.
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    distinct?: ProductLineScalarFieldEnum | ProductLineScalarFieldEnum[]
  }


  /**
   * ProductLine create
   */
  export type ProductLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductLine.
     */
    data?: XOR<ProductLineCreateInput, ProductLineUncheckedCreateInput>
  }


  /**
   * ProductLine createMany
   */
  export type ProductLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductLines.
     */
    data: ProductLineCreateManyInput | ProductLineCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProductLine update
   */
  export type ProductLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductLine.
     */
    data: XOR<ProductLineUpdateInput, ProductLineUncheckedUpdateInput>
    /**
     * Choose, which ProductLine to update.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine updateMany
   */
  export type ProductLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductLines.
     */
    data: XOR<ProductLineUpdateManyMutationInput, ProductLineUncheckedUpdateManyInput>
    /**
     * Filter which ProductLines to update
     */
    where?: ProductLineWhereInput
  }


  /**
   * ProductLine upsert
   */
  export type ProductLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductLine to update in case it exists.
     */
    where: ProductLineWhereUniqueInput
    /**
     * In case the ProductLine found by the `where` argument doesn't exist, create a new ProductLine with this data.
     */
    create: XOR<ProductLineCreateInput, ProductLineUncheckedCreateInput>
    /**
     * In case the ProductLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductLineUpdateInput, ProductLineUncheckedUpdateInput>
  }


  /**
   * ProductLine delete
   */
  export type ProductLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    /**
     * Filter which ProductLine to delete.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine deleteMany
   */
  export type ProductLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductLines to delete
     */
    where?: ProductLineWhereInput
  }


  /**
   * ProductLine.labelMemberships
   */
  export type ProductLine$labelMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandMember
     */
    select?: BrandMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandMemberInclude<ExtArgs> | null
    where?: BrandMemberWhereInput
    orderBy?: BrandMemberOrderByWithRelationInput | BrandMemberOrderByWithRelationInput[]
    cursor?: BrandMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrandMemberScalarFieldEnum | BrandMemberScalarFieldEnum[]
  }


  /**
   * ProductLine.items
   */
  export type ProductLine$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    cursor?: PartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }


  /**
   * ProductLine without action
   */
  export type ProductLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
  }



  /**
   * Model PropertyGroup
   */

  export type AggregatePropertyGroup = {
    _count: PropertyGroupCountAggregateOutputType | null
    _avg: PropertyGroupAvgAggregateOutputType | null
    _sum: PropertyGroupSumAggregateOutputType | null
    _min: PropertyGroupMinAggregateOutputType | null
    _max: PropertyGroupMaxAggregateOutputType | null
  }

  export type PropertyGroupAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type PropertyGroupSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type PropertyGroupMinAggregateOutputType = {
    id: number | null
    order: number | null
    name: string | null
    description: string | null
  }

  export type PropertyGroupMaxAggregateOutputType = {
    id: number | null
    order: number | null
    name: string | null
    description: string | null
  }

  export type PropertyGroupCountAggregateOutputType = {
    id: number
    order: number
    name: number
    description: number
    _all: number
  }


  export type PropertyGroupAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type PropertyGroupSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type PropertyGroupMinAggregateInputType = {
    id?: true
    order?: true
    name?: true
    description?: true
  }

  export type PropertyGroupMaxAggregateInputType = {
    id?: true
    order?: true
    name?: true
    description?: true
  }

  export type PropertyGroupCountAggregateInputType = {
    id?: true
    order?: true
    name?: true
    description?: true
    _all?: true
  }

  export type PropertyGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyGroup to aggregate.
     */
    where?: PropertyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroups to fetch.
     */
    orderBy?: PropertyGroupOrderByWithRelationInput | PropertyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyGroups
    **/
    _count?: true | PropertyGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyGroupMaxAggregateInputType
  }

  export type GetPropertyGroupAggregateType<T extends PropertyGroupAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyGroup[P]>
      : GetScalarType<T[P], AggregatePropertyGroup[P]>
  }




  export type PropertyGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyGroupWhereInput
    orderBy?: PropertyGroupOrderByWithAggregationInput | PropertyGroupOrderByWithAggregationInput[]
    by: PropertyGroupScalarFieldEnum[] | PropertyGroupScalarFieldEnum
    having?: PropertyGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyGroupCountAggregateInputType | true
    _avg?: PropertyGroupAvgAggregateInputType
    _sum?: PropertyGroupSumAggregateInputType
    _min?: PropertyGroupMinAggregateInputType
    _max?: PropertyGroupMaxAggregateInputType
  }

  export type PropertyGroupGroupByOutputType = {
    id: number
    order: number | null
    name: string
    description: string | null
    _count: PropertyGroupCountAggregateOutputType | null
    _avg: PropertyGroupAvgAggregateOutputType | null
    _sum: PropertyGroupSumAggregateOutputType | null
    _min: PropertyGroupMinAggregateOutputType | null
    _max: PropertyGroupMaxAggregateOutputType | null
  }

  type GetPropertyGroupGroupByPayload<T extends PropertyGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupGroupByOutputType[P]>
        }
      >
    >


  export type PropertyGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    name?: boolean
    description?: boolean
    propertyTypes?: boolean | PropertyGroup$propertyTypesArgs<ExtArgs>
    _count?: boolean | PropertyGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyGroup"]>

  export type PropertyGroupSelectScalar = {
    id?: boolean
    order?: boolean
    name?: boolean
    description?: boolean
  }

  export type PropertyGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyTypes?: boolean | PropertyGroup$propertyTypesArgs<ExtArgs>
    _count?: boolean | PropertyGroupCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PropertyGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyGroup"
    objects: {
      propertyTypes: Prisma.$PropertyGroupMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      order: number | null
      name: string
      description: string | null
    }, ExtArgs["result"]["propertyGroup"]>
    composites: {}
  }


  type PropertyGroupGetPayload<S extends boolean | null | undefined | PropertyGroupDefaultArgs> = $Result.GetResult<Prisma.$PropertyGroupPayload, S>

  type PropertyGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyGroupFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PropertyGroupCountAggregateInputType | true
    }

  export interface PropertyGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyGroup'], meta: { name: 'PropertyGroup' } }
    /**
     * Find zero or one PropertyGroup that matches the filter.
     * @param {PropertyGroupFindUniqueArgs} args - Arguments to find a PropertyGroup
     * @example
     * // Get one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyGroupFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupFindUniqueArgs<ExtArgs>>
    ): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PropertyGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PropertyGroupFindUniqueOrThrowArgs} args - Arguments to find a PropertyGroup
     * @example
     * // Get one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PropertyGroupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PropertyGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupFindFirstArgs} args - Arguments to find a PropertyGroup
     * @example
     * // Get one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyGroupFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupFindFirstArgs<ExtArgs>>
    ): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PropertyGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupFindFirstOrThrowArgs} args - Arguments to find a PropertyGroup
     * @example
     * // Get one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PropertyGroupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PropertyGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyGroups
     * const propertyGroups = await prisma.propertyGroup.findMany()
     * 
     * // Get first 10 PropertyGroups
     * const propertyGroups = await prisma.propertyGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyGroupWithIdOnly = await prisma.propertyGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyGroupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PropertyGroup.
     * @param {PropertyGroupCreateArgs} args - Arguments to create a PropertyGroup.
     * @example
     * // Create one PropertyGroup
     * const PropertyGroup = await prisma.propertyGroup.create({
     *   data: {
     *     // ... data to create a PropertyGroup
     *   }
     * })
     * 
    **/
    create<T extends PropertyGroupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupCreateArgs<ExtArgs>>
    ): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PropertyGroups.
     *     @param {PropertyGroupCreateManyArgs} args - Arguments to create many PropertyGroups.
     *     @example
     *     // Create many PropertyGroups
     *     const propertyGroup = await prisma.propertyGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PropertyGroupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyGroup.
     * @param {PropertyGroupDeleteArgs} args - Arguments to delete one PropertyGroup.
     * @example
     * // Delete one PropertyGroup
     * const PropertyGroup = await prisma.propertyGroup.delete({
     *   where: {
     *     // ... filter to delete one PropertyGroup
     *   }
     * })
     * 
    **/
    delete<T extends PropertyGroupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupDeleteArgs<ExtArgs>>
    ): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PropertyGroup.
     * @param {PropertyGroupUpdateArgs} args - Arguments to update one PropertyGroup.
     * @example
     * // Update one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyGroupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupUpdateArgs<ExtArgs>>
    ): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PropertyGroups.
     * @param {PropertyGroupDeleteManyArgs} args - Arguments to filter PropertyGroups to delete.
     * @example
     * // Delete a few PropertyGroups
     * const { count } = await prisma.propertyGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyGroupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyGroups
     * const propertyGroup = await prisma.propertyGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyGroupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyGroup.
     * @param {PropertyGroupUpsertArgs} args - Arguments to update or create a PropertyGroup.
     * @example
     * // Update or create a PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.upsert({
     *   create: {
     *     // ... data to create a PropertyGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyGroup we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyGroupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupUpsertArgs<ExtArgs>>
    ): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PropertyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupCountArgs} args - Arguments to filter PropertyGroups to count.
     * @example
     * // Count the number of PropertyGroups
     * const count = await prisma.propertyGroup.count({
     *   where: {
     *     // ... the filter for the PropertyGroups we want to count
     *   }
     * })
    **/
    count<T extends PropertyGroupCountArgs>(
      args?: Subset<T, PropertyGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyGroupAggregateArgs>(args: Subset<T, PropertyGroupAggregateArgs>): Prisma.PrismaPromise<GetPropertyGroupAggregateType<T>>

    /**
     * Group by PropertyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyGroup model
   */
  readonly fields: PropertyGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    propertyTypes<T extends PropertyGroup$propertyTypesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyGroup$propertyTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PropertyGroup model
   */ 
  interface PropertyGroupFieldRefs {
    readonly id: FieldRef<"PropertyGroup", 'Int'>
    readonly order: FieldRef<"PropertyGroup", 'Int'>
    readonly name: FieldRef<"PropertyGroup", 'String'>
    readonly description: FieldRef<"PropertyGroup", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PropertyGroup findUnique
   */
  export type PropertyGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroup to fetch.
     */
    where: PropertyGroupWhereUniqueInput
  }


  /**
   * PropertyGroup findUniqueOrThrow
   */
  export type PropertyGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroup to fetch.
     */
    where: PropertyGroupWhereUniqueInput
  }


  /**
   * PropertyGroup findFirst
   */
  export type PropertyGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroup to fetch.
     */
    where?: PropertyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroups to fetch.
     */
    orderBy?: PropertyGroupOrderByWithRelationInput | PropertyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyGroups.
     */
    cursor?: PropertyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyGroups.
     */
    distinct?: PropertyGroupScalarFieldEnum | PropertyGroupScalarFieldEnum[]
  }


  /**
   * PropertyGroup findFirstOrThrow
   */
  export type PropertyGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroup to fetch.
     */
    where?: PropertyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroups to fetch.
     */
    orderBy?: PropertyGroupOrderByWithRelationInput | PropertyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyGroups.
     */
    cursor?: PropertyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyGroups.
     */
    distinct?: PropertyGroupScalarFieldEnum | PropertyGroupScalarFieldEnum[]
  }


  /**
   * PropertyGroup findMany
   */
  export type PropertyGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroups to fetch.
     */
    where?: PropertyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroups to fetch.
     */
    orderBy?: PropertyGroupOrderByWithRelationInput | PropertyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyGroups.
     */
    cursor?: PropertyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroups.
     */
    skip?: number
    distinct?: PropertyGroupScalarFieldEnum | PropertyGroupScalarFieldEnum[]
  }


  /**
   * PropertyGroup create
   */
  export type PropertyGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyGroup.
     */
    data: XOR<PropertyGroupCreateInput, PropertyGroupUncheckedCreateInput>
  }


  /**
   * PropertyGroup createMany
   */
  export type PropertyGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyGroups.
     */
    data: PropertyGroupCreateManyInput | PropertyGroupCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PropertyGroup update
   */
  export type PropertyGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyGroup.
     */
    data: XOR<PropertyGroupUpdateInput, PropertyGroupUncheckedUpdateInput>
    /**
     * Choose, which PropertyGroup to update.
     */
    where: PropertyGroupWhereUniqueInput
  }


  /**
   * PropertyGroup updateMany
   */
  export type PropertyGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyGroups.
     */
    data: XOR<PropertyGroupUpdateManyMutationInput, PropertyGroupUncheckedUpdateManyInput>
    /**
     * Filter which PropertyGroups to update
     */
    where?: PropertyGroupWhereInput
  }


  /**
   * PropertyGroup upsert
   */
  export type PropertyGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyGroup to update in case it exists.
     */
    where: PropertyGroupWhereUniqueInput
    /**
     * In case the PropertyGroup found by the `where` argument doesn't exist, create a new PropertyGroup with this data.
     */
    create: XOR<PropertyGroupCreateInput, PropertyGroupUncheckedCreateInput>
    /**
     * In case the PropertyGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyGroupUpdateInput, PropertyGroupUncheckedUpdateInput>
  }


  /**
   * PropertyGroup delete
   */
  export type PropertyGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter which PropertyGroup to delete.
     */
    where: PropertyGroupWhereUniqueInput
  }


  /**
   * PropertyGroup deleteMany
   */
  export type PropertyGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyGroups to delete
     */
    where?: PropertyGroupWhereInput
  }


  /**
   * PropertyGroup.propertyTypes
   */
  export type PropertyGroup$propertyTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    where?: PropertyGroupMembershipWhereInput
    orderBy?: PropertyGroupMembershipOrderByWithRelationInput | PropertyGroupMembershipOrderByWithRelationInput[]
    cursor?: PropertyGroupMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyGroupMembershipScalarFieldEnum | PropertyGroupMembershipScalarFieldEnum[]
  }


  /**
   * PropertyGroup without action
   */
  export type PropertyGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
  }



  /**
   * Model PropertyGroupMembership
   */

  export type AggregatePropertyGroupMembership = {
    _count: PropertyGroupMembershipCountAggregateOutputType | null
    _avg: PropertyGroupMembershipAvgAggregateOutputType | null
    _sum: PropertyGroupMembershipSumAggregateOutputType | null
    _min: PropertyGroupMembershipMinAggregateOutputType | null
    _max: PropertyGroupMembershipMaxAggregateOutputType | null
  }

  export type PropertyGroupMembershipAvgAggregateOutputType = {
    id: number | null
    partTypeId: number | null
    propertyTypeId: number | null
    groupId: number | null
  }

  export type PropertyGroupMembershipSumAggregateOutputType = {
    id: number | null
    partTypeId: number | null
    propertyTypeId: number | null
    groupId: number | null
  }

  export type PropertyGroupMembershipMinAggregateOutputType = {
    id: number | null
    partTypeId: number | null
    propertyTypeId: number | null
    groupId: number | null
  }

  export type PropertyGroupMembershipMaxAggregateOutputType = {
    id: number | null
    partTypeId: number | null
    propertyTypeId: number | null
    groupId: number | null
  }

  export type PropertyGroupMembershipCountAggregateOutputType = {
    id: number
    partTypeId: number
    propertyTypeId: number
    groupId: number
    _all: number
  }


  export type PropertyGroupMembershipAvgAggregateInputType = {
    id?: true
    partTypeId?: true
    propertyTypeId?: true
    groupId?: true
  }

  export type PropertyGroupMembershipSumAggregateInputType = {
    id?: true
    partTypeId?: true
    propertyTypeId?: true
    groupId?: true
  }

  export type PropertyGroupMembershipMinAggregateInputType = {
    id?: true
    partTypeId?: true
    propertyTypeId?: true
    groupId?: true
  }

  export type PropertyGroupMembershipMaxAggregateInputType = {
    id?: true
    partTypeId?: true
    propertyTypeId?: true
    groupId?: true
  }

  export type PropertyGroupMembershipCountAggregateInputType = {
    id?: true
    partTypeId?: true
    propertyTypeId?: true
    groupId?: true
    _all?: true
  }

  export type PropertyGroupMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyGroupMembership to aggregate.
     */
    where?: PropertyGroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroupMemberships to fetch.
     */
    orderBy?: PropertyGroupMembershipOrderByWithRelationInput | PropertyGroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyGroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroupMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyGroupMemberships
    **/
    _count?: true | PropertyGroupMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyGroupMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyGroupMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyGroupMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyGroupMembershipMaxAggregateInputType
  }

  export type GetPropertyGroupMembershipAggregateType<T extends PropertyGroupMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyGroupMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyGroupMembership[P]>
      : GetScalarType<T[P], AggregatePropertyGroupMembership[P]>
  }




  export type PropertyGroupMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyGroupMembershipWhereInput
    orderBy?: PropertyGroupMembershipOrderByWithAggregationInput | PropertyGroupMembershipOrderByWithAggregationInput[]
    by: PropertyGroupMembershipScalarFieldEnum[] | PropertyGroupMembershipScalarFieldEnum
    having?: PropertyGroupMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyGroupMembershipCountAggregateInputType | true
    _avg?: PropertyGroupMembershipAvgAggregateInputType
    _sum?: PropertyGroupMembershipSumAggregateInputType
    _min?: PropertyGroupMembershipMinAggregateInputType
    _max?: PropertyGroupMembershipMaxAggregateInputType
  }

  export type PropertyGroupMembershipGroupByOutputType = {
    id: number
    partTypeId: number | null
    propertyTypeId: number | null
    groupId: number | null
    _count: PropertyGroupMembershipCountAggregateOutputType | null
    _avg: PropertyGroupMembershipAvgAggregateOutputType | null
    _sum: PropertyGroupMembershipSumAggregateOutputType | null
    _min: PropertyGroupMembershipMinAggregateOutputType | null
    _max: PropertyGroupMembershipMaxAggregateOutputType | null
  }

  type GetPropertyGroupMembershipGroupByPayload<T extends PropertyGroupMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupMembershipGroupByOutputType[P]>
        }
      >
    >


  export type PropertyGroupMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partTypeId?: boolean
    propertyTypeId?: boolean
    groupId?: boolean
    partType?: boolean | PropertyGroupMembership$partTypeArgs<ExtArgs>
    propertyType?: boolean | PropertyGroupMembership$propertyTypeArgs<ExtArgs>
    group?: boolean | PropertyGroupMembership$groupArgs<ExtArgs>
  }, ExtArgs["result"]["propertyGroupMembership"]>

  export type PropertyGroupMembershipSelectScalar = {
    id?: boolean
    partTypeId?: boolean
    propertyTypeId?: boolean
    groupId?: boolean
  }

  export type PropertyGroupMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partType?: boolean | PropertyGroupMembership$partTypeArgs<ExtArgs>
    propertyType?: boolean | PropertyGroupMembership$propertyTypeArgs<ExtArgs>
    group?: boolean | PropertyGroupMembership$groupArgs<ExtArgs>
  }


  export type $PropertyGroupMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyGroupMembership"
    objects: {
      partType: Prisma.$PartTypePayload<ExtArgs> | null
      propertyType: Prisma.$PropertyTypePayload<ExtArgs> | null
      group: Prisma.$PropertyGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      partTypeId: number | null
      propertyTypeId: number | null
      groupId: number | null
    }, ExtArgs["result"]["propertyGroupMembership"]>
    composites: {}
  }


  type PropertyGroupMembershipGetPayload<S extends boolean | null | undefined | PropertyGroupMembershipDefaultArgs> = $Result.GetResult<Prisma.$PropertyGroupMembershipPayload, S>

  type PropertyGroupMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyGroupMembershipFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PropertyGroupMembershipCountAggregateInputType | true
    }

  export interface PropertyGroupMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyGroupMembership'], meta: { name: 'PropertyGroupMembership' } }
    /**
     * Find zero or one PropertyGroupMembership that matches the filter.
     * @param {PropertyGroupMembershipFindUniqueArgs} args - Arguments to find a PropertyGroupMembership
     * @example
     * // Get one PropertyGroupMembership
     * const propertyGroupMembership = await prisma.propertyGroupMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyGroupMembershipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupMembershipFindUniqueArgs<ExtArgs>>
    ): Prisma__PropertyGroupMembershipClient<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PropertyGroupMembership that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PropertyGroupMembershipFindUniqueOrThrowArgs} args - Arguments to find a PropertyGroupMembership
     * @example
     * // Get one PropertyGroupMembership
     * const propertyGroupMembership = await prisma.propertyGroupMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PropertyGroupMembershipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupMembershipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyGroupMembershipClient<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PropertyGroupMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupMembershipFindFirstArgs} args - Arguments to find a PropertyGroupMembership
     * @example
     * // Get one PropertyGroupMembership
     * const propertyGroupMembership = await prisma.propertyGroupMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyGroupMembershipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupMembershipFindFirstArgs<ExtArgs>>
    ): Prisma__PropertyGroupMembershipClient<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PropertyGroupMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupMembershipFindFirstOrThrowArgs} args - Arguments to find a PropertyGroupMembership
     * @example
     * // Get one PropertyGroupMembership
     * const propertyGroupMembership = await prisma.propertyGroupMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PropertyGroupMembershipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupMembershipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyGroupMembershipClient<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PropertyGroupMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupMembershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyGroupMemberships
     * const propertyGroupMemberships = await prisma.propertyGroupMembership.findMany()
     * 
     * // Get first 10 PropertyGroupMemberships
     * const propertyGroupMemberships = await prisma.propertyGroupMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyGroupMembershipWithIdOnly = await prisma.propertyGroupMembership.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyGroupMembershipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupMembershipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PropertyGroupMembership.
     * @param {PropertyGroupMembershipCreateArgs} args - Arguments to create a PropertyGroupMembership.
     * @example
     * // Create one PropertyGroupMembership
     * const PropertyGroupMembership = await prisma.propertyGroupMembership.create({
     *   data: {
     *     // ... data to create a PropertyGroupMembership
     *   }
     * })
     * 
    **/
    create<T extends PropertyGroupMembershipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupMembershipCreateArgs<ExtArgs>>
    ): Prisma__PropertyGroupMembershipClient<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PropertyGroupMemberships.
     *     @param {PropertyGroupMembershipCreateManyArgs} args - Arguments to create many PropertyGroupMemberships.
     *     @example
     *     // Create many PropertyGroupMemberships
     *     const propertyGroupMembership = await prisma.propertyGroupMembership.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PropertyGroupMembershipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupMembershipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyGroupMembership.
     * @param {PropertyGroupMembershipDeleteArgs} args - Arguments to delete one PropertyGroupMembership.
     * @example
     * // Delete one PropertyGroupMembership
     * const PropertyGroupMembership = await prisma.propertyGroupMembership.delete({
     *   where: {
     *     // ... filter to delete one PropertyGroupMembership
     *   }
     * })
     * 
    **/
    delete<T extends PropertyGroupMembershipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupMembershipDeleteArgs<ExtArgs>>
    ): Prisma__PropertyGroupMembershipClient<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PropertyGroupMembership.
     * @param {PropertyGroupMembershipUpdateArgs} args - Arguments to update one PropertyGroupMembership.
     * @example
     * // Update one PropertyGroupMembership
     * const propertyGroupMembership = await prisma.propertyGroupMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyGroupMembershipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupMembershipUpdateArgs<ExtArgs>>
    ): Prisma__PropertyGroupMembershipClient<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PropertyGroupMemberships.
     * @param {PropertyGroupMembershipDeleteManyArgs} args - Arguments to filter PropertyGroupMemberships to delete.
     * @example
     * // Delete a few PropertyGroupMemberships
     * const { count } = await prisma.propertyGroupMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyGroupMembershipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyGroupMembershipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyGroupMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyGroupMemberships
     * const propertyGroupMembership = await prisma.propertyGroupMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyGroupMembershipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupMembershipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyGroupMembership.
     * @param {PropertyGroupMembershipUpsertArgs} args - Arguments to update or create a PropertyGroupMembership.
     * @example
     * // Update or create a PropertyGroupMembership
     * const propertyGroupMembership = await prisma.propertyGroupMembership.upsert({
     *   create: {
     *     // ... data to create a PropertyGroupMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyGroupMembership we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyGroupMembershipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyGroupMembershipUpsertArgs<ExtArgs>>
    ): Prisma__PropertyGroupMembershipClient<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PropertyGroupMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupMembershipCountArgs} args - Arguments to filter PropertyGroupMemberships to count.
     * @example
     * // Count the number of PropertyGroupMemberships
     * const count = await prisma.propertyGroupMembership.count({
     *   where: {
     *     // ... the filter for the PropertyGroupMemberships we want to count
     *   }
     * })
    **/
    count<T extends PropertyGroupMembershipCountArgs>(
      args?: Subset<T, PropertyGroupMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyGroupMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyGroupMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyGroupMembershipAggregateArgs>(args: Subset<T, PropertyGroupMembershipAggregateArgs>): Prisma.PrismaPromise<GetPropertyGroupMembershipAggregateType<T>>

    /**
     * Group by PropertyGroupMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupMembershipGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyGroupMembership model
   */
  readonly fields: PropertyGroupMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyGroupMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyGroupMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    partType<T extends PropertyGroupMembership$partTypeArgs<ExtArgs> = {}>(args?: Subset<T, PropertyGroupMembership$partTypeArgs<ExtArgs>>): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    propertyType<T extends PropertyGroupMembership$propertyTypeArgs<ExtArgs> = {}>(args?: Subset<T, PropertyGroupMembership$propertyTypeArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    group<T extends PropertyGroupMembership$groupArgs<ExtArgs> = {}>(args?: Subset<T, PropertyGroupMembership$groupArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PropertyGroupMembership model
   */ 
  interface PropertyGroupMembershipFieldRefs {
    readonly id: FieldRef<"PropertyGroupMembership", 'Int'>
    readonly partTypeId: FieldRef<"PropertyGroupMembership", 'Int'>
    readonly propertyTypeId: FieldRef<"PropertyGroupMembership", 'Int'>
    readonly groupId: FieldRef<"PropertyGroupMembership", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * PropertyGroupMembership findUnique
   */
  export type PropertyGroupMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroupMembership to fetch.
     */
    where: PropertyGroupMembershipWhereUniqueInput
  }


  /**
   * PropertyGroupMembership findUniqueOrThrow
   */
  export type PropertyGroupMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroupMembership to fetch.
     */
    where: PropertyGroupMembershipWhereUniqueInput
  }


  /**
   * PropertyGroupMembership findFirst
   */
  export type PropertyGroupMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroupMembership to fetch.
     */
    where?: PropertyGroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroupMemberships to fetch.
     */
    orderBy?: PropertyGroupMembershipOrderByWithRelationInput | PropertyGroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyGroupMemberships.
     */
    cursor?: PropertyGroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroupMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyGroupMemberships.
     */
    distinct?: PropertyGroupMembershipScalarFieldEnum | PropertyGroupMembershipScalarFieldEnum[]
  }


  /**
   * PropertyGroupMembership findFirstOrThrow
   */
  export type PropertyGroupMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroupMembership to fetch.
     */
    where?: PropertyGroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroupMemberships to fetch.
     */
    orderBy?: PropertyGroupMembershipOrderByWithRelationInput | PropertyGroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyGroupMemberships.
     */
    cursor?: PropertyGroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroupMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyGroupMemberships.
     */
    distinct?: PropertyGroupMembershipScalarFieldEnum | PropertyGroupMembershipScalarFieldEnum[]
  }


  /**
   * PropertyGroupMembership findMany
   */
  export type PropertyGroupMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroupMemberships to fetch.
     */
    where?: PropertyGroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroupMemberships to fetch.
     */
    orderBy?: PropertyGroupMembershipOrderByWithRelationInput | PropertyGroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyGroupMemberships.
     */
    cursor?: PropertyGroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroupMemberships.
     */
    skip?: number
    distinct?: PropertyGroupMembershipScalarFieldEnum | PropertyGroupMembershipScalarFieldEnum[]
  }


  /**
   * PropertyGroupMembership create
   */
  export type PropertyGroupMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyGroupMembership.
     */
    data?: XOR<PropertyGroupMembershipCreateInput, PropertyGroupMembershipUncheckedCreateInput>
  }


  /**
   * PropertyGroupMembership createMany
   */
  export type PropertyGroupMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyGroupMemberships.
     */
    data: PropertyGroupMembershipCreateManyInput | PropertyGroupMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PropertyGroupMembership update
   */
  export type PropertyGroupMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyGroupMembership.
     */
    data: XOR<PropertyGroupMembershipUpdateInput, PropertyGroupMembershipUncheckedUpdateInput>
    /**
     * Choose, which PropertyGroupMembership to update.
     */
    where: PropertyGroupMembershipWhereUniqueInput
  }


  /**
   * PropertyGroupMembership updateMany
   */
  export type PropertyGroupMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyGroupMemberships.
     */
    data: XOR<PropertyGroupMembershipUpdateManyMutationInput, PropertyGroupMembershipUncheckedUpdateManyInput>
    /**
     * Filter which PropertyGroupMemberships to update
     */
    where?: PropertyGroupMembershipWhereInput
  }


  /**
   * PropertyGroupMembership upsert
   */
  export type PropertyGroupMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyGroupMembership to update in case it exists.
     */
    where: PropertyGroupMembershipWhereUniqueInput
    /**
     * In case the PropertyGroupMembership found by the `where` argument doesn't exist, create a new PropertyGroupMembership with this data.
     */
    create: XOR<PropertyGroupMembershipCreateInput, PropertyGroupMembershipUncheckedCreateInput>
    /**
     * In case the PropertyGroupMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyGroupMembershipUpdateInput, PropertyGroupMembershipUncheckedUpdateInput>
  }


  /**
   * PropertyGroupMembership delete
   */
  export type PropertyGroupMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter which PropertyGroupMembership to delete.
     */
    where: PropertyGroupMembershipWhereUniqueInput
  }


  /**
   * PropertyGroupMembership deleteMany
   */
  export type PropertyGroupMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyGroupMemberships to delete
     */
    where?: PropertyGroupMembershipWhereInput
  }


  /**
   * PropertyGroupMembership.partType
   */
  export type PropertyGroupMembership$partTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    where?: PartTypeWhereInput
  }


  /**
   * PropertyGroupMembership.propertyType
   */
  export type PropertyGroupMembership$propertyTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    where?: PropertyTypeWhereInput
  }


  /**
   * PropertyGroupMembership.group
   */
  export type PropertyGroupMembership$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    where?: PropertyGroupWhereInput
  }


  /**
   * PropertyGroupMembership without action
   */
  export type PropertyGroupMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
  }



  /**
   * Model PropertyType
   */

  export type AggregatePropertyType = {
    _count: PropertyTypeCountAggregateOutputType | null
    _avg: PropertyTypeAvgAggregateOutputType | null
    _sum: PropertyTypeSumAggregateOutputType | null
    _min: PropertyTypeMinAggregateOutputType | null
    _max: PropertyTypeMaxAggregateOutputType | null
  }

  export type PropertyTypeAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type PropertyTypeSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type PropertyTypeMinAggregateOutputType = {
    id: number | null
    order: number | null
    name: string | null
    description: string | null
    valueDataType: string | null
    valueDataTypeModifier: string | null
    variation: string | null
  }

  export type PropertyTypeMaxAggregateOutputType = {
    id: number | null
    order: number | null
    name: string | null
    description: string | null
    valueDataType: string | null
    valueDataTypeModifier: string | null
    variation: string | null
  }

  export type PropertyTypeCountAggregateOutputType = {
    id: number
    order: number
    name: number
    description: number
    valueDataType: number
    valueDataTypeModifier: number
    variation: number
    _all: number
  }


  export type PropertyTypeAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type PropertyTypeSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type PropertyTypeMinAggregateInputType = {
    id?: true
    order?: true
    name?: true
    description?: true
    valueDataType?: true
    valueDataTypeModifier?: true
    variation?: true
  }

  export type PropertyTypeMaxAggregateInputType = {
    id?: true
    order?: true
    name?: true
    description?: true
    valueDataType?: true
    valueDataTypeModifier?: true
    variation?: true
  }

  export type PropertyTypeCountAggregateInputType = {
    id?: true
    order?: true
    name?: true
    description?: true
    valueDataType?: true
    valueDataTypeModifier?: true
    variation?: true
    _all?: true
  }

  export type PropertyTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyType to aggregate.
     */
    where?: PropertyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypes to fetch.
     */
    orderBy?: PropertyTypeOrderByWithRelationInput | PropertyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyTypes
    **/
    _count?: true | PropertyTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyTypeMaxAggregateInputType
  }

  export type GetPropertyTypeAggregateType<T extends PropertyTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyType[P]>
      : GetScalarType<T[P], AggregatePropertyType[P]>
  }




  export type PropertyTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyTypeWhereInput
    orderBy?: PropertyTypeOrderByWithAggregationInput | PropertyTypeOrderByWithAggregationInput[]
    by: PropertyTypeScalarFieldEnum[] | PropertyTypeScalarFieldEnum
    having?: PropertyTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyTypeCountAggregateInputType | true
    _avg?: PropertyTypeAvgAggregateInputType
    _sum?: PropertyTypeSumAggregateInputType
    _min?: PropertyTypeMinAggregateInputType
    _max?: PropertyTypeMaxAggregateInputType
  }

  export type PropertyTypeGroupByOutputType = {
    id: number
    order: number | null
    name: string | null
    description: string | null
    valueDataType: string | null
    valueDataTypeModifier: string | null
    variation: string | null
    _count: PropertyTypeCountAggregateOutputType | null
    _avg: PropertyTypeAvgAggregateOutputType | null
    _sum: PropertyTypeSumAggregateOutputType | null
    _min: PropertyTypeMinAggregateOutputType | null
    _max: PropertyTypeMaxAggregateOutputType | null
  }

  type GetPropertyTypeGroupByPayload<T extends PropertyTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyTypeGroupByOutputType[P]>
        }
      >
    >


  export type PropertyTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    name?: boolean
    description?: boolean
    valueDataType?: boolean
    valueDataTypeModifier?: boolean
    variation?: boolean
    groups?: boolean | PropertyType$groupsArgs<ExtArgs>
    properties?: boolean | PropertyType$propertiesArgs<ExtArgs>
    lookupValues?: boolean | PropertyType$lookupValuesArgs<ExtArgs>
    _count?: boolean | PropertyTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyType"]>

  export type PropertyTypeSelectScalar = {
    id?: boolean
    order?: boolean
    name?: boolean
    description?: boolean
    valueDataType?: boolean
    valueDataTypeModifier?: boolean
    variation?: boolean
  }

  export type PropertyTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | PropertyType$groupsArgs<ExtArgs>
    properties?: boolean | PropertyType$propertiesArgs<ExtArgs>
    lookupValues?: boolean | PropertyType$lookupValuesArgs<ExtArgs>
    _count?: boolean | PropertyTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PropertyTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyType"
    objects: {
      groups: Prisma.$PropertyGroupMembershipPayload<ExtArgs>[]
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      lookupValues: Prisma.$PropertyLookupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      order: number | null
      name: string | null
      description: string | null
      valueDataType: string | null
      valueDataTypeModifier: string | null
      variation: string | null
    }, ExtArgs["result"]["propertyType"]>
    composites: {}
  }


  type PropertyTypeGetPayload<S extends boolean | null | undefined | PropertyTypeDefaultArgs> = $Result.GetResult<Prisma.$PropertyTypePayload, S>

  type PropertyTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyTypeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PropertyTypeCountAggregateInputType | true
    }

  export interface PropertyTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyType'], meta: { name: 'PropertyType' } }
    /**
     * Find zero or one PropertyType that matches the filter.
     * @param {PropertyTypeFindUniqueArgs} args - Arguments to find a PropertyType
     * @example
     * // Get one PropertyType
     * const propertyType = await prisma.propertyType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PropertyType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PropertyTypeFindUniqueOrThrowArgs} args - Arguments to find a PropertyType
     * @example
     * // Get one PropertyType
     * const propertyType = await prisma.propertyType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PropertyTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PropertyType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeFindFirstArgs} args - Arguments to find a PropertyType
     * @example
     * // Get one PropertyType
     * const propertyType = await prisma.propertyType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyTypeFindFirstArgs<ExtArgs>>
    ): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PropertyType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeFindFirstOrThrowArgs} args - Arguments to find a PropertyType
     * @example
     * // Get one PropertyType
     * const propertyType = await prisma.propertyType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PropertyTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PropertyTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyTypes
     * const propertyTypes = await prisma.propertyType.findMany()
     * 
     * // Get first 10 PropertyTypes
     * const propertyTypes = await prisma.propertyType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyTypeWithIdOnly = await prisma.propertyType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PropertyType.
     * @param {PropertyTypeCreateArgs} args - Arguments to create a PropertyType.
     * @example
     * // Create one PropertyType
     * const PropertyType = await prisma.propertyType.create({
     *   data: {
     *     // ... data to create a PropertyType
     *   }
     * })
     * 
    **/
    create<T extends PropertyTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyTypeCreateArgs<ExtArgs>>
    ): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PropertyTypes.
     *     @param {PropertyTypeCreateManyArgs} args - Arguments to create many PropertyTypes.
     *     @example
     *     // Create many PropertyTypes
     *     const propertyType = await prisma.propertyType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PropertyTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyType.
     * @param {PropertyTypeDeleteArgs} args - Arguments to delete one PropertyType.
     * @example
     * // Delete one PropertyType
     * const PropertyType = await prisma.propertyType.delete({
     *   where: {
     *     // ... filter to delete one PropertyType
     *   }
     * })
     * 
    **/
    delete<T extends PropertyTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyTypeDeleteArgs<ExtArgs>>
    ): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PropertyType.
     * @param {PropertyTypeUpdateArgs} args - Arguments to update one PropertyType.
     * @example
     * // Update one PropertyType
     * const propertyType = await prisma.propertyType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyTypeUpdateArgs<ExtArgs>>
    ): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PropertyTypes.
     * @param {PropertyTypeDeleteManyArgs} args - Arguments to filter PropertyTypes to delete.
     * @example
     * // Delete a few PropertyTypes
     * const { count } = await prisma.propertyType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyTypes
     * const propertyType = await prisma.propertyType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyType.
     * @param {PropertyTypeUpsertArgs} args - Arguments to update or create a PropertyType.
     * @example
     * // Update or create a PropertyType
     * const propertyType = await prisma.propertyType.upsert({
     *   create: {
     *     // ... data to create a PropertyType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyType we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyTypeUpsertArgs<ExtArgs>>
    ): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PropertyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeCountArgs} args - Arguments to filter PropertyTypes to count.
     * @example
     * // Count the number of PropertyTypes
     * const count = await prisma.propertyType.count({
     *   where: {
     *     // ... the filter for the PropertyTypes we want to count
     *   }
     * })
    **/
    count<T extends PropertyTypeCountArgs>(
      args?: Subset<T, PropertyTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyTypeAggregateArgs>(args: Subset<T, PropertyTypeAggregateArgs>): Prisma.PrismaPromise<GetPropertyTypeAggregateType<T>>

    /**
     * Group by PropertyType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyTypeGroupByArgs['orderBy'] }
        : { orderBy?: PropertyTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyType model
   */
  readonly fields: PropertyTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    groups<T extends PropertyType$groupsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyType$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'findMany'> | Null>;

    properties<T extends PropertyType$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyType$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'findMany'> | Null>;

    lookupValues<T extends PropertyType$lookupValuesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyType$lookupValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PropertyType model
   */ 
  interface PropertyTypeFieldRefs {
    readonly id: FieldRef<"PropertyType", 'Int'>
    readonly order: FieldRef<"PropertyType", 'Int'>
    readonly name: FieldRef<"PropertyType", 'String'>
    readonly description: FieldRef<"PropertyType", 'String'>
    readonly valueDataType: FieldRef<"PropertyType", 'String'>
    readonly valueDataTypeModifier: FieldRef<"PropertyType", 'String'>
    readonly variation: FieldRef<"PropertyType", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PropertyType findUnique
   */
  export type PropertyTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyType to fetch.
     */
    where: PropertyTypeWhereUniqueInput
  }


  /**
   * PropertyType findUniqueOrThrow
   */
  export type PropertyTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyType to fetch.
     */
    where: PropertyTypeWhereUniqueInput
  }


  /**
   * PropertyType findFirst
   */
  export type PropertyTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyType to fetch.
     */
    where?: PropertyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypes to fetch.
     */
    orderBy?: PropertyTypeOrderByWithRelationInput | PropertyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTypes.
     */
    cursor?: PropertyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTypes.
     */
    distinct?: PropertyTypeScalarFieldEnum | PropertyTypeScalarFieldEnum[]
  }


  /**
   * PropertyType findFirstOrThrow
   */
  export type PropertyTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyType to fetch.
     */
    where?: PropertyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypes to fetch.
     */
    orderBy?: PropertyTypeOrderByWithRelationInput | PropertyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTypes.
     */
    cursor?: PropertyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTypes.
     */
    distinct?: PropertyTypeScalarFieldEnum | PropertyTypeScalarFieldEnum[]
  }


  /**
   * PropertyType findMany
   */
  export type PropertyTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTypes to fetch.
     */
    where?: PropertyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTypes to fetch.
     */
    orderBy?: PropertyTypeOrderByWithRelationInput | PropertyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyTypes.
     */
    cursor?: PropertyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTypes.
     */
    skip?: number
    distinct?: PropertyTypeScalarFieldEnum | PropertyTypeScalarFieldEnum[]
  }


  /**
   * PropertyType create
   */
  export type PropertyTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyType.
     */
    data?: XOR<PropertyTypeCreateInput, PropertyTypeUncheckedCreateInput>
  }


  /**
   * PropertyType createMany
   */
  export type PropertyTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyTypes.
     */
    data: PropertyTypeCreateManyInput | PropertyTypeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PropertyType update
   */
  export type PropertyTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyType.
     */
    data: XOR<PropertyTypeUpdateInput, PropertyTypeUncheckedUpdateInput>
    /**
     * Choose, which PropertyType to update.
     */
    where: PropertyTypeWhereUniqueInput
  }


  /**
   * PropertyType updateMany
   */
  export type PropertyTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyTypes.
     */
    data: XOR<PropertyTypeUpdateManyMutationInput, PropertyTypeUncheckedUpdateManyInput>
    /**
     * Filter which PropertyTypes to update
     */
    where?: PropertyTypeWhereInput
  }


  /**
   * PropertyType upsert
   */
  export type PropertyTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyType to update in case it exists.
     */
    where: PropertyTypeWhereUniqueInput
    /**
     * In case the PropertyType found by the `where` argument doesn't exist, create a new PropertyType with this data.
     */
    create: XOR<PropertyTypeCreateInput, PropertyTypeUncheckedCreateInput>
    /**
     * In case the PropertyType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyTypeUpdateInput, PropertyTypeUncheckedUpdateInput>
  }


  /**
   * PropertyType delete
   */
  export type PropertyTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    /**
     * Filter which PropertyType to delete.
     */
    where: PropertyTypeWhereUniqueInput
  }


  /**
   * PropertyType deleteMany
   */
  export type PropertyTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTypes to delete
     */
    where?: PropertyTypeWhereInput
  }


  /**
   * PropertyType.groups
   */
  export type PropertyType$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    where?: PropertyGroupMembershipWhereInput
    orderBy?: PropertyGroupMembershipOrderByWithRelationInput | PropertyGroupMembershipOrderByWithRelationInput[]
    cursor?: PropertyGroupMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyGroupMembershipScalarFieldEnum | PropertyGroupMembershipScalarFieldEnum[]
  }


  /**
   * PropertyType.properties
   */
  export type PropertyType$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }


  /**
   * PropertyType.lookupValues
   */
  export type PropertyType$lookupValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    where?: PropertyLookupWhereInput
    orderBy?: PropertyLookupOrderByWithRelationInput | PropertyLookupOrderByWithRelationInput[]
    cursor?: PropertyLookupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyLookupScalarFieldEnum | PropertyLookupScalarFieldEnum[]
  }


  /**
   * PropertyType without action
   */
  export type PropertyTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
  }



  /**
   * Model PropertyLookup
   */

  export type AggregatePropertyLookup = {
    _count: PropertyLookupCountAggregateOutputType | null
    _avg: PropertyLookupAvgAggregateOutputType | null
    _sum: PropertyLookupSumAggregateOutputType | null
    _min: PropertyLookupMinAggregateOutputType | null
    _max: PropertyLookupMaxAggregateOutputType | null
  }

  export type PropertyLookupAvgAggregateOutputType = {
    id: number | null
    propertyTypeId: number | null
  }

  export type PropertyLookupSumAggregateOutputType = {
    id: number | null
    propertyTypeId: number | null
  }

  export type PropertyLookupMinAggregateOutputType = {
    id: number | null
    value: string | null
    propertyTypeId: number | null
  }

  export type PropertyLookupMaxAggregateOutputType = {
    id: number | null
    value: string | null
    propertyTypeId: number | null
  }

  export type PropertyLookupCountAggregateOutputType = {
    id: number
    value: number
    propertyTypeId: number
    _all: number
  }


  export type PropertyLookupAvgAggregateInputType = {
    id?: true
    propertyTypeId?: true
  }

  export type PropertyLookupSumAggregateInputType = {
    id?: true
    propertyTypeId?: true
  }

  export type PropertyLookupMinAggregateInputType = {
    id?: true
    value?: true
    propertyTypeId?: true
  }

  export type PropertyLookupMaxAggregateInputType = {
    id?: true
    value?: true
    propertyTypeId?: true
  }

  export type PropertyLookupCountAggregateInputType = {
    id?: true
    value?: true
    propertyTypeId?: true
    _all?: true
  }

  export type PropertyLookupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyLookup to aggregate.
     */
    where?: PropertyLookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLookups to fetch.
     */
    orderBy?: PropertyLookupOrderByWithRelationInput | PropertyLookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyLookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLookups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyLookups
    **/
    _count?: true | PropertyLookupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyLookupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyLookupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyLookupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyLookupMaxAggregateInputType
  }

  export type GetPropertyLookupAggregateType<T extends PropertyLookupAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyLookup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyLookup[P]>
      : GetScalarType<T[P], AggregatePropertyLookup[P]>
  }




  export type PropertyLookupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyLookupWhereInput
    orderBy?: PropertyLookupOrderByWithAggregationInput | PropertyLookupOrderByWithAggregationInput[]
    by: PropertyLookupScalarFieldEnum[] | PropertyLookupScalarFieldEnum
    having?: PropertyLookupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyLookupCountAggregateInputType | true
    _avg?: PropertyLookupAvgAggregateInputType
    _sum?: PropertyLookupSumAggregateInputType
    _min?: PropertyLookupMinAggregateInputType
    _max?: PropertyLookupMaxAggregateInputType
  }

  export type PropertyLookupGroupByOutputType = {
    id: number
    value: string | null
    propertyTypeId: number | null
    _count: PropertyLookupCountAggregateOutputType | null
    _avg: PropertyLookupAvgAggregateOutputType | null
    _sum: PropertyLookupSumAggregateOutputType | null
    _min: PropertyLookupMinAggregateOutputType | null
    _max: PropertyLookupMaxAggregateOutputType | null
  }

  type GetPropertyLookupGroupByPayload<T extends PropertyLookupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyLookupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyLookupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyLookupGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyLookupGroupByOutputType[P]>
        }
      >
    >


  export type PropertyLookupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    propertyTypeId?: boolean
    propertyType?: boolean | PropertyLookup$propertyTypeArgs<ExtArgs>
  }, ExtArgs["result"]["propertyLookup"]>

  export type PropertyLookupSelectScalar = {
    id?: boolean
    value?: boolean
    propertyTypeId?: boolean
  }

  export type PropertyLookupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyType?: boolean | PropertyLookup$propertyTypeArgs<ExtArgs>
  }


  export type $PropertyLookupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyLookup"
    objects: {
      propertyType: Prisma.$PropertyTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string | null
      propertyTypeId: number | null
    }, ExtArgs["result"]["propertyLookup"]>
    composites: {}
  }


  type PropertyLookupGetPayload<S extends boolean | null | undefined | PropertyLookupDefaultArgs> = $Result.GetResult<Prisma.$PropertyLookupPayload, S>

  type PropertyLookupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyLookupFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PropertyLookupCountAggregateInputType | true
    }

  export interface PropertyLookupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyLookup'], meta: { name: 'PropertyLookup' } }
    /**
     * Find zero or one PropertyLookup that matches the filter.
     * @param {PropertyLookupFindUniqueArgs} args - Arguments to find a PropertyLookup
     * @example
     * // Get one PropertyLookup
     * const propertyLookup = await prisma.propertyLookup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyLookupFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyLookupFindUniqueArgs<ExtArgs>>
    ): Prisma__PropertyLookupClient<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PropertyLookup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PropertyLookupFindUniqueOrThrowArgs} args - Arguments to find a PropertyLookup
     * @example
     * // Get one PropertyLookup
     * const propertyLookup = await prisma.propertyLookup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PropertyLookupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyLookupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyLookupClient<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PropertyLookup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLookupFindFirstArgs} args - Arguments to find a PropertyLookup
     * @example
     * // Get one PropertyLookup
     * const propertyLookup = await prisma.propertyLookup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyLookupFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyLookupFindFirstArgs<ExtArgs>>
    ): Prisma__PropertyLookupClient<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PropertyLookup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLookupFindFirstOrThrowArgs} args - Arguments to find a PropertyLookup
     * @example
     * // Get one PropertyLookup
     * const propertyLookup = await prisma.propertyLookup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PropertyLookupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyLookupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyLookupClient<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PropertyLookups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLookupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyLookups
     * const propertyLookups = await prisma.propertyLookup.findMany()
     * 
     * // Get first 10 PropertyLookups
     * const propertyLookups = await prisma.propertyLookup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyLookupWithIdOnly = await prisma.propertyLookup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyLookupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyLookupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PropertyLookup.
     * @param {PropertyLookupCreateArgs} args - Arguments to create a PropertyLookup.
     * @example
     * // Create one PropertyLookup
     * const PropertyLookup = await prisma.propertyLookup.create({
     *   data: {
     *     // ... data to create a PropertyLookup
     *   }
     * })
     * 
    **/
    create<T extends PropertyLookupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyLookupCreateArgs<ExtArgs>>
    ): Prisma__PropertyLookupClient<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PropertyLookups.
     *     @param {PropertyLookupCreateManyArgs} args - Arguments to create many PropertyLookups.
     *     @example
     *     // Create many PropertyLookups
     *     const propertyLookup = await prisma.propertyLookup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PropertyLookupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyLookupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyLookup.
     * @param {PropertyLookupDeleteArgs} args - Arguments to delete one PropertyLookup.
     * @example
     * // Delete one PropertyLookup
     * const PropertyLookup = await prisma.propertyLookup.delete({
     *   where: {
     *     // ... filter to delete one PropertyLookup
     *   }
     * })
     * 
    **/
    delete<T extends PropertyLookupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyLookupDeleteArgs<ExtArgs>>
    ): Prisma__PropertyLookupClient<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PropertyLookup.
     * @param {PropertyLookupUpdateArgs} args - Arguments to update one PropertyLookup.
     * @example
     * // Update one PropertyLookup
     * const propertyLookup = await prisma.propertyLookup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyLookupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyLookupUpdateArgs<ExtArgs>>
    ): Prisma__PropertyLookupClient<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PropertyLookups.
     * @param {PropertyLookupDeleteManyArgs} args - Arguments to filter PropertyLookups to delete.
     * @example
     * // Delete a few PropertyLookups
     * const { count } = await prisma.propertyLookup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyLookupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyLookupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyLookups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLookupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyLookups
     * const propertyLookup = await prisma.propertyLookup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyLookupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyLookupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyLookup.
     * @param {PropertyLookupUpsertArgs} args - Arguments to update or create a PropertyLookup.
     * @example
     * // Update or create a PropertyLookup
     * const propertyLookup = await prisma.propertyLookup.upsert({
     *   create: {
     *     // ... data to create a PropertyLookup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyLookup we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyLookupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyLookupUpsertArgs<ExtArgs>>
    ): Prisma__PropertyLookupClient<$Result.GetResult<Prisma.$PropertyLookupPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PropertyLookups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLookupCountArgs} args - Arguments to filter PropertyLookups to count.
     * @example
     * // Count the number of PropertyLookups
     * const count = await prisma.propertyLookup.count({
     *   where: {
     *     // ... the filter for the PropertyLookups we want to count
     *   }
     * })
    **/
    count<T extends PropertyLookupCountArgs>(
      args?: Subset<T, PropertyLookupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyLookupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyLookup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLookupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyLookupAggregateArgs>(args: Subset<T, PropertyLookupAggregateArgs>): Prisma.PrismaPromise<GetPropertyLookupAggregateType<T>>

    /**
     * Group by PropertyLookup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyLookupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyLookupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyLookupGroupByArgs['orderBy'] }
        : { orderBy?: PropertyLookupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyLookupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyLookupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyLookup model
   */
  readonly fields: PropertyLookupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyLookup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyLookupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    propertyType<T extends PropertyLookup$propertyTypeArgs<ExtArgs> = {}>(args?: Subset<T, PropertyLookup$propertyTypeArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PropertyLookup model
   */ 
  interface PropertyLookupFieldRefs {
    readonly id: FieldRef<"PropertyLookup", 'Int'>
    readonly value: FieldRef<"PropertyLookup", 'String'>
    readonly propertyTypeId: FieldRef<"PropertyLookup", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * PropertyLookup findUnique
   */
  export type PropertyLookupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLookup to fetch.
     */
    where: PropertyLookupWhereUniqueInput
  }


  /**
   * PropertyLookup findUniqueOrThrow
   */
  export type PropertyLookupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLookup to fetch.
     */
    where: PropertyLookupWhereUniqueInput
  }


  /**
   * PropertyLookup findFirst
   */
  export type PropertyLookupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLookup to fetch.
     */
    where?: PropertyLookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLookups to fetch.
     */
    orderBy?: PropertyLookupOrderByWithRelationInput | PropertyLookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyLookups.
     */
    cursor?: PropertyLookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLookups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyLookups.
     */
    distinct?: PropertyLookupScalarFieldEnum | PropertyLookupScalarFieldEnum[]
  }


  /**
   * PropertyLookup findFirstOrThrow
   */
  export type PropertyLookupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLookup to fetch.
     */
    where?: PropertyLookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLookups to fetch.
     */
    orderBy?: PropertyLookupOrderByWithRelationInput | PropertyLookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyLookups.
     */
    cursor?: PropertyLookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLookups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyLookups.
     */
    distinct?: PropertyLookupScalarFieldEnum | PropertyLookupScalarFieldEnum[]
  }


  /**
   * PropertyLookup findMany
   */
  export type PropertyLookupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyLookups to fetch.
     */
    where?: PropertyLookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyLookups to fetch.
     */
    orderBy?: PropertyLookupOrderByWithRelationInput | PropertyLookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyLookups.
     */
    cursor?: PropertyLookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyLookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyLookups.
     */
    skip?: number
    distinct?: PropertyLookupScalarFieldEnum | PropertyLookupScalarFieldEnum[]
  }


  /**
   * PropertyLookup create
   */
  export type PropertyLookupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyLookup.
     */
    data?: XOR<PropertyLookupCreateInput, PropertyLookupUncheckedCreateInput>
  }


  /**
   * PropertyLookup createMany
   */
  export type PropertyLookupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyLookups.
     */
    data: PropertyLookupCreateManyInput | PropertyLookupCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PropertyLookup update
   */
  export type PropertyLookupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyLookup.
     */
    data: XOR<PropertyLookupUpdateInput, PropertyLookupUncheckedUpdateInput>
    /**
     * Choose, which PropertyLookup to update.
     */
    where: PropertyLookupWhereUniqueInput
  }


  /**
   * PropertyLookup updateMany
   */
  export type PropertyLookupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyLookups.
     */
    data: XOR<PropertyLookupUpdateManyMutationInput, PropertyLookupUncheckedUpdateManyInput>
    /**
     * Filter which PropertyLookups to update
     */
    where?: PropertyLookupWhereInput
  }


  /**
   * PropertyLookup upsert
   */
  export type PropertyLookupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyLookup to update in case it exists.
     */
    where: PropertyLookupWhereUniqueInput
    /**
     * In case the PropertyLookup found by the `where` argument doesn't exist, create a new PropertyLookup with this data.
     */
    create: XOR<PropertyLookupCreateInput, PropertyLookupUncheckedCreateInput>
    /**
     * In case the PropertyLookup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyLookupUpdateInput, PropertyLookupUncheckedUpdateInput>
  }


  /**
   * PropertyLookup delete
   */
  export type PropertyLookupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
    /**
     * Filter which PropertyLookup to delete.
     */
    where: PropertyLookupWhereUniqueInput
  }


  /**
   * PropertyLookup deleteMany
   */
  export type PropertyLookupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyLookups to delete
     */
    where?: PropertyLookupWhereInput
  }


  /**
   * PropertyLookup.propertyType
   */
  export type PropertyLookup$propertyTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    where?: PropertyTypeWhereInput
  }


  /**
   * PropertyLookup without action
   */
  export type PropertyLookupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyLookup
     */
    select?: PropertyLookupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyLookupInclude<ExtArgs> | null
  }



  /**
   * Model PartClass
   */

  export type AggregatePartClass = {
    _count: PartClassCountAggregateOutputType | null
    _avg: PartClassAvgAggregateOutputType | null
    _sum: PartClassSumAggregateOutputType | null
    _min: PartClassMinAggregateOutputType | null
    _max: PartClassMaxAggregateOutputType | null
  }

  export type PartClassAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type PartClassSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type PartClassMinAggregateOutputType = {
    id: number | null
    order: number | null
    name: string | null
  }

  export type PartClassMaxAggregateOutputType = {
    id: number | null
    order: number | null
    name: string | null
  }

  export type PartClassCountAggregateOutputType = {
    id: number
    order: number
    name: number
    _all: number
  }


  export type PartClassAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type PartClassSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type PartClassMinAggregateInputType = {
    id?: true
    order?: true
    name?: true
  }

  export type PartClassMaxAggregateInputType = {
    id?: true
    order?: true
    name?: true
  }

  export type PartClassCountAggregateInputType = {
    id?: true
    order?: true
    name?: true
    _all?: true
  }

  export type PartClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartClass to aggregate.
     */
    where?: PartClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartClasses to fetch.
     */
    orderBy?: PartClassOrderByWithRelationInput | PartClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartClasses
    **/
    _count?: true | PartClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartClassMaxAggregateInputType
  }

  export type GetPartClassAggregateType<T extends PartClassAggregateArgs> = {
        [P in keyof T & keyof AggregatePartClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartClass[P]>
      : GetScalarType<T[P], AggregatePartClass[P]>
  }




  export type PartClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartClassWhereInput
    orderBy?: PartClassOrderByWithAggregationInput | PartClassOrderByWithAggregationInput[]
    by: PartClassScalarFieldEnum[] | PartClassScalarFieldEnum
    having?: PartClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartClassCountAggregateInputType | true
    _avg?: PartClassAvgAggregateInputType
    _sum?: PartClassSumAggregateInputType
    _min?: PartClassMinAggregateInputType
    _max?: PartClassMaxAggregateInputType
  }

  export type PartClassGroupByOutputType = {
    id: number
    order: number | null
    name: string
    _count: PartClassCountAggregateOutputType | null
    _avg: PartClassAvgAggregateOutputType | null
    _sum: PartClassSumAggregateOutputType | null
    _min: PartClassMinAggregateOutputType | null
    _max: PartClassMaxAggregateOutputType | null
  }

  type GetPartClassGroupByPayload<T extends PartClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartClassGroupByOutputType[P]>
            : GetScalarType<T[P], PartClassGroupByOutputType[P]>
        }
      >
    >


  export type PartClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    name?: boolean
    partTypes?: boolean | PartClass$partTypesArgs<ExtArgs>
    _count?: boolean | PartClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partClass"]>

  export type PartClassSelectScalar = {
    id?: boolean
    order?: boolean
    name?: boolean
  }

  export type PartClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partTypes?: boolean | PartClass$partTypesArgs<ExtArgs>
    _count?: boolean | PartClassCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PartClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartClass"
    objects: {
      partTypes: Prisma.$PartClassMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      order: number | null
      name: string
    }, ExtArgs["result"]["partClass"]>
    composites: {}
  }


  type PartClassGetPayload<S extends boolean | null | undefined | PartClassDefaultArgs> = $Result.GetResult<Prisma.$PartClassPayload, S>

  type PartClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartClassFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PartClassCountAggregateInputType | true
    }

  export interface PartClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartClass'], meta: { name: 'PartClass' } }
    /**
     * Find zero or one PartClass that matches the filter.
     * @param {PartClassFindUniqueArgs} args - Arguments to find a PartClass
     * @example
     * // Get one PartClass
     * const partClass = await prisma.partClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartClassFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassFindUniqueArgs<ExtArgs>>
    ): Prisma__PartClassClient<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PartClass that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartClassFindUniqueOrThrowArgs} args - Arguments to find a PartClass
     * @example
     * // Get one PartClass
     * const partClass = await prisma.partClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartClassFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PartClassClient<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PartClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassFindFirstArgs} args - Arguments to find a PartClass
     * @example
     * // Get one PartClass
     * const partClass = await prisma.partClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartClassFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassFindFirstArgs<ExtArgs>>
    ): Prisma__PartClassClient<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PartClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassFindFirstOrThrowArgs} args - Arguments to find a PartClass
     * @example
     * // Get one PartClass
     * const partClass = await prisma.partClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartClassFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PartClassClient<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PartClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartClasses
     * const partClasses = await prisma.partClass.findMany()
     * 
     * // Get first 10 PartClasses
     * const partClasses = await prisma.partClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partClassWithIdOnly = await prisma.partClass.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartClassFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PartClass.
     * @param {PartClassCreateArgs} args - Arguments to create a PartClass.
     * @example
     * // Create one PartClass
     * const PartClass = await prisma.partClass.create({
     *   data: {
     *     // ... data to create a PartClass
     *   }
     * })
     * 
    **/
    create<T extends PartClassCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassCreateArgs<ExtArgs>>
    ): Prisma__PartClassClient<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PartClasses.
     *     @param {PartClassCreateManyArgs} args - Arguments to create many PartClasses.
     *     @example
     *     // Create many PartClasses
     *     const partClass = await prisma.partClass.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartClassCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PartClass.
     * @param {PartClassDeleteArgs} args - Arguments to delete one PartClass.
     * @example
     * // Delete one PartClass
     * const PartClass = await prisma.partClass.delete({
     *   where: {
     *     // ... filter to delete one PartClass
     *   }
     * })
     * 
    **/
    delete<T extends PartClassDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassDeleteArgs<ExtArgs>>
    ): Prisma__PartClassClient<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PartClass.
     * @param {PartClassUpdateArgs} args - Arguments to update one PartClass.
     * @example
     * // Update one PartClass
     * const partClass = await prisma.partClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartClassUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassUpdateArgs<ExtArgs>>
    ): Prisma__PartClassClient<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PartClasses.
     * @param {PartClassDeleteManyArgs} args - Arguments to filter PartClasses to delete.
     * @example
     * // Delete a few PartClasses
     * const { count } = await prisma.partClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartClassDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartClasses
     * const partClass = await prisma.partClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartClassUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartClass.
     * @param {PartClassUpsertArgs} args - Arguments to update or create a PartClass.
     * @example
     * // Update or create a PartClass
     * const partClass = await prisma.partClass.upsert({
     *   create: {
     *     // ... data to create a PartClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartClass we want to update
     *   }
     * })
    **/
    upsert<T extends PartClassUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassUpsertArgs<ExtArgs>>
    ): Prisma__PartClassClient<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PartClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassCountArgs} args - Arguments to filter PartClasses to count.
     * @example
     * // Count the number of PartClasses
     * const count = await prisma.partClass.count({
     *   where: {
     *     // ... the filter for the PartClasses we want to count
     *   }
     * })
    **/
    count<T extends PartClassCountArgs>(
      args?: Subset<T, PartClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartClassAggregateArgs>(args: Subset<T, PartClassAggregateArgs>): Prisma.PrismaPromise<GetPartClassAggregateType<T>>

    /**
     * Group by PartClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartClassGroupByArgs['orderBy'] }
        : { orderBy?: PartClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartClass model
   */
  readonly fields: PartClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    partTypes<T extends PartClass$partTypesArgs<ExtArgs> = {}>(args?: Subset<T, PartClass$partTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PartClass model
   */ 
  interface PartClassFieldRefs {
    readonly id: FieldRef<"PartClass", 'Int'>
    readonly order: FieldRef<"PartClass", 'Int'>
    readonly name: FieldRef<"PartClass", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PartClass findUnique
   */
  export type PartClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    /**
     * Filter, which PartClass to fetch.
     */
    where: PartClassWhereUniqueInput
  }


  /**
   * PartClass findUniqueOrThrow
   */
  export type PartClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    /**
     * Filter, which PartClass to fetch.
     */
    where: PartClassWhereUniqueInput
  }


  /**
   * PartClass findFirst
   */
  export type PartClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    /**
     * Filter, which PartClass to fetch.
     */
    where?: PartClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartClasses to fetch.
     */
    orderBy?: PartClassOrderByWithRelationInput | PartClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartClasses.
     */
    cursor?: PartClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartClasses.
     */
    distinct?: PartClassScalarFieldEnum | PartClassScalarFieldEnum[]
  }


  /**
   * PartClass findFirstOrThrow
   */
  export type PartClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    /**
     * Filter, which PartClass to fetch.
     */
    where?: PartClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartClasses to fetch.
     */
    orderBy?: PartClassOrderByWithRelationInput | PartClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartClasses.
     */
    cursor?: PartClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartClasses.
     */
    distinct?: PartClassScalarFieldEnum | PartClassScalarFieldEnum[]
  }


  /**
   * PartClass findMany
   */
  export type PartClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    /**
     * Filter, which PartClasses to fetch.
     */
    where?: PartClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartClasses to fetch.
     */
    orderBy?: PartClassOrderByWithRelationInput | PartClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartClasses.
     */
    cursor?: PartClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartClasses.
     */
    skip?: number
    distinct?: PartClassScalarFieldEnum | PartClassScalarFieldEnum[]
  }


  /**
   * PartClass create
   */
  export type PartClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    /**
     * The data needed to create a PartClass.
     */
    data: XOR<PartClassCreateInput, PartClassUncheckedCreateInput>
  }


  /**
   * PartClass createMany
   */
  export type PartClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartClasses.
     */
    data: PartClassCreateManyInput | PartClassCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PartClass update
   */
  export type PartClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    /**
     * The data needed to update a PartClass.
     */
    data: XOR<PartClassUpdateInput, PartClassUncheckedUpdateInput>
    /**
     * Choose, which PartClass to update.
     */
    where: PartClassWhereUniqueInput
  }


  /**
   * PartClass updateMany
   */
  export type PartClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartClasses.
     */
    data: XOR<PartClassUpdateManyMutationInput, PartClassUncheckedUpdateManyInput>
    /**
     * Filter which PartClasses to update
     */
    where?: PartClassWhereInput
  }


  /**
   * PartClass upsert
   */
  export type PartClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    /**
     * The filter to search for the PartClass to update in case it exists.
     */
    where: PartClassWhereUniqueInput
    /**
     * In case the PartClass found by the `where` argument doesn't exist, create a new PartClass with this data.
     */
    create: XOR<PartClassCreateInput, PartClassUncheckedCreateInput>
    /**
     * In case the PartClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartClassUpdateInput, PartClassUncheckedUpdateInput>
  }


  /**
   * PartClass delete
   */
  export type PartClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    /**
     * Filter which PartClass to delete.
     */
    where: PartClassWhereUniqueInput
  }


  /**
   * PartClass deleteMany
   */
  export type PartClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartClasses to delete
     */
    where?: PartClassWhereInput
  }


  /**
   * PartClass.partTypes
   */
  export type PartClass$partTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    where?: PartClassMembershipWhereInput
    orderBy?: PartClassMembershipOrderByWithRelationInput | PartClassMembershipOrderByWithRelationInput[]
    cursor?: PartClassMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartClassMembershipScalarFieldEnum | PartClassMembershipScalarFieldEnum[]
  }


  /**
   * PartClass without action
   */
  export type PartClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
  }



  /**
   * Model PartClassMembership
   */

  export type AggregatePartClassMembership = {
    _count: PartClassMembershipCountAggregateOutputType | null
    _avg: PartClassMembershipAvgAggregateOutputType | null
    _sum: PartClassMembershipSumAggregateOutputType | null
    _min: PartClassMembershipMinAggregateOutputType | null
    _max: PartClassMembershipMaxAggregateOutputType | null
  }

  export type PartClassMembershipAvgAggregateOutputType = {
    id: number | null
    partClassId: number | null
    partTypeId: number | null
  }

  export type PartClassMembershipSumAggregateOutputType = {
    id: number | null
    partClassId: number | null
    partTypeId: number | null
  }

  export type PartClassMembershipMinAggregateOutputType = {
    id: number | null
    partClassId: number | null
    partTypeId: number | null
  }

  export type PartClassMembershipMaxAggregateOutputType = {
    id: number | null
    partClassId: number | null
    partTypeId: number | null
  }

  export type PartClassMembershipCountAggregateOutputType = {
    id: number
    partClassId: number
    partTypeId: number
    _all: number
  }


  export type PartClassMembershipAvgAggregateInputType = {
    id?: true
    partClassId?: true
    partTypeId?: true
  }

  export type PartClassMembershipSumAggregateInputType = {
    id?: true
    partClassId?: true
    partTypeId?: true
  }

  export type PartClassMembershipMinAggregateInputType = {
    id?: true
    partClassId?: true
    partTypeId?: true
  }

  export type PartClassMembershipMaxAggregateInputType = {
    id?: true
    partClassId?: true
    partTypeId?: true
  }

  export type PartClassMembershipCountAggregateInputType = {
    id?: true
    partClassId?: true
    partTypeId?: true
    _all?: true
  }

  export type PartClassMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartClassMembership to aggregate.
     */
    where?: PartClassMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartClassMemberships to fetch.
     */
    orderBy?: PartClassMembershipOrderByWithRelationInput | PartClassMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartClassMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartClassMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartClassMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartClassMemberships
    **/
    _count?: true | PartClassMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartClassMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartClassMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartClassMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartClassMembershipMaxAggregateInputType
  }

  export type GetPartClassMembershipAggregateType<T extends PartClassMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregatePartClassMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartClassMembership[P]>
      : GetScalarType<T[P], AggregatePartClassMembership[P]>
  }




  export type PartClassMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartClassMembershipWhereInput
    orderBy?: PartClassMembershipOrderByWithAggregationInput | PartClassMembershipOrderByWithAggregationInput[]
    by: PartClassMembershipScalarFieldEnum[] | PartClassMembershipScalarFieldEnum
    having?: PartClassMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartClassMembershipCountAggregateInputType | true
    _avg?: PartClassMembershipAvgAggregateInputType
    _sum?: PartClassMembershipSumAggregateInputType
    _min?: PartClassMembershipMinAggregateInputType
    _max?: PartClassMembershipMaxAggregateInputType
  }

  export type PartClassMembershipGroupByOutputType = {
    id: number
    partClassId: number | null
    partTypeId: number | null
    _count: PartClassMembershipCountAggregateOutputType | null
    _avg: PartClassMembershipAvgAggregateOutputType | null
    _sum: PartClassMembershipSumAggregateOutputType | null
    _min: PartClassMembershipMinAggregateOutputType | null
    _max: PartClassMembershipMaxAggregateOutputType | null
  }

  type GetPartClassMembershipGroupByPayload<T extends PartClassMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartClassMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartClassMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartClassMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], PartClassMembershipGroupByOutputType[P]>
        }
      >
    >


  export type PartClassMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partClassId?: boolean
    partTypeId?: boolean
    partClass?: boolean | PartClassMembership$partClassArgs<ExtArgs>
    partType?: boolean | PartClassMembership$partTypeArgs<ExtArgs>
  }, ExtArgs["result"]["partClassMembership"]>

  export type PartClassMembershipSelectScalar = {
    id?: boolean
    partClassId?: boolean
    partTypeId?: boolean
  }

  export type PartClassMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partClass?: boolean | PartClassMembership$partClassArgs<ExtArgs>
    partType?: boolean | PartClassMembership$partTypeArgs<ExtArgs>
  }


  export type $PartClassMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartClassMembership"
    objects: {
      partClass: Prisma.$PartClassPayload<ExtArgs> | null
      partType: Prisma.$PartTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      partClassId: number | null
      partTypeId: number | null
    }, ExtArgs["result"]["partClassMembership"]>
    composites: {}
  }


  type PartClassMembershipGetPayload<S extends boolean | null | undefined | PartClassMembershipDefaultArgs> = $Result.GetResult<Prisma.$PartClassMembershipPayload, S>

  type PartClassMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartClassMembershipFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PartClassMembershipCountAggregateInputType | true
    }

  export interface PartClassMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartClassMembership'], meta: { name: 'PartClassMembership' } }
    /**
     * Find zero or one PartClassMembership that matches the filter.
     * @param {PartClassMembershipFindUniqueArgs} args - Arguments to find a PartClassMembership
     * @example
     * // Get one PartClassMembership
     * const partClassMembership = await prisma.partClassMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartClassMembershipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassMembershipFindUniqueArgs<ExtArgs>>
    ): Prisma__PartClassMembershipClient<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PartClassMembership that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartClassMembershipFindUniqueOrThrowArgs} args - Arguments to find a PartClassMembership
     * @example
     * // Get one PartClassMembership
     * const partClassMembership = await prisma.partClassMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartClassMembershipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassMembershipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PartClassMembershipClient<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PartClassMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassMembershipFindFirstArgs} args - Arguments to find a PartClassMembership
     * @example
     * // Get one PartClassMembership
     * const partClassMembership = await prisma.partClassMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartClassMembershipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassMembershipFindFirstArgs<ExtArgs>>
    ): Prisma__PartClassMembershipClient<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PartClassMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassMembershipFindFirstOrThrowArgs} args - Arguments to find a PartClassMembership
     * @example
     * // Get one PartClassMembership
     * const partClassMembership = await prisma.partClassMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartClassMembershipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassMembershipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PartClassMembershipClient<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PartClassMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassMembershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartClassMemberships
     * const partClassMemberships = await prisma.partClassMembership.findMany()
     * 
     * // Get first 10 PartClassMemberships
     * const partClassMemberships = await prisma.partClassMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partClassMembershipWithIdOnly = await prisma.partClassMembership.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartClassMembershipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassMembershipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PartClassMembership.
     * @param {PartClassMembershipCreateArgs} args - Arguments to create a PartClassMembership.
     * @example
     * // Create one PartClassMembership
     * const PartClassMembership = await prisma.partClassMembership.create({
     *   data: {
     *     // ... data to create a PartClassMembership
     *   }
     * })
     * 
    **/
    create<T extends PartClassMembershipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassMembershipCreateArgs<ExtArgs>>
    ): Prisma__PartClassMembershipClient<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PartClassMemberships.
     *     @param {PartClassMembershipCreateManyArgs} args - Arguments to create many PartClassMemberships.
     *     @example
     *     // Create many PartClassMemberships
     *     const partClassMembership = await prisma.partClassMembership.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartClassMembershipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassMembershipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PartClassMembership.
     * @param {PartClassMembershipDeleteArgs} args - Arguments to delete one PartClassMembership.
     * @example
     * // Delete one PartClassMembership
     * const PartClassMembership = await prisma.partClassMembership.delete({
     *   where: {
     *     // ... filter to delete one PartClassMembership
     *   }
     * })
     * 
    **/
    delete<T extends PartClassMembershipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassMembershipDeleteArgs<ExtArgs>>
    ): Prisma__PartClassMembershipClient<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PartClassMembership.
     * @param {PartClassMembershipUpdateArgs} args - Arguments to update one PartClassMembership.
     * @example
     * // Update one PartClassMembership
     * const partClassMembership = await prisma.partClassMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartClassMembershipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassMembershipUpdateArgs<ExtArgs>>
    ): Prisma__PartClassMembershipClient<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PartClassMemberships.
     * @param {PartClassMembershipDeleteManyArgs} args - Arguments to filter PartClassMemberships to delete.
     * @example
     * // Delete a few PartClassMemberships
     * const { count } = await prisma.partClassMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartClassMembershipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartClassMembershipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartClassMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartClassMemberships
     * const partClassMembership = await prisma.partClassMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartClassMembershipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassMembershipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartClassMembership.
     * @param {PartClassMembershipUpsertArgs} args - Arguments to update or create a PartClassMembership.
     * @example
     * // Update or create a PartClassMembership
     * const partClassMembership = await prisma.partClassMembership.upsert({
     *   create: {
     *     // ... data to create a PartClassMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartClassMembership we want to update
     *   }
     * })
    **/
    upsert<T extends PartClassMembershipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PartClassMembershipUpsertArgs<ExtArgs>>
    ): Prisma__PartClassMembershipClient<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PartClassMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassMembershipCountArgs} args - Arguments to filter PartClassMemberships to count.
     * @example
     * // Count the number of PartClassMemberships
     * const count = await prisma.partClassMembership.count({
     *   where: {
     *     // ... the filter for the PartClassMemberships we want to count
     *   }
     * })
    **/
    count<T extends PartClassMembershipCountArgs>(
      args?: Subset<T, PartClassMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartClassMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartClassMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartClassMembershipAggregateArgs>(args: Subset<T, PartClassMembershipAggregateArgs>): Prisma.PrismaPromise<GetPartClassMembershipAggregateType<T>>

    /**
     * Group by PartClassMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartClassMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartClassMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartClassMembershipGroupByArgs['orderBy'] }
        : { orderBy?: PartClassMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartClassMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartClassMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartClassMembership model
   */
  readonly fields: PartClassMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartClassMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartClassMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    partClass<T extends PartClassMembership$partClassArgs<ExtArgs> = {}>(args?: Subset<T, PartClassMembership$partClassArgs<ExtArgs>>): Prisma__PartClassClient<$Result.GetResult<Prisma.$PartClassPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    partType<T extends PartClassMembership$partTypeArgs<ExtArgs> = {}>(args?: Subset<T, PartClassMembership$partTypeArgs<ExtArgs>>): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PartClassMembership model
   */ 
  interface PartClassMembershipFieldRefs {
    readonly id: FieldRef<"PartClassMembership", 'Int'>
    readonly partClassId: FieldRef<"PartClassMembership", 'Int'>
    readonly partTypeId: FieldRef<"PartClassMembership", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * PartClassMembership findUnique
   */
  export type PartClassMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartClassMembership to fetch.
     */
    where: PartClassMembershipWhereUniqueInput
  }


  /**
   * PartClassMembership findUniqueOrThrow
   */
  export type PartClassMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartClassMembership to fetch.
     */
    where: PartClassMembershipWhereUniqueInput
  }


  /**
   * PartClassMembership findFirst
   */
  export type PartClassMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartClassMembership to fetch.
     */
    where?: PartClassMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartClassMemberships to fetch.
     */
    orderBy?: PartClassMembershipOrderByWithRelationInput | PartClassMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartClassMemberships.
     */
    cursor?: PartClassMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartClassMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartClassMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartClassMemberships.
     */
    distinct?: PartClassMembershipScalarFieldEnum | PartClassMembershipScalarFieldEnum[]
  }


  /**
   * PartClassMembership findFirstOrThrow
   */
  export type PartClassMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartClassMembership to fetch.
     */
    where?: PartClassMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartClassMemberships to fetch.
     */
    orderBy?: PartClassMembershipOrderByWithRelationInput | PartClassMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartClassMemberships.
     */
    cursor?: PartClassMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartClassMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartClassMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartClassMemberships.
     */
    distinct?: PartClassMembershipScalarFieldEnum | PartClassMembershipScalarFieldEnum[]
  }


  /**
   * PartClassMembership findMany
   */
  export type PartClassMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartClassMemberships to fetch.
     */
    where?: PartClassMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartClassMemberships to fetch.
     */
    orderBy?: PartClassMembershipOrderByWithRelationInput | PartClassMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartClassMemberships.
     */
    cursor?: PartClassMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartClassMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartClassMemberships.
     */
    skip?: number
    distinct?: PartClassMembershipScalarFieldEnum | PartClassMembershipScalarFieldEnum[]
  }


  /**
   * PartClassMembership create
   */
  export type PartClassMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a PartClassMembership.
     */
    data?: XOR<PartClassMembershipCreateInput, PartClassMembershipUncheckedCreateInput>
  }


  /**
   * PartClassMembership createMany
   */
  export type PartClassMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartClassMemberships.
     */
    data: PartClassMembershipCreateManyInput | PartClassMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PartClassMembership update
   */
  export type PartClassMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a PartClassMembership.
     */
    data: XOR<PartClassMembershipUpdateInput, PartClassMembershipUncheckedUpdateInput>
    /**
     * Choose, which PartClassMembership to update.
     */
    where: PartClassMembershipWhereUniqueInput
  }


  /**
   * PartClassMembership updateMany
   */
  export type PartClassMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartClassMemberships.
     */
    data: XOR<PartClassMembershipUpdateManyMutationInput, PartClassMembershipUncheckedUpdateManyInput>
    /**
     * Filter which PartClassMemberships to update
     */
    where?: PartClassMembershipWhereInput
  }


  /**
   * PartClassMembership upsert
   */
  export type PartClassMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the PartClassMembership to update in case it exists.
     */
    where: PartClassMembershipWhereUniqueInput
    /**
     * In case the PartClassMembership found by the `where` argument doesn't exist, create a new PartClassMembership with this data.
     */
    create: XOR<PartClassMembershipCreateInput, PartClassMembershipUncheckedCreateInput>
    /**
     * In case the PartClassMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartClassMembershipUpdateInput, PartClassMembershipUncheckedUpdateInput>
  }


  /**
   * PartClassMembership delete
   */
  export type PartClassMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    /**
     * Filter which PartClassMembership to delete.
     */
    where: PartClassMembershipWhereUniqueInput
  }


  /**
   * PartClassMembership deleteMany
   */
  export type PartClassMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartClassMemberships to delete
     */
    where?: PartClassMembershipWhereInput
  }


  /**
   * PartClassMembership.partClass
   */
  export type PartClassMembership$partClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClass
     */
    select?: PartClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassInclude<ExtArgs> | null
    where?: PartClassWhereInput
  }


  /**
   * PartClassMembership.partType
   */
  export type PartClassMembership$partTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    where?: PartTypeWhereInput
  }


  /**
   * PartClassMembership without action
   */
  export type PartClassMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
  }



  /**
   * Model PartType
   */

  export type AggregatePartType = {
    _count: PartTypeCountAggregateOutputType | null
    _avg: PartTypeAvgAggregateOutputType | null
    _sum: PartTypeSumAggregateOutputType | null
    _min: PartTypeMinAggregateOutputType | null
    _max: PartTypeMaxAggregateOutputType | null
  }

  export type PartTypeAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type PartTypeSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type PartTypeMinAggregateOutputType = {
    id: number | null
    order: number | null
    name: string | null
    description: string | null
  }

  export type PartTypeMaxAggregateOutputType = {
    id: number | null
    order: number | null
    name: string | null
    description: string | null
  }

  export type PartTypeCountAggregateOutputType = {
    id: number
    order: number
    name: number
    description: number
    _all: number
  }


  export type PartTypeAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type PartTypeSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type PartTypeMinAggregateInputType = {
    id?: true
    order?: true
    name?: true
    description?: true
  }

  export type PartTypeMaxAggregateInputType = {
    id?: true
    order?: true
    name?: true
    description?: true
  }

  export type PartTypeCountAggregateInputType = {
    id?: true
    order?: true
    name?: true
    description?: true
    _all?: true
  }

  export type PartTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartType to aggregate.
     */
    where?: PartTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartTypes to fetch.
     */
    orderBy?: PartTypeOrderByWithRelationInput | PartTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartTypes
    **/
    _count?: true | PartTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartTypeMaxAggregateInputType
  }

  export type GetPartTypeAggregateType<T extends PartTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePartType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartType[P]>
      : GetScalarType<T[P], AggregatePartType[P]>
  }




  export type PartTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartTypeWhereInput
    orderBy?: PartTypeOrderByWithAggregationInput | PartTypeOrderByWithAggregationInput[]
    by: PartTypeScalarFieldEnum[] | PartTypeScalarFieldEnum
    having?: PartTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartTypeCountAggregateInputType | true
    _avg?: PartTypeAvgAggregateInputType
    _sum?: PartTypeSumAggregateInputType
    _min?: PartTypeMinAggregateInputType
    _max?: PartTypeMaxAggregateInputType
  }

  export type PartTypeGroupByOutputType = {
    id: number
    order: number | null
    name: string
    description: string | null
    _count: PartTypeCountAggregateOutputType | null
    _avg: PartTypeAvgAggregateOutputType | null
    _sum: PartTypeSumAggregateOutputType | null
    _min: PartTypeMinAggregateOutputType | null
    _max: PartTypeMaxAggregateOutputType | null
  }

  type GetPartTypeGroupByPayload<T extends PartTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PartTypeGroupByOutputType[P]>
        }
      >
    >


  export type PartTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    name?: boolean
    description?: boolean
    propertyTypes?: boolean | PartType$propertyTypesArgs<ExtArgs>
    classes?: boolean | PartType$classesArgs<ExtArgs>
    _count?: boolean | PartTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partType"]>

  export type PartTypeSelectScalar = {
    id?: boolean
    order?: boolean
    name?: boolean
    description?: boolean
  }

  export type PartTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyTypes?: boolean | PartType$propertyTypesArgs<ExtArgs>
    classes?: boolean | PartType$classesArgs<ExtArgs>
    _count?: boolean | PartTypeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PartTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartType"
    objects: {
      propertyTypes: Prisma.$PropertyGroupMembershipPayload<ExtArgs>[]
      classes: Prisma.$PartClassMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      order: number | null
      name: string
      description: string | null
    }, ExtArgs["result"]["partType"]>
    composites: {}
  }


  type PartTypeGetPayload<S extends boolean | null | undefined | PartTypeDefaultArgs> = $Result.GetResult<Prisma.$PartTypePayload, S>

  type PartTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartTypeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PartTypeCountAggregateInputType | true
    }

  export interface PartTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartType'], meta: { name: 'PartType' } }
    /**
     * Find zero or one PartType that matches the filter.
     * @param {PartTypeFindUniqueArgs} args - Arguments to find a PartType
     * @example
     * // Get one PartType
     * const partType = await prisma.partType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PartTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PartType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartTypeFindUniqueOrThrowArgs} args - Arguments to find a PartType
     * @example
     * // Get one PartType
     * const partType = await prisma.partType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PartType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartTypeFindFirstArgs} args - Arguments to find a PartType
     * @example
     * // Get one PartType
     * const partType = await prisma.partType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PartTypeFindFirstArgs<ExtArgs>>
    ): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PartType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartTypeFindFirstOrThrowArgs} args - Arguments to find a PartType
     * @example
     * // Get one PartType
     * const partType = await prisma.partType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PartTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartTypes
     * const partTypes = await prisma.partType.findMany()
     * 
     * // Get first 10 PartTypes
     * const partTypes = await prisma.partType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partTypeWithIdOnly = await prisma.partType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PartType.
     * @param {PartTypeCreateArgs} args - Arguments to create a PartType.
     * @example
     * // Create one PartType
     * const PartType = await prisma.partType.create({
     *   data: {
     *     // ... data to create a PartType
     *   }
     * })
     * 
    **/
    create<T extends PartTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PartTypeCreateArgs<ExtArgs>>
    ): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PartTypes.
     *     @param {PartTypeCreateManyArgs} args - Arguments to create many PartTypes.
     *     @example
     *     // Create many PartTypes
     *     const partType = await prisma.partType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PartType.
     * @param {PartTypeDeleteArgs} args - Arguments to delete one PartType.
     * @example
     * // Delete one PartType
     * const PartType = await prisma.partType.delete({
     *   where: {
     *     // ... filter to delete one PartType
     *   }
     * })
     * 
    **/
    delete<T extends PartTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PartTypeDeleteArgs<ExtArgs>>
    ): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PartType.
     * @param {PartTypeUpdateArgs} args - Arguments to update one PartType.
     * @example
     * // Update one PartType
     * const partType = await prisma.partType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PartTypeUpdateArgs<ExtArgs>>
    ): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PartTypes.
     * @param {PartTypeDeleteManyArgs} args - Arguments to filter PartTypes to delete.
     * @example
     * // Delete a few PartTypes
     * const { count } = await prisma.partType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartTypes
     * const partType = await prisma.partType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PartTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartType.
     * @param {PartTypeUpsertArgs} args - Arguments to update or create a PartType.
     * @example
     * // Update or create a PartType
     * const partType = await prisma.partType.upsert({
     *   create: {
     *     // ... data to create a PartType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartType we want to update
     *   }
     * })
    **/
    upsert<T extends PartTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PartTypeUpsertArgs<ExtArgs>>
    ): Prisma__PartTypeClient<$Result.GetResult<Prisma.$PartTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PartTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartTypeCountArgs} args - Arguments to filter PartTypes to count.
     * @example
     * // Count the number of PartTypes
     * const count = await prisma.partType.count({
     *   where: {
     *     // ... the filter for the PartTypes we want to count
     *   }
     * })
    **/
    count<T extends PartTypeCountArgs>(
      args?: Subset<T, PartTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartTypeAggregateArgs>(args: Subset<T, PartTypeAggregateArgs>): Prisma.PrismaPromise<GetPartTypeAggregateType<T>>

    /**
     * Group by PartType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartTypeGroupByArgs['orderBy'] }
        : { orderBy?: PartTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartType model
   */
  readonly fields: PartTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    propertyTypes<T extends PartType$propertyTypesArgs<ExtArgs> = {}>(args?: Subset<T, PartType$propertyTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyGroupMembershipPayload<ExtArgs>, T, 'findMany'> | Null>;

    classes<T extends PartType$classesArgs<ExtArgs> = {}>(args?: Subset<T, PartType$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartClassMembershipPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PartType model
   */ 
  interface PartTypeFieldRefs {
    readonly id: FieldRef<"PartType", 'Int'>
    readonly order: FieldRef<"PartType", 'Int'>
    readonly name: FieldRef<"PartType", 'String'>
    readonly description: FieldRef<"PartType", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PartType findUnique
   */
  export type PartTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    /**
     * Filter, which PartType to fetch.
     */
    where: PartTypeWhereUniqueInput
  }


  /**
   * PartType findUniqueOrThrow
   */
  export type PartTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    /**
     * Filter, which PartType to fetch.
     */
    where: PartTypeWhereUniqueInput
  }


  /**
   * PartType findFirst
   */
  export type PartTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    /**
     * Filter, which PartType to fetch.
     */
    where?: PartTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartTypes to fetch.
     */
    orderBy?: PartTypeOrderByWithRelationInput | PartTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartTypes.
     */
    cursor?: PartTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartTypes.
     */
    distinct?: PartTypeScalarFieldEnum | PartTypeScalarFieldEnum[]
  }


  /**
   * PartType findFirstOrThrow
   */
  export type PartTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    /**
     * Filter, which PartType to fetch.
     */
    where?: PartTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartTypes to fetch.
     */
    orderBy?: PartTypeOrderByWithRelationInput | PartTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartTypes.
     */
    cursor?: PartTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartTypes.
     */
    distinct?: PartTypeScalarFieldEnum | PartTypeScalarFieldEnum[]
  }


  /**
   * PartType findMany
   */
  export type PartTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    /**
     * Filter, which PartTypes to fetch.
     */
    where?: PartTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartTypes to fetch.
     */
    orderBy?: PartTypeOrderByWithRelationInput | PartTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartTypes.
     */
    cursor?: PartTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartTypes.
     */
    skip?: number
    distinct?: PartTypeScalarFieldEnum | PartTypeScalarFieldEnum[]
  }


  /**
   * PartType create
   */
  export type PartTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PartType.
     */
    data: XOR<PartTypeCreateInput, PartTypeUncheckedCreateInput>
  }


  /**
   * PartType createMany
   */
  export type PartTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartTypes.
     */
    data: PartTypeCreateManyInput | PartTypeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PartType update
   */
  export type PartTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PartType.
     */
    data: XOR<PartTypeUpdateInput, PartTypeUncheckedUpdateInput>
    /**
     * Choose, which PartType to update.
     */
    where: PartTypeWhereUniqueInput
  }


  /**
   * PartType updateMany
   */
  export type PartTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartTypes.
     */
    data: XOR<PartTypeUpdateManyMutationInput, PartTypeUncheckedUpdateManyInput>
    /**
     * Filter which PartTypes to update
     */
    where?: PartTypeWhereInput
  }


  /**
   * PartType upsert
   */
  export type PartTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PartType to update in case it exists.
     */
    where: PartTypeWhereUniqueInput
    /**
     * In case the PartType found by the `where` argument doesn't exist, create a new PartType with this data.
     */
    create: XOR<PartTypeCreateInput, PartTypeUncheckedCreateInput>
    /**
     * In case the PartType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartTypeUpdateInput, PartTypeUncheckedUpdateInput>
  }


  /**
   * PartType delete
   */
  export type PartTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
    /**
     * Filter which PartType to delete.
     */
    where: PartTypeWhereUniqueInput
  }


  /**
   * PartType deleteMany
   */
  export type PartTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartTypes to delete
     */
    where?: PartTypeWhereInput
  }


  /**
   * PartType.propertyTypes
   */
  export type PartType$propertyTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupMembership
     */
    select?: PropertyGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyGroupMembershipInclude<ExtArgs> | null
    where?: PropertyGroupMembershipWhereInput
    orderBy?: PropertyGroupMembershipOrderByWithRelationInput | PropertyGroupMembershipOrderByWithRelationInput[]
    cursor?: PropertyGroupMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyGroupMembershipScalarFieldEnum | PropertyGroupMembershipScalarFieldEnum[]
  }


  /**
   * PartType.classes
   */
  export type PartType$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartClassMembership
     */
    select?: PartClassMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartClassMembershipInclude<ExtArgs> | null
    where?: PartClassMembershipWhereInput
    orderBy?: PartClassMembershipOrderByWithRelationInput | PartClassMembershipOrderByWithRelationInput[]
    cursor?: PartClassMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartClassMembershipScalarFieldEnum | PartClassMembershipScalarFieldEnum[]
  }


  /**
   * PartType without action
   */
  export type PartTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartType
     */
    select?: PartTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartTypeInclude<ExtArgs> | null
  }



  /**
   * Model PartGroup
   */

  export type AggregatePartGroup = {
    _count: PartGroupCountAggregateOutputType | null
    _avg: PartGroupAvgAggregateOutputType | null
    _sum: PartGroupSumAggregateOutputType | null
    _min: PartGroupMinAggregateOutputType | null
    _max: PartGroupMaxAggregateOutputType | null
  }

  export type PartGroupAvgAggregateOutputType = {
    id: number | null
  }

  export type PartGroupSumAggregateOutputType = {
    id: number | null
  }

  export type PartGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PartGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PartGroupCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PartGroupAvgAggregateInputType = {
    id?: true
  }

  export type PartGroupSumAggregateInputType = {
    id?: true
  }

  export type PartGroupMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PartGroupMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PartGroupCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PartGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartGroup to aggregate.
     */
    where?: PartGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartGroups to fetch.
     */
    orderBy?: PartGroupOrderByWithRelationInput | PartGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartGroups
    **/
    _count?: true | PartGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartGroupMaxAggregateInputType
  }

  export type GetPartGroupAggregateType<T extends PartGroupAggregateArgs> = {
        [P in keyof T & keyof AggregatePartGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartGroup[P]>
      : GetScalarType<T[P], AggregatePartGroup[P]>
  }




  export type PartGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartGroupWhereInput
    orderBy?: PartGroupOrderByWithAggregationInput | PartGroupOrderByWithAggregationInput[]
    by: PartGroupScalarFieldEnum[] | PartGroupScalarFieldEnum
    having?: PartGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartGroupCountAggregateInputType | true
    _avg?: PartGroupAvgAggregateInputType
    _sum?: PartGroupSumAggregateInputType
    _min?: PartGroupMinAggregateInputType
    _max?: PartGroupMaxAggregateInputType
  }

  export type PartGroupGroupByOutputType = {
    id: number
    name: string | null
    _count: PartGroupCountAggregateOutputType | null
    _avg: PartGroupAvgAggregateOutputType | null
    _sum: PartGroupSumAggregateOutputType | null
    _min: PartGroupMinAggregateOutputType | null
    _max: PartGroupMaxAggregateOutputType | null
  }

  type GetPartGroupGroupByPayload<T extends PartGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartGroupGroupByOutputType[P]>
            : GetScalarType<T[P], PartGroupGroupByOutputType[P]>
        }
      >
    >


  export type PartGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parts?: boolean | PartGroup$partsArgs<ExtArgs>
    _count?: boolean | PartGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partGroup"]>

  export type PartGroupSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type PartGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parts?: boolean | PartGroup$partsArgs<ExtArgs>
    _count?: boolean | PartGroupCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PartGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartGroup"
    objects: {
      parts: Prisma.$PartGroupMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
    }, ExtArgs["result"]["partGroup"]>
    composites: {}
  }


  type PartGroupGetPayload<S extends boolean | null | undefined | PartGroupDefaultArgs> = $Result.GetResult<Prisma.$PartGroupPayload, S>

  type PartGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartGroupFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PartGroupCountAggregateInputType | true
    }

  export interface PartGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartGroup'], meta: { name: 'PartGroup' } }
    /**
     * Find zero or one PartGroup that matches the filter.
     * @param {PartGroupFindUniqueArgs} args - Arguments to find a PartGroup
     * @example
     * // Get one PartGroup
     * const partGroup = await prisma.partGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartGroupFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupFindUniqueArgs<ExtArgs>>
    ): Prisma__PartGroupClient<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PartGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartGroupFindUniqueOrThrowArgs} args - Arguments to find a PartGroup
     * @example
     * // Get one PartGroup
     * const partGroup = await prisma.partGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartGroupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PartGroupClient<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PartGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupFindFirstArgs} args - Arguments to find a PartGroup
     * @example
     * // Get one PartGroup
     * const partGroup = await prisma.partGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartGroupFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupFindFirstArgs<ExtArgs>>
    ): Prisma__PartGroupClient<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PartGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupFindFirstOrThrowArgs} args - Arguments to find a PartGroup
     * @example
     * // Get one PartGroup
     * const partGroup = await prisma.partGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartGroupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PartGroupClient<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PartGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartGroups
     * const partGroups = await prisma.partGroup.findMany()
     * 
     * // Get first 10 PartGroups
     * const partGroups = await prisma.partGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partGroupWithIdOnly = await prisma.partGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartGroupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PartGroup.
     * @param {PartGroupCreateArgs} args - Arguments to create a PartGroup.
     * @example
     * // Create one PartGroup
     * const PartGroup = await prisma.partGroup.create({
     *   data: {
     *     // ... data to create a PartGroup
     *   }
     * })
     * 
    **/
    create<T extends PartGroupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupCreateArgs<ExtArgs>>
    ): Prisma__PartGroupClient<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PartGroups.
     *     @param {PartGroupCreateManyArgs} args - Arguments to create many PartGroups.
     *     @example
     *     // Create many PartGroups
     *     const partGroup = await prisma.partGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartGroupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PartGroup.
     * @param {PartGroupDeleteArgs} args - Arguments to delete one PartGroup.
     * @example
     * // Delete one PartGroup
     * const PartGroup = await prisma.partGroup.delete({
     *   where: {
     *     // ... filter to delete one PartGroup
     *   }
     * })
     * 
    **/
    delete<T extends PartGroupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupDeleteArgs<ExtArgs>>
    ): Prisma__PartGroupClient<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PartGroup.
     * @param {PartGroupUpdateArgs} args - Arguments to update one PartGroup.
     * @example
     * // Update one PartGroup
     * const partGroup = await prisma.partGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartGroupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupUpdateArgs<ExtArgs>>
    ): Prisma__PartGroupClient<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PartGroups.
     * @param {PartGroupDeleteManyArgs} args - Arguments to filter PartGroups to delete.
     * @example
     * // Delete a few PartGroups
     * const { count } = await prisma.partGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartGroupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartGroups
     * const partGroup = await prisma.partGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartGroupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartGroup.
     * @param {PartGroupUpsertArgs} args - Arguments to update or create a PartGroup.
     * @example
     * // Update or create a PartGroup
     * const partGroup = await prisma.partGroup.upsert({
     *   create: {
     *     // ... data to create a PartGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartGroup we want to update
     *   }
     * })
    **/
    upsert<T extends PartGroupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupUpsertArgs<ExtArgs>>
    ): Prisma__PartGroupClient<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PartGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupCountArgs} args - Arguments to filter PartGroups to count.
     * @example
     * // Count the number of PartGroups
     * const count = await prisma.partGroup.count({
     *   where: {
     *     // ... the filter for the PartGroups we want to count
     *   }
     * })
    **/
    count<T extends PartGroupCountArgs>(
      args?: Subset<T, PartGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartGroupAggregateArgs>(args: Subset<T, PartGroupAggregateArgs>): Prisma.PrismaPromise<GetPartGroupAggregateType<T>>

    /**
     * Group by PartGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartGroupGroupByArgs['orderBy'] }
        : { orderBy?: PartGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartGroup model
   */
  readonly fields: PartGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    parts<T extends PartGroup$partsArgs<ExtArgs> = {}>(args?: Subset<T, PartGroup$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PartGroup model
   */ 
  interface PartGroupFieldRefs {
    readonly id: FieldRef<"PartGroup", 'Int'>
    readonly name: FieldRef<"PartGroup", 'String'>
  }
    

  // Custom InputTypes

  /**
   * PartGroup findUnique
   */
  export type PartGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartGroup to fetch.
     */
    where: PartGroupWhereUniqueInput
  }


  /**
   * PartGroup findUniqueOrThrow
   */
  export type PartGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartGroup to fetch.
     */
    where: PartGroupWhereUniqueInput
  }


  /**
   * PartGroup findFirst
   */
  export type PartGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartGroup to fetch.
     */
    where?: PartGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartGroups to fetch.
     */
    orderBy?: PartGroupOrderByWithRelationInput | PartGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartGroups.
     */
    cursor?: PartGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartGroups.
     */
    distinct?: PartGroupScalarFieldEnum | PartGroupScalarFieldEnum[]
  }


  /**
   * PartGroup findFirstOrThrow
   */
  export type PartGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartGroup to fetch.
     */
    where?: PartGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartGroups to fetch.
     */
    orderBy?: PartGroupOrderByWithRelationInput | PartGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartGroups.
     */
    cursor?: PartGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartGroups.
     */
    distinct?: PartGroupScalarFieldEnum | PartGroupScalarFieldEnum[]
  }


  /**
   * PartGroup findMany
   */
  export type PartGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    /**
     * Filter, which PartGroups to fetch.
     */
    where?: PartGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartGroups to fetch.
     */
    orderBy?: PartGroupOrderByWithRelationInput | PartGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartGroups.
     */
    cursor?: PartGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartGroups.
     */
    skip?: number
    distinct?: PartGroupScalarFieldEnum | PartGroupScalarFieldEnum[]
  }


  /**
   * PartGroup create
   */
  export type PartGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a PartGroup.
     */
    data?: XOR<PartGroupCreateInput, PartGroupUncheckedCreateInput>
  }


  /**
   * PartGroup createMany
   */
  export type PartGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartGroups.
     */
    data: PartGroupCreateManyInput | PartGroupCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PartGroup update
   */
  export type PartGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a PartGroup.
     */
    data: XOR<PartGroupUpdateInput, PartGroupUncheckedUpdateInput>
    /**
     * Choose, which PartGroup to update.
     */
    where: PartGroupWhereUniqueInput
  }


  /**
   * PartGroup updateMany
   */
  export type PartGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartGroups.
     */
    data: XOR<PartGroupUpdateManyMutationInput, PartGroupUncheckedUpdateManyInput>
    /**
     * Filter which PartGroups to update
     */
    where?: PartGroupWhereInput
  }


  /**
   * PartGroup upsert
   */
  export type PartGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the PartGroup to update in case it exists.
     */
    where: PartGroupWhereUniqueInput
    /**
     * In case the PartGroup found by the `where` argument doesn't exist, create a new PartGroup with this data.
     */
    create: XOR<PartGroupCreateInput, PartGroupUncheckedCreateInput>
    /**
     * In case the PartGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartGroupUpdateInput, PartGroupUncheckedUpdateInput>
  }


  /**
   * PartGroup delete
   */
  export type PartGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    /**
     * Filter which PartGroup to delete.
     */
    where: PartGroupWhereUniqueInput
  }


  /**
   * PartGroup deleteMany
   */
  export type PartGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartGroups to delete
     */
    where?: PartGroupWhereInput
  }


  /**
   * PartGroup.parts
   */
  export type PartGroup$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    where?: PartGroupMembershipWhereInput
    orderBy?: PartGroupMembershipOrderByWithRelationInput | PartGroupMembershipOrderByWithRelationInput[]
    cursor?: PartGroupMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartGroupMembershipScalarFieldEnum | PartGroupMembershipScalarFieldEnum[]
  }


  /**
   * PartGroup without action
   */
  export type PartGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
  }



  /**
   * Model PartGroupMembership
   */

  export type AggregatePartGroupMembership = {
    _count: PartGroupMembershipCountAggregateOutputType | null
    _avg: PartGroupMembershipAvgAggregateOutputType | null
    _sum: PartGroupMembershipSumAggregateOutputType | null
    _min: PartGroupMembershipMinAggregateOutputType | null
    _max: PartGroupMembershipMaxAggregateOutputType | null
  }

  export type PartGroupMembershipAvgAggregateOutputType = {
    id: number | null
    partId: number | null
    groupId: number | null
  }

  export type PartGroupMembershipSumAggregateOutputType = {
    id: number | null
    partId: number | null
    groupId: number | null
  }

  export type PartGroupMembershipMinAggregateOutputType = {
    id: number | null
    partId: number | null
    groupId: number | null
  }

  export type PartGroupMembershipMaxAggregateOutputType = {
    id: number | null
    partId: number | null
    groupId: number | null
  }

  export type PartGroupMembershipCountAggregateOutputType = {
    id: number
    partId: number
    groupId: number
    _all: number
  }


  export type PartGroupMembershipAvgAggregateInputType = {
    id?: true
    partId?: true
    groupId?: true
  }

  export type PartGroupMembershipSumAggregateInputType = {
    id?: true
    partId?: true
    groupId?: true
  }

  export type PartGroupMembershipMinAggregateInputType = {
    id?: true
    partId?: true
    groupId?: true
  }

  export type PartGroupMembershipMaxAggregateInputType = {
    id?: true
    partId?: true
    groupId?: true
  }

  export type PartGroupMembershipCountAggregateInputType = {
    id?: true
    partId?: true
    groupId?: true
    _all?: true
  }

  export type PartGroupMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartGroupMembership to aggregate.
     */
    where?: PartGroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartGroupMemberships to fetch.
     */
    orderBy?: PartGroupMembershipOrderByWithRelationInput | PartGroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartGroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartGroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartGroupMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartGroupMemberships
    **/
    _count?: true | PartGroupMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartGroupMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartGroupMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartGroupMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartGroupMembershipMaxAggregateInputType
  }

  export type GetPartGroupMembershipAggregateType<T extends PartGroupMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregatePartGroupMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartGroupMembership[P]>
      : GetScalarType<T[P], AggregatePartGroupMembership[P]>
  }




  export type PartGroupMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartGroupMembershipWhereInput
    orderBy?: PartGroupMembershipOrderByWithAggregationInput | PartGroupMembershipOrderByWithAggregationInput[]
    by: PartGroupMembershipScalarFieldEnum[] | PartGroupMembershipScalarFieldEnum
    having?: PartGroupMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartGroupMembershipCountAggregateInputType | true
    _avg?: PartGroupMembershipAvgAggregateInputType
    _sum?: PartGroupMembershipSumAggregateInputType
    _min?: PartGroupMembershipMinAggregateInputType
    _max?: PartGroupMembershipMaxAggregateInputType
  }

  export type PartGroupMembershipGroupByOutputType = {
    id: number
    partId: number | null
    groupId: number | null
    _count: PartGroupMembershipCountAggregateOutputType | null
    _avg: PartGroupMembershipAvgAggregateOutputType | null
    _sum: PartGroupMembershipSumAggregateOutputType | null
    _min: PartGroupMembershipMinAggregateOutputType | null
    _max: PartGroupMembershipMaxAggregateOutputType | null
  }

  type GetPartGroupMembershipGroupByPayload<T extends PartGroupMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartGroupMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartGroupMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartGroupMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], PartGroupMembershipGroupByOutputType[P]>
        }
      >
    >


  export type PartGroupMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partId?: boolean
    groupId?: boolean
    part?: boolean | PartGroupMembership$partArgs<ExtArgs>
    group?: boolean | PartGroupMembership$groupArgs<ExtArgs>
  }, ExtArgs["result"]["partGroupMembership"]>

  export type PartGroupMembershipSelectScalar = {
    id?: boolean
    partId?: boolean
    groupId?: boolean
  }

  export type PartGroupMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartGroupMembership$partArgs<ExtArgs>
    group?: boolean | PartGroupMembership$groupArgs<ExtArgs>
  }


  export type $PartGroupMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartGroupMembership"
    objects: {
      part: Prisma.$PartPayload<ExtArgs> | null
      group: Prisma.$PartGroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      partId: number | null
      groupId: number | null
    }, ExtArgs["result"]["partGroupMembership"]>
    composites: {}
  }


  type PartGroupMembershipGetPayload<S extends boolean | null | undefined | PartGroupMembershipDefaultArgs> = $Result.GetResult<Prisma.$PartGroupMembershipPayload, S>

  type PartGroupMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartGroupMembershipFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PartGroupMembershipCountAggregateInputType | true
    }

  export interface PartGroupMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartGroupMembership'], meta: { name: 'PartGroupMembership' } }
    /**
     * Find zero or one PartGroupMembership that matches the filter.
     * @param {PartGroupMembershipFindUniqueArgs} args - Arguments to find a PartGroupMembership
     * @example
     * // Get one PartGroupMembership
     * const partGroupMembership = await prisma.partGroupMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartGroupMembershipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupMembershipFindUniqueArgs<ExtArgs>>
    ): Prisma__PartGroupMembershipClient<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PartGroupMembership that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartGroupMembershipFindUniqueOrThrowArgs} args - Arguments to find a PartGroupMembership
     * @example
     * // Get one PartGroupMembership
     * const partGroupMembership = await prisma.partGroupMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartGroupMembershipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupMembershipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PartGroupMembershipClient<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PartGroupMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupMembershipFindFirstArgs} args - Arguments to find a PartGroupMembership
     * @example
     * // Get one PartGroupMembership
     * const partGroupMembership = await prisma.partGroupMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartGroupMembershipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupMembershipFindFirstArgs<ExtArgs>>
    ): Prisma__PartGroupMembershipClient<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PartGroupMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupMembershipFindFirstOrThrowArgs} args - Arguments to find a PartGroupMembership
     * @example
     * // Get one PartGroupMembership
     * const partGroupMembership = await prisma.partGroupMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartGroupMembershipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupMembershipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PartGroupMembershipClient<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PartGroupMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupMembershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartGroupMemberships
     * const partGroupMemberships = await prisma.partGroupMembership.findMany()
     * 
     * // Get first 10 PartGroupMemberships
     * const partGroupMemberships = await prisma.partGroupMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partGroupMembershipWithIdOnly = await prisma.partGroupMembership.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartGroupMembershipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupMembershipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PartGroupMembership.
     * @param {PartGroupMembershipCreateArgs} args - Arguments to create a PartGroupMembership.
     * @example
     * // Create one PartGroupMembership
     * const PartGroupMembership = await prisma.partGroupMembership.create({
     *   data: {
     *     // ... data to create a PartGroupMembership
     *   }
     * })
     * 
    **/
    create<T extends PartGroupMembershipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupMembershipCreateArgs<ExtArgs>>
    ): Prisma__PartGroupMembershipClient<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PartGroupMemberships.
     *     @param {PartGroupMembershipCreateManyArgs} args - Arguments to create many PartGroupMemberships.
     *     @example
     *     // Create many PartGroupMemberships
     *     const partGroupMembership = await prisma.partGroupMembership.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartGroupMembershipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupMembershipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PartGroupMembership.
     * @param {PartGroupMembershipDeleteArgs} args - Arguments to delete one PartGroupMembership.
     * @example
     * // Delete one PartGroupMembership
     * const PartGroupMembership = await prisma.partGroupMembership.delete({
     *   where: {
     *     // ... filter to delete one PartGroupMembership
     *   }
     * })
     * 
    **/
    delete<T extends PartGroupMembershipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupMembershipDeleteArgs<ExtArgs>>
    ): Prisma__PartGroupMembershipClient<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PartGroupMembership.
     * @param {PartGroupMembershipUpdateArgs} args - Arguments to update one PartGroupMembership.
     * @example
     * // Update one PartGroupMembership
     * const partGroupMembership = await prisma.partGroupMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartGroupMembershipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupMembershipUpdateArgs<ExtArgs>>
    ): Prisma__PartGroupMembershipClient<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PartGroupMemberships.
     * @param {PartGroupMembershipDeleteManyArgs} args - Arguments to filter PartGroupMemberships to delete.
     * @example
     * // Delete a few PartGroupMemberships
     * const { count } = await prisma.partGroupMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartGroupMembershipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartGroupMembershipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartGroupMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartGroupMemberships
     * const partGroupMembership = await prisma.partGroupMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartGroupMembershipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupMembershipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartGroupMembership.
     * @param {PartGroupMembershipUpsertArgs} args - Arguments to update or create a PartGroupMembership.
     * @example
     * // Update or create a PartGroupMembership
     * const partGroupMembership = await prisma.partGroupMembership.upsert({
     *   create: {
     *     // ... data to create a PartGroupMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartGroupMembership we want to update
     *   }
     * })
    **/
    upsert<T extends PartGroupMembershipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PartGroupMembershipUpsertArgs<ExtArgs>>
    ): Prisma__PartGroupMembershipClient<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PartGroupMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupMembershipCountArgs} args - Arguments to filter PartGroupMemberships to count.
     * @example
     * // Count the number of PartGroupMemberships
     * const count = await prisma.partGroupMembership.count({
     *   where: {
     *     // ... the filter for the PartGroupMemberships we want to count
     *   }
     * })
    **/
    count<T extends PartGroupMembershipCountArgs>(
      args?: Subset<T, PartGroupMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartGroupMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartGroupMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartGroupMembershipAggregateArgs>(args: Subset<T, PartGroupMembershipAggregateArgs>): Prisma.PrismaPromise<GetPartGroupMembershipAggregateType<T>>

    /**
     * Group by PartGroupMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartGroupMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartGroupMembershipGroupByArgs['orderBy'] }
        : { orderBy?: PartGroupMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartGroupMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartGroupMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartGroupMembership model
   */
  readonly fields: PartGroupMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartGroupMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartGroupMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    part<T extends PartGroupMembership$partArgs<ExtArgs> = {}>(args?: Subset<T, PartGroupMembership$partArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    group<T extends PartGroupMembership$groupArgs<ExtArgs> = {}>(args?: Subset<T, PartGroupMembership$groupArgs<ExtArgs>>): Prisma__PartGroupClient<$Result.GetResult<Prisma.$PartGroupPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the PartGroupMembership model
   */ 
  interface PartGroupMembershipFieldRefs {
    readonly id: FieldRef<"PartGroupMembership", 'Int'>
    readonly partId: FieldRef<"PartGroupMembership", 'Int'>
    readonly groupId: FieldRef<"PartGroupMembership", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * PartGroupMembership findUnique
   */
  export type PartGroupMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartGroupMembership to fetch.
     */
    where: PartGroupMembershipWhereUniqueInput
  }


  /**
   * PartGroupMembership findUniqueOrThrow
   */
  export type PartGroupMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartGroupMembership to fetch.
     */
    where: PartGroupMembershipWhereUniqueInput
  }


  /**
   * PartGroupMembership findFirst
   */
  export type PartGroupMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartGroupMembership to fetch.
     */
    where?: PartGroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartGroupMemberships to fetch.
     */
    orderBy?: PartGroupMembershipOrderByWithRelationInput | PartGroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartGroupMemberships.
     */
    cursor?: PartGroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartGroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartGroupMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartGroupMemberships.
     */
    distinct?: PartGroupMembershipScalarFieldEnum | PartGroupMembershipScalarFieldEnum[]
  }


  /**
   * PartGroupMembership findFirstOrThrow
   */
  export type PartGroupMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartGroupMembership to fetch.
     */
    where?: PartGroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartGroupMemberships to fetch.
     */
    orderBy?: PartGroupMembershipOrderByWithRelationInput | PartGroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartGroupMemberships.
     */
    cursor?: PartGroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartGroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartGroupMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartGroupMemberships.
     */
    distinct?: PartGroupMembershipScalarFieldEnum | PartGroupMembershipScalarFieldEnum[]
  }


  /**
   * PartGroupMembership findMany
   */
  export type PartGroupMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter, which PartGroupMemberships to fetch.
     */
    where?: PartGroupMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartGroupMemberships to fetch.
     */
    orderBy?: PartGroupMembershipOrderByWithRelationInput | PartGroupMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartGroupMemberships.
     */
    cursor?: PartGroupMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartGroupMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartGroupMemberships.
     */
    skip?: number
    distinct?: PartGroupMembershipScalarFieldEnum | PartGroupMembershipScalarFieldEnum[]
  }


  /**
   * PartGroupMembership create
   */
  export type PartGroupMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a PartGroupMembership.
     */
    data?: XOR<PartGroupMembershipCreateInput, PartGroupMembershipUncheckedCreateInput>
  }


  /**
   * PartGroupMembership createMany
   */
  export type PartGroupMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartGroupMemberships.
     */
    data: PartGroupMembershipCreateManyInput | PartGroupMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PartGroupMembership update
   */
  export type PartGroupMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a PartGroupMembership.
     */
    data: XOR<PartGroupMembershipUpdateInput, PartGroupMembershipUncheckedUpdateInput>
    /**
     * Choose, which PartGroupMembership to update.
     */
    where: PartGroupMembershipWhereUniqueInput
  }


  /**
   * PartGroupMembership updateMany
   */
  export type PartGroupMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartGroupMemberships.
     */
    data: XOR<PartGroupMembershipUpdateManyMutationInput, PartGroupMembershipUncheckedUpdateManyInput>
    /**
     * Filter which PartGroupMemberships to update
     */
    where?: PartGroupMembershipWhereInput
  }


  /**
   * PartGroupMembership upsert
   */
  export type PartGroupMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the PartGroupMembership to update in case it exists.
     */
    where: PartGroupMembershipWhereUniqueInput
    /**
     * In case the PartGroupMembership found by the `where` argument doesn't exist, create a new PartGroupMembership with this data.
     */
    create: XOR<PartGroupMembershipCreateInput, PartGroupMembershipUncheckedCreateInput>
    /**
     * In case the PartGroupMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartGroupMembershipUpdateInput, PartGroupMembershipUncheckedUpdateInput>
  }


  /**
   * PartGroupMembership delete
   */
  export type PartGroupMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    /**
     * Filter which PartGroupMembership to delete.
     */
    where: PartGroupMembershipWhereUniqueInput
  }


  /**
   * PartGroupMembership deleteMany
   */
  export type PartGroupMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartGroupMemberships to delete
     */
    where?: PartGroupMembershipWhereInput
  }


  /**
   * PartGroupMembership.part
   */
  export type PartGroupMembership$partArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
  }


  /**
   * PartGroupMembership.group
   */
  export type PartGroupMembership$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroup
     */
    select?: PartGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupInclude<ExtArgs> | null
    where?: PartGroupWhereInput
  }


  /**
   * PartGroupMembership without action
   */
  export type PartGroupMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
  }



  /**
   * Model Part
   */

  export type AggregatePart = {
    _count: PartCountAggregateOutputType | null
    _avg: PartAvgAggregateOutputType | null
    _sum: PartSumAggregateOutputType | null
    _min: PartMinAggregateOutputType | null
    _max: PartMaxAggregateOutputType | null
  }

  export type PartAvgAggregateOutputType = {
    id: number | null
    weight: Decimal | null
    productLineId: number | null
  }

  export type PartSumAggregateOutputType = {
    id: number | null
    weight: Decimal | null
    productLineId: number | null
  }

  export type PartMinAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    notes: string | null
    weight: Decimal | null
    weightUnit: string | null
    productLineId: number | null
  }

  export type PartMaxAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    notes: string | null
    weight: Decimal | null
    weightUnit: string | null
    productLineId: number | null
  }

  export type PartCountAggregateOutputType = {
    id: number
    type: number
    name: number
    notes: number
    weight: number
    weightUnit: number
    productLineId: number
    _all: number
  }


  export type PartAvgAggregateInputType = {
    id?: true
    weight?: true
    productLineId?: true
  }

  export type PartSumAggregateInputType = {
    id?: true
    weight?: true
    productLineId?: true
  }

  export type PartMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    notes?: true
    weight?: true
    weightUnit?: true
    productLineId?: true
  }

  export type PartMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    notes?: true
    weight?: true
    weightUnit?: true
    productLineId?: true
  }

  export type PartCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    notes?: true
    weight?: true
    weightUnit?: true
    productLineId?: true
    _all?: true
  }

  export type PartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Part to aggregate.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parts
    **/
    _count?: true | PartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartMaxAggregateInputType
  }

  export type GetPartAggregateType<T extends PartAggregateArgs> = {
        [P in keyof T & keyof AggregatePart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePart[P]>
      : GetScalarType<T[P], AggregatePart[P]>
  }




  export type PartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartWhereInput
    orderBy?: PartOrderByWithAggregationInput | PartOrderByWithAggregationInput[]
    by: PartScalarFieldEnum[] | PartScalarFieldEnum
    having?: PartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartCountAggregateInputType | true
    _avg?: PartAvgAggregateInputType
    _sum?: PartSumAggregateInputType
    _min?: PartMinAggregateInputType
    _max?: PartMaxAggregateInputType
  }

  export type PartGroupByOutputType = {
    id: number
    type: string | null
    name: string | null
    notes: string | null
    weight: Decimal | null
    weightUnit: string | null
    productLineId: number | null
    _count: PartCountAggregateOutputType | null
    _avg: PartAvgAggregateOutputType | null
    _sum: PartSumAggregateOutputType | null
    _min: PartMinAggregateOutputType | null
    _max: PartMaxAggregateOutputType | null
  }

  type GetPartGroupByPayload<T extends PartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartGroupByOutputType[P]>
            : GetScalarType<T[P], PartGroupByOutputType[P]>
        }
      >
    >


  export type PartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    notes?: boolean
    weight?: boolean
    weightUnit?: boolean
    productLineId?: boolean
    productLine?: boolean | Part$productLineArgs<ExtArgs>
    wheelHubs?: boolean | Part$wheelHubsArgs<ExtArgs>
    wheelRims?: boolean | Part$wheelRimsArgs<ExtArgs>
    wheelSpokes?: boolean | Part$wheelSpokesArgs<ExtArgs>
    properties?: boolean | Part$propertiesArgs<ExtArgs>
    claims?: boolean | Part$claimsArgs<ExtArgs>
    groups?: boolean | Part$groupsArgs<ExtArgs>
    builds?: boolean | Part$buildsArgs<ExtArgs>
    _count?: boolean | PartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["part"]>

  export type PartSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    notes?: boolean
    weight?: boolean
    weightUnit?: boolean
    productLineId?: boolean
  }

  export type PartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productLine?: boolean | Part$productLineArgs<ExtArgs>
    wheelHubs?: boolean | Part$wheelHubsArgs<ExtArgs>
    wheelRims?: boolean | Part$wheelRimsArgs<ExtArgs>
    wheelSpokes?: boolean | Part$wheelSpokesArgs<ExtArgs>
    properties?: boolean | Part$propertiesArgs<ExtArgs>
    claims?: boolean | Part$claimsArgs<ExtArgs>
    groups?: boolean | Part$groupsArgs<ExtArgs>
    builds?: boolean | Part$buildsArgs<ExtArgs>
    _count?: boolean | PartCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Part"
    objects: {
      productLine: Prisma.$ProductLinePayload<ExtArgs> | null
      wheelHubs: Prisma.$WheelPayload<ExtArgs>[]
      wheelRims: Prisma.$WheelPayload<ExtArgs>[]
      wheelSpokes: Prisma.$WheelSpokePayload<ExtArgs>[]
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      groups: Prisma.$PartGroupMembershipPayload<ExtArgs>[]
      builds: Prisma.$BuildPartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      name: string | null
      notes: string | null
      weight: Prisma.Decimal | null
      weightUnit: string | null
      productLineId: number | null
    }, ExtArgs["result"]["part"]>
    composites: {}
  }


  type PartGetPayload<S extends boolean | null | undefined | PartDefaultArgs> = $Result.GetResult<Prisma.$PartPayload, S>

  type PartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PartCountAggregateInputType | true
    }

  export interface PartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Part'], meta: { name: 'Part' } }
    /**
     * Find zero or one Part that matches the filter.
     * @param {PartFindUniqueArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PartFindUniqueArgs<ExtArgs>>
    ): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Part that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartFindUniqueOrThrowArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Part that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindFirstArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PartFindFirstArgs<ExtArgs>>
    ): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Part that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindFirstOrThrowArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Parts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parts
     * const parts = await prisma.part.findMany()
     * 
     * // Get first 10 Parts
     * const parts = await prisma.part.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partWithIdOnly = await prisma.part.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Part.
     * @param {PartCreateArgs} args - Arguments to create a Part.
     * @example
     * // Create one Part
     * const Part = await prisma.part.create({
     *   data: {
     *     // ... data to create a Part
     *   }
     * })
     * 
    **/
    create<T extends PartCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PartCreateArgs<ExtArgs>>
    ): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Parts.
     *     @param {PartCreateManyArgs} args - Arguments to create many Parts.
     *     @example
     *     // Create many Parts
     *     const part = await prisma.part.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Part.
     * @param {PartDeleteArgs} args - Arguments to delete one Part.
     * @example
     * // Delete one Part
     * const Part = await prisma.part.delete({
     *   where: {
     *     // ... filter to delete one Part
     *   }
     * })
     * 
    **/
    delete<T extends PartDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PartDeleteArgs<ExtArgs>>
    ): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Part.
     * @param {PartUpdateArgs} args - Arguments to update one Part.
     * @example
     * // Update one Part
     * const part = await prisma.part.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PartUpdateArgs<ExtArgs>>
    ): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Parts.
     * @param {PartDeleteManyArgs} args - Arguments to filter Parts to delete.
     * @example
     * // Delete a few Parts
     * const { count } = await prisma.part.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parts
     * const part = await prisma.part.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Part.
     * @param {PartUpsertArgs} args - Arguments to update or create a Part.
     * @example
     * // Update or create a Part
     * const part = await prisma.part.upsert({
     *   create: {
     *     // ... data to create a Part
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Part we want to update
     *   }
     * })
    **/
    upsert<T extends PartUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PartUpsertArgs<ExtArgs>>
    ): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartCountArgs} args - Arguments to filter Parts to count.
     * @example
     * // Count the number of Parts
     * const count = await prisma.part.count({
     *   where: {
     *     // ... the filter for the Parts we want to count
     *   }
     * })
    **/
    count<T extends PartCountArgs>(
      args?: Subset<T, PartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Part.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartAggregateArgs>(args: Subset<T, PartAggregateArgs>): Prisma.PrismaPromise<GetPartAggregateType<T>>

    /**
     * Group by Part.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartGroupByArgs['orderBy'] }
        : { orderBy?: PartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Part model
   */
  readonly fields: PartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Part.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    productLine<T extends Part$productLineArgs<ExtArgs> = {}>(args?: Subset<T, Part$productLineArgs<ExtArgs>>): Prisma__ProductLineClient<$Result.GetResult<Prisma.$ProductLinePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    wheelHubs<T extends Part$wheelHubsArgs<ExtArgs> = {}>(args?: Subset<T, Part$wheelHubsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'findMany'> | Null>;

    wheelRims<T extends Part$wheelRimsArgs<ExtArgs> = {}>(args?: Subset<T, Part$wheelRimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'findMany'> | Null>;

    wheelSpokes<T extends Part$wheelSpokesArgs<ExtArgs> = {}>(args?: Subset<T, Part$wheelSpokesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'findMany'> | Null>;

    properties<T extends Part$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Part$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'findMany'> | Null>;

    claims<T extends Part$claimsArgs<ExtArgs> = {}>(args?: Subset<T, Part$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findMany'> | Null>;

    groups<T extends Part$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Part$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartGroupMembershipPayload<ExtArgs>, T, 'findMany'> | Null>;

    builds<T extends Part$buildsArgs<ExtArgs> = {}>(args?: Subset<T, Part$buildsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Part model
   */ 
  interface PartFieldRefs {
    readonly id: FieldRef<"Part", 'Int'>
    readonly type: FieldRef<"Part", 'String'>
    readonly name: FieldRef<"Part", 'String'>
    readonly notes: FieldRef<"Part", 'String'>
    readonly weight: FieldRef<"Part", 'Decimal'>
    readonly weightUnit: FieldRef<"Part", 'String'>
    readonly productLineId: FieldRef<"Part", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Part findUnique
   */
  export type PartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where: PartWhereUniqueInput
  }


  /**
   * Part findUniqueOrThrow
   */
  export type PartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where: PartWhereUniqueInput
  }


  /**
   * Part findFirst
   */
  export type PartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }


  /**
   * Part findFirstOrThrow
   */
  export type PartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }


  /**
   * Part findMany
   */
  export type PartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Parts to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }


  /**
   * Part create
   */
  export type PartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * The data needed to create a Part.
     */
    data?: XOR<PartCreateInput, PartUncheckedCreateInput>
  }


  /**
   * Part createMany
   */
  export type PartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parts.
     */
    data: PartCreateManyInput | PartCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Part update
   */
  export type PartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * The data needed to update a Part.
     */
    data: XOR<PartUpdateInput, PartUncheckedUpdateInput>
    /**
     * Choose, which Part to update.
     */
    where: PartWhereUniqueInput
  }


  /**
   * Part updateMany
   */
  export type PartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parts.
     */
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyInput>
    /**
     * Filter which Parts to update
     */
    where?: PartWhereInput
  }


  /**
   * Part upsert
   */
  export type PartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * The filter to search for the Part to update in case it exists.
     */
    where: PartWhereUniqueInput
    /**
     * In case the Part found by the `where` argument doesn't exist, create a new Part with this data.
     */
    create: XOR<PartCreateInput, PartUncheckedCreateInput>
    /**
     * In case the Part was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartUpdateInput, PartUncheckedUpdateInput>
  }


  /**
   * Part delete
   */
  export type PartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter which Part to delete.
     */
    where: PartWhereUniqueInput
  }


  /**
   * Part deleteMany
   */
  export type PartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parts to delete
     */
    where?: PartWhereInput
  }


  /**
   * Part.productLine
   */
  export type Part$productLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude<ExtArgs> | null
    where?: ProductLineWhereInput
  }


  /**
   * Part.wheelHubs
   */
  export type Part$wheelHubsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    where?: WheelWhereInput
    orderBy?: WheelOrderByWithRelationInput | WheelOrderByWithRelationInput[]
    cursor?: WheelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WheelScalarFieldEnum | WheelScalarFieldEnum[]
  }


  /**
   * Part.wheelRims
   */
  export type Part$wheelRimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    where?: WheelWhereInput
    orderBy?: WheelOrderByWithRelationInput | WheelOrderByWithRelationInput[]
    cursor?: WheelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WheelScalarFieldEnum | WheelScalarFieldEnum[]
  }


  /**
   * Part.wheelSpokes
   */
  export type Part$wheelSpokesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    where?: WheelSpokeWhereInput
    orderBy?: WheelSpokeOrderByWithRelationInput | WheelSpokeOrderByWithRelationInput[]
    cursor?: WheelSpokeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WheelSpokeScalarFieldEnum | WheelSpokeScalarFieldEnum[]
  }


  /**
   * Part.properties
   */
  export type Part$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }


  /**
   * Part.claims
   */
  export type Part$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Part.groups
   */
  export type Part$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartGroupMembership
     */
    select?: PartGroupMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartGroupMembershipInclude<ExtArgs> | null
    where?: PartGroupMembershipWhereInput
    orderBy?: PartGroupMembershipOrderByWithRelationInput | PartGroupMembershipOrderByWithRelationInput[]
    cursor?: PartGroupMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartGroupMembershipScalarFieldEnum | PartGroupMembershipScalarFieldEnum[]
  }


  /**
   * Part.builds
   */
  export type Part$buildsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    where?: BuildPartWhereInput
    orderBy?: BuildPartOrderByWithRelationInput | BuildPartOrderByWithRelationInput[]
    cursor?: BuildPartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildPartScalarFieldEnum | BuildPartScalarFieldEnum[]
  }


  /**
   * Part without action
   */
  export type PartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
  }



  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    id: number | null
    itemId: number | null
    propertyTypeId: number | null
  }

  export type PropertySumAggregateOutputType = {
    id: number | null
    itemId: number | null
    propertyTypeId: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: number | null
    itemId: number | null
    value: string | null
    valueDataMethod: string | null
    propertyTypeId: number | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: number | null
    itemId: number | null
    value: string | null
    valueDataMethod: string | null
    propertyTypeId: number | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    itemId: number
    value: number
    valueDataMethod: number
    propertyTypeId: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    id?: true
    itemId?: true
    propertyTypeId?: true
  }

  export type PropertySumAggregateInputType = {
    id?: true
    itemId?: true
    propertyTypeId?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    itemId?: true
    value?: true
    valueDataMethod?: true
    propertyTypeId?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    itemId?: true
    value?: true
    valueDataMethod?: true
    propertyTypeId?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    itemId?: true
    value?: true
    valueDataMethod?: true
    propertyTypeId?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: number
    itemId: number | null
    value: string | null
    valueDataMethod: string | null
    propertyTypeId: number | null
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    value?: boolean
    valueDataMethod?: boolean
    propertyTypeId?: boolean
    part?: boolean | Property$partArgs<ExtArgs>
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    itemId?: boolean
    value?: boolean
    valueDataMethod?: boolean
    propertyTypeId?: boolean
  }

  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | Property$partArgs<ExtArgs>
    propertyType?: boolean | Property$propertyTypeArgs<ExtArgs>
  }


  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      part: Prisma.$PartPayload<ExtArgs> | null
      propertyType: Prisma.$PropertyTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemId: number | null
      value: string | null
      valueDataMethod: string | null
      propertyTypeId: number | null
    }, ExtArgs["result"]["property"]>
    composites: {}
  }


  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PropertyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>
    ): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Property that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PropertyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>
    ): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PropertyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
    **/
    create<T extends PropertyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>
    ): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Properties.
     *     @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     *     @example
     *     // Create many Properties
     *     const property = await prisma.property.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PropertyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
    **/
    delete<T extends PropertyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>
    ): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PropertyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>
    ): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PropertyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PropertyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
    **/
    upsert<T extends PropertyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>
    ): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    part<T extends Property$partArgs<ExtArgs> = {}>(args?: Subset<T, Property$partArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    propertyType<T extends Property$propertyTypeArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyTypeArgs<ExtArgs>>): Prisma__PropertyTypeClient<$Result.GetResult<Prisma.$PropertyTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Property model
   */ 
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'Int'>
    readonly itemId: FieldRef<"Property", 'Int'>
    readonly value: FieldRef<"Property", 'String'>
    readonly valueDataMethod: FieldRef<"Property", 'String'>
    readonly propertyTypeId: FieldRef<"Property", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }


  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }


  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }


  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }


  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }


  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data?: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }


  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }


  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
  }


  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }


  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }


  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
  }


  /**
   * Property.part
   */
  export type Property$partArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
  }


  /**
   * Property.propertyType
   */
  export type Property$propertyTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyType
     */
    select?: PropertyTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyTypeInclude<ExtArgs> | null
    where?: PropertyTypeWhereInput
  }


  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PropertyInclude<ExtArgs> | null
  }



  /**
   * Model WheelSpoke
   */

  export type AggregateWheelSpoke = {
    _count: WheelSpokeCountAggregateOutputType | null
    _avg: WheelSpokeAvgAggregateOutputType | null
    _sum: WheelSpokeSumAggregateOutputType | null
    _min: WheelSpokeMinAggregateOutputType | null
    _max: WheelSpokeMaxAggregateOutputType | null
  }

  export type WheelSpokeAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    length: Decimal | null
    tensionApplied: Decimal | null
    spokeId: number | null
    wheelId: number | null
  }

  export type WheelSpokeSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    length: Decimal | null
    tensionApplied: Decimal | null
    spokeId: number | null
    wheelId: number | null
  }

  export type WheelSpokeMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    length: Decimal | null
    tensionApplied: Decimal | null
    tensionUnit: string | null
    preparation: string | null
    notes: string | null
    spokeId: number | null
    wheelId: number | null
  }

  export type WheelSpokeMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    length: Decimal | null
    tensionApplied: Decimal | null
    tensionUnit: string | null
    preparation: string | null
    notes: string | null
    spokeId: number | null
    wheelId: number | null
  }

  export type WheelSpokeCountAggregateOutputType = {
    id: number
    quantity: number
    length: number
    tensionApplied: number
    tensionUnit: number
    preparation: number
    notes: number
    spokeId: number
    wheelId: number
    _all: number
  }


  export type WheelSpokeAvgAggregateInputType = {
    id?: true
    quantity?: true
    length?: true
    tensionApplied?: true
    spokeId?: true
    wheelId?: true
  }

  export type WheelSpokeSumAggregateInputType = {
    id?: true
    quantity?: true
    length?: true
    tensionApplied?: true
    spokeId?: true
    wheelId?: true
  }

  export type WheelSpokeMinAggregateInputType = {
    id?: true
    quantity?: true
    length?: true
    tensionApplied?: true
    tensionUnit?: true
    preparation?: true
    notes?: true
    spokeId?: true
    wheelId?: true
  }

  export type WheelSpokeMaxAggregateInputType = {
    id?: true
    quantity?: true
    length?: true
    tensionApplied?: true
    tensionUnit?: true
    preparation?: true
    notes?: true
    spokeId?: true
    wheelId?: true
  }

  export type WheelSpokeCountAggregateInputType = {
    id?: true
    quantity?: true
    length?: true
    tensionApplied?: true
    tensionUnit?: true
    preparation?: true
    notes?: true
    spokeId?: true
    wheelId?: true
    _all?: true
  }

  export type WheelSpokeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WheelSpoke to aggregate.
     */
    where?: WheelSpokeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WheelSpokes to fetch.
     */
    orderBy?: WheelSpokeOrderByWithRelationInput | WheelSpokeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WheelSpokeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WheelSpokes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WheelSpokes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WheelSpokes
    **/
    _count?: true | WheelSpokeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WheelSpokeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WheelSpokeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WheelSpokeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WheelSpokeMaxAggregateInputType
  }

  export type GetWheelSpokeAggregateType<T extends WheelSpokeAggregateArgs> = {
        [P in keyof T & keyof AggregateWheelSpoke]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWheelSpoke[P]>
      : GetScalarType<T[P], AggregateWheelSpoke[P]>
  }




  export type WheelSpokeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WheelSpokeWhereInput
    orderBy?: WheelSpokeOrderByWithAggregationInput | WheelSpokeOrderByWithAggregationInput[]
    by: WheelSpokeScalarFieldEnum[] | WheelSpokeScalarFieldEnum
    having?: WheelSpokeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WheelSpokeCountAggregateInputType | true
    _avg?: WheelSpokeAvgAggregateInputType
    _sum?: WheelSpokeSumAggregateInputType
    _min?: WheelSpokeMinAggregateInputType
    _max?: WheelSpokeMaxAggregateInputType
  }

  export type WheelSpokeGroupByOutputType = {
    id: number
    quantity: number | null
    length: Decimal | null
    tensionApplied: Decimal | null
    tensionUnit: string | null
    preparation: string | null
    notes: string | null
    spokeId: number | null
    wheelId: number | null
    _count: WheelSpokeCountAggregateOutputType | null
    _avg: WheelSpokeAvgAggregateOutputType | null
    _sum: WheelSpokeSumAggregateOutputType | null
    _min: WheelSpokeMinAggregateOutputType | null
    _max: WheelSpokeMaxAggregateOutputType | null
  }

  type GetWheelSpokeGroupByPayload<T extends WheelSpokeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WheelSpokeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WheelSpokeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WheelSpokeGroupByOutputType[P]>
            : GetScalarType<T[P], WheelSpokeGroupByOutputType[P]>
        }
      >
    >


  export type WheelSpokeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    length?: boolean
    tensionApplied?: boolean
    tensionUnit?: boolean
    preparation?: boolean
    notes?: boolean
    spokeId?: boolean
    wheelId?: boolean
    spoke?: boolean | WheelSpoke$spokeArgs<ExtArgs>
    wheel?: boolean | WheelSpoke$wheelArgs<ExtArgs>
  }, ExtArgs["result"]["wheelSpoke"]>

  export type WheelSpokeSelectScalar = {
    id?: boolean
    quantity?: boolean
    length?: boolean
    tensionApplied?: boolean
    tensionUnit?: boolean
    preparation?: boolean
    notes?: boolean
    spokeId?: boolean
    wheelId?: boolean
  }

  export type WheelSpokeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spoke?: boolean | WheelSpoke$spokeArgs<ExtArgs>
    wheel?: boolean | WheelSpoke$wheelArgs<ExtArgs>
  }


  export type $WheelSpokePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WheelSpoke"
    objects: {
      spoke: Prisma.$PartPayload<ExtArgs> | null
      wheel: Prisma.$WheelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quantity: number | null
      length: Prisma.Decimal | null
      tensionApplied: Prisma.Decimal | null
      tensionUnit: string | null
      preparation: string | null
      notes: string | null
      spokeId: number | null
      wheelId: number | null
    }, ExtArgs["result"]["wheelSpoke"]>
    composites: {}
  }


  type WheelSpokeGetPayload<S extends boolean | null | undefined | WheelSpokeDefaultArgs> = $Result.GetResult<Prisma.$WheelSpokePayload, S>

  type WheelSpokeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WheelSpokeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: WheelSpokeCountAggregateInputType | true
    }

  export interface WheelSpokeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WheelSpoke'], meta: { name: 'WheelSpoke' } }
    /**
     * Find zero or one WheelSpoke that matches the filter.
     * @param {WheelSpokeFindUniqueArgs} args - Arguments to find a WheelSpoke
     * @example
     * // Get one WheelSpoke
     * const wheelSpoke = await prisma.wheelSpoke.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WheelSpokeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WheelSpokeFindUniqueArgs<ExtArgs>>
    ): Prisma__WheelSpokeClient<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WheelSpoke that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WheelSpokeFindUniqueOrThrowArgs} args - Arguments to find a WheelSpoke
     * @example
     * // Get one WheelSpoke
     * const wheelSpoke = await prisma.wheelSpoke.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WheelSpokeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelSpokeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WheelSpokeClient<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WheelSpoke that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelSpokeFindFirstArgs} args - Arguments to find a WheelSpoke
     * @example
     * // Get one WheelSpoke
     * const wheelSpoke = await prisma.wheelSpoke.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WheelSpokeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelSpokeFindFirstArgs<ExtArgs>>
    ): Prisma__WheelSpokeClient<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WheelSpoke that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelSpokeFindFirstOrThrowArgs} args - Arguments to find a WheelSpoke
     * @example
     * // Get one WheelSpoke
     * const wheelSpoke = await prisma.wheelSpoke.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WheelSpokeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelSpokeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WheelSpokeClient<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WheelSpokes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelSpokeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WheelSpokes
     * const wheelSpokes = await prisma.wheelSpoke.findMany()
     * 
     * // Get first 10 WheelSpokes
     * const wheelSpokes = await prisma.wheelSpoke.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wheelSpokeWithIdOnly = await prisma.wheelSpoke.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WheelSpokeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelSpokeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WheelSpoke.
     * @param {WheelSpokeCreateArgs} args - Arguments to create a WheelSpoke.
     * @example
     * // Create one WheelSpoke
     * const WheelSpoke = await prisma.wheelSpoke.create({
     *   data: {
     *     // ... data to create a WheelSpoke
     *   }
     * })
     * 
    **/
    create<T extends WheelSpokeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WheelSpokeCreateArgs<ExtArgs>>
    ): Prisma__WheelSpokeClient<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WheelSpokes.
     *     @param {WheelSpokeCreateManyArgs} args - Arguments to create many WheelSpokes.
     *     @example
     *     // Create many WheelSpokes
     *     const wheelSpoke = await prisma.wheelSpoke.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WheelSpokeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelSpokeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WheelSpoke.
     * @param {WheelSpokeDeleteArgs} args - Arguments to delete one WheelSpoke.
     * @example
     * // Delete one WheelSpoke
     * const WheelSpoke = await prisma.wheelSpoke.delete({
     *   where: {
     *     // ... filter to delete one WheelSpoke
     *   }
     * })
     * 
    **/
    delete<T extends WheelSpokeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WheelSpokeDeleteArgs<ExtArgs>>
    ): Prisma__WheelSpokeClient<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WheelSpoke.
     * @param {WheelSpokeUpdateArgs} args - Arguments to update one WheelSpoke.
     * @example
     * // Update one WheelSpoke
     * const wheelSpoke = await prisma.wheelSpoke.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WheelSpokeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WheelSpokeUpdateArgs<ExtArgs>>
    ): Prisma__WheelSpokeClient<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WheelSpokes.
     * @param {WheelSpokeDeleteManyArgs} args - Arguments to filter WheelSpokes to delete.
     * @example
     * // Delete a few WheelSpokes
     * const { count } = await prisma.wheelSpoke.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WheelSpokeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelSpokeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WheelSpokes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelSpokeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WheelSpokes
     * const wheelSpoke = await prisma.wheelSpoke.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WheelSpokeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WheelSpokeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WheelSpoke.
     * @param {WheelSpokeUpsertArgs} args - Arguments to update or create a WheelSpoke.
     * @example
     * // Update or create a WheelSpoke
     * const wheelSpoke = await prisma.wheelSpoke.upsert({
     *   create: {
     *     // ... data to create a WheelSpoke
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WheelSpoke we want to update
     *   }
     * })
    **/
    upsert<T extends WheelSpokeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WheelSpokeUpsertArgs<ExtArgs>>
    ): Prisma__WheelSpokeClient<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WheelSpokes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelSpokeCountArgs} args - Arguments to filter WheelSpokes to count.
     * @example
     * // Count the number of WheelSpokes
     * const count = await prisma.wheelSpoke.count({
     *   where: {
     *     // ... the filter for the WheelSpokes we want to count
     *   }
     * })
    **/
    count<T extends WheelSpokeCountArgs>(
      args?: Subset<T, WheelSpokeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WheelSpokeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WheelSpoke.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelSpokeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WheelSpokeAggregateArgs>(args: Subset<T, WheelSpokeAggregateArgs>): Prisma.PrismaPromise<GetWheelSpokeAggregateType<T>>

    /**
     * Group by WheelSpoke.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelSpokeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WheelSpokeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WheelSpokeGroupByArgs['orderBy'] }
        : { orderBy?: WheelSpokeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WheelSpokeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWheelSpokeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WheelSpoke model
   */
  readonly fields: WheelSpokeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WheelSpoke.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WheelSpokeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    spoke<T extends WheelSpoke$spokeArgs<ExtArgs> = {}>(args?: Subset<T, WheelSpoke$spokeArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    wheel<T extends WheelSpoke$wheelArgs<ExtArgs> = {}>(args?: Subset<T, WheelSpoke$wheelArgs<ExtArgs>>): Prisma__WheelClient<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WheelSpoke model
   */ 
  interface WheelSpokeFieldRefs {
    readonly id: FieldRef<"WheelSpoke", 'Int'>
    readonly quantity: FieldRef<"WheelSpoke", 'Int'>
    readonly length: FieldRef<"WheelSpoke", 'Decimal'>
    readonly tensionApplied: FieldRef<"WheelSpoke", 'Decimal'>
    readonly tensionUnit: FieldRef<"WheelSpoke", 'String'>
    readonly preparation: FieldRef<"WheelSpoke", 'String'>
    readonly notes: FieldRef<"WheelSpoke", 'String'>
    readonly spokeId: FieldRef<"WheelSpoke", 'Int'>
    readonly wheelId: FieldRef<"WheelSpoke", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * WheelSpoke findUnique
   */
  export type WheelSpokeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    /**
     * Filter, which WheelSpoke to fetch.
     */
    where: WheelSpokeWhereUniqueInput
  }


  /**
   * WheelSpoke findUniqueOrThrow
   */
  export type WheelSpokeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    /**
     * Filter, which WheelSpoke to fetch.
     */
    where: WheelSpokeWhereUniqueInput
  }


  /**
   * WheelSpoke findFirst
   */
  export type WheelSpokeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    /**
     * Filter, which WheelSpoke to fetch.
     */
    where?: WheelSpokeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WheelSpokes to fetch.
     */
    orderBy?: WheelSpokeOrderByWithRelationInput | WheelSpokeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WheelSpokes.
     */
    cursor?: WheelSpokeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WheelSpokes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WheelSpokes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WheelSpokes.
     */
    distinct?: WheelSpokeScalarFieldEnum | WheelSpokeScalarFieldEnum[]
  }


  /**
   * WheelSpoke findFirstOrThrow
   */
  export type WheelSpokeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    /**
     * Filter, which WheelSpoke to fetch.
     */
    where?: WheelSpokeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WheelSpokes to fetch.
     */
    orderBy?: WheelSpokeOrderByWithRelationInput | WheelSpokeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WheelSpokes.
     */
    cursor?: WheelSpokeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WheelSpokes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WheelSpokes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WheelSpokes.
     */
    distinct?: WheelSpokeScalarFieldEnum | WheelSpokeScalarFieldEnum[]
  }


  /**
   * WheelSpoke findMany
   */
  export type WheelSpokeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    /**
     * Filter, which WheelSpokes to fetch.
     */
    where?: WheelSpokeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WheelSpokes to fetch.
     */
    orderBy?: WheelSpokeOrderByWithRelationInput | WheelSpokeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WheelSpokes.
     */
    cursor?: WheelSpokeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WheelSpokes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WheelSpokes.
     */
    skip?: number
    distinct?: WheelSpokeScalarFieldEnum | WheelSpokeScalarFieldEnum[]
  }


  /**
   * WheelSpoke create
   */
  export type WheelSpokeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    /**
     * The data needed to create a WheelSpoke.
     */
    data?: XOR<WheelSpokeCreateInput, WheelSpokeUncheckedCreateInput>
  }


  /**
   * WheelSpoke createMany
   */
  export type WheelSpokeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WheelSpokes.
     */
    data: WheelSpokeCreateManyInput | WheelSpokeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * WheelSpoke update
   */
  export type WheelSpokeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    /**
     * The data needed to update a WheelSpoke.
     */
    data: XOR<WheelSpokeUpdateInput, WheelSpokeUncheckedUpdateInput>
    /**
     * Choose, which WheelSpoke to update.
     */
    where: WheelSpokeWhereUniqueInput
  }


  /**
   * WheelSpoke updateMany
   */
  export type WheelSpokeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WheelSpokes.
     */
    data: XOR<WheelSpokeUpdateManyMutationInput, WheelSpokeUncheckedUpdateManyInput>
    /**
     * Filter which WheelSpokes to update
     */
    where?: WheelSpokeWhereInput
  }


  /**
   * WheelSpoke upsert
   */
  export type WheelSpokeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    /**
     * The filter to search for the WheelSpoke to update in case it exists.
     */
    where: WheelSpokeWhereUniqueInput
    /**
     * In case the WheelSpoke found by the `where` argument doesn't exist, create a new WheelSpoke with this data.
     */
    create: XOR<WheelSpokeCreateInput, WheelSpokeUncheckedCreateInput>
    /**
     * In case the WheelSpoke was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WheelSpokeUpdateInput, WheelSpokeUncheckedUpdateInput>
  }


  /**
   * WheelSpoke delete
   */
  export type WheelSpokeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    /**
     * Filter which WheelSpoke to delete.
     */
    where: WheelSpokeWhereUniqueInput
  }


  /**
   * WheelSpoke deleteMany
   */
  export type WheelSpokeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WheelSpokes to delete
     */
    where?: WheelSpokeWhereInput
  }


  /**
   * WheelSpoke.spoke
   */
  export type WheelSpoke$spokeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
  }


  /**
   * WheelSpoke.wheel
   */
  export type WheelSpoke$wheelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    where?: WheelWhereInput
  }


  /**
   * WheelSpoke without action
   */
  export type WheelSpokeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
  }



  /**
   * Model Wheel
   */

  export type AggregateWheel = {
    _count: WheelCountAggregateOutputType | null
    _avg: WheelAvgAggregateOutputType | null
    _sum: WheelSumAggregateOutputType | null
    _min: WheelMinAggregateOutputType | null
    _max: WheelMaxAggregateOutputType | null
  }

  export type WheelAvgAggregateOutputType = {
    id: number | null
    hubId: number | null
    rimId: number | null
  }

  export type WheelSumAggregateOutputType = {
    id: number | null
    hubId: number | null
    rimId: number | null
  }

  export type WheelMinAggregateOutputType = {
    id: number | null
    name: string | null
    notes: string | null
    hubId: number | null
    rimId: number | null
  }

  export type WheelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    notes: string | null
    hubId: number | null
    rimId: number | null
  }

  export type WheelCountAggregateOutputType = {
    id: number
    name: number
    notes: number
    hubId: number
    rimId: number
    _all: number
  }


  export type WheelAvgAggregateInputType = {
    id?: true
    hubId?: true
    rimId?: true
  }

  export type WheelSumAggregateInputType = {
    id?: true
    hubId?: true
    rimId?: true
  }

  export type WheelMinAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    hubId?: true
    rimId?: true
  }

  export type WheelMaxAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    hubId?: true
    rimId?: true
  }

  export type WheelCountAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    hubId?: true
    rimId?: true
    _all?: true
  }

  export type WheelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wheel to aggregate.
     */
    where?: WheelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wheels to fetch.
     */
    orderBy?: WheelOrderByWithRelationInput | WheelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WheelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wheels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wheels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wheels
    **/
    _count?: true | WheelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WheelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WheelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WheelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WheelMaxAggregateInputType
  }

  export type GetWheelAggregateType<T extends WheelAggregateArgs> = {
        [P in keyof T & keyof AggregateWheel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWheel[P]>
      : GetScalarType<T[P], AggregateWheel[P]>
  }




  export type WheelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WheelWhereInput
    orderBy?: WheelOrderByWithAggregationInput | WheelOrderByWithAggregationInput[]
    by: WheelScalarFieldEnum[] | WheelScalarFieldEnum
    having?: WheelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WheelCountAggregateInputType | true
    _avg?: WheelAvgAggregateInputType
    _sum?: WheelSumAggregateInputType
    _min?: WheelMinAggregateInputType
    _max?: WheelMaxAggregateInputType
  }

  export type WheelGroupByOutputType = {
    id: number
    name: string | null
    notes: string | null
    hubId: number | null
    rimId: number | null
    _count: WheelCountAggregateOutputType | null
    _avg: WheelAvgAggregateOutputType | null
    _sum: WheelSumAggregateOutputType | null
    _min: WheelMinAggregateOutputType | null
    _max: WheelMaxAggregateOutputType | null
  }

  type GetWheelGroupByPayload<T extends WheelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WheelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WheelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WheelGroupByOutputType[P]>
            : GetScalarType<T[P], WheelGroupByOutputType[P]>
        }
      >
    >


  export type WheelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    hubId?: boolean
    rimId?: boolean
    hub?: boolean | Wheel$hubArgs<ExtArgs>
    rim?: boolean | Wheel$rimArgs<ExtArgs>
    spokes?: boolean | Wheel$spokesArgs<ExtArgs>
    _count?: boolean | WheelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wheel"]>

  export type WheelSelectScalar = {
    id?: boolean
    name?: boolean
    notes?: boolean
    hubId?: boolean
    rimId?: boolean
  }

  export type WheelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hub?: boolean | Wheel$hubArgs<ExtArgs>
    rim?: boolean | Wheel$rimArgs<ExtArgs>
    spokes?: boolean | Wheel$spokesArgs<ExtArgs>
    _count?: boolean | WheelCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $WheelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wheel"
    objects: {
      hub: Prisma.$PartPayload<ExtArgs> | null
      rim: Prisma.$PartPayload<ExtArgs> | null
      spokes: Prisma.$WheelSpokePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      notes: string | null
      hubId: number | null
      rimId: number | null
    }, ExtArgs["result"]["wheel"]>
    composites: {}
  }


  type WheelGetPayload<S extends boolean | null | undefined | WheelDefaultArgs> = $Result.GetResult<Prisma.$WheelPayload, S>

  type WheelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WheelFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: WheelCountAggregateInputType | true
    }

  export interface WheelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wheel'], meta: { name: 'Wheel' } }
    /**
     * Find zero or one Wheel that matches the filter.
     * @param {WheelFindUniqueArgs} args - Arguments to find a Wheel
     * @example
     * // Get one Wheel
     * const wheel = await prisma.wheel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WheelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WheelFindUniqueArgs<ExtArgs>>
    ): Prisma__WheelClient<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Wheel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WheelFindUniqueOrThrowArgs} args - Arguments to find a Wheel
     * @example
     * // Get one Wheel
     * const wheel = await prisma.wheel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WheelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WheelClient<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Wheel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelFindFirstArgs} args - Arguments to find a Wheel
     * @example
     * // Get one Wheel
     * const wheel = await prisma.wheel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WheelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelFindFirstArgs<ExtArgs>>
    ): Prisma__WheelClient<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Wheel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelFindFirstOrThrowArgs} args - Arguments to find a Wheel
     * @example
     * // Get one Wheel
     * const wheel = await prisma.wheel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WheelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WheelClient<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Wheels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wheels
     * const wheels = await prisma.wheel.findMany()
     * 
     * // Get first 10 Wheels
     * const wheels = await prisma.wheel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wheelWithIdOnly = await prisma.wheel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WheelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Wheel.
     * @param {WheelCreateArgs} args - Arguments to create a Wheel.
     * @example
     * // Create one Wheel
     * const Wheel = await prisma.wheel.create({
     *   data: {
     *     // ... data to create a Wheel
     *   }
     * })
     * 
    **/
    create<T extends WheelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WheelCreateArgs<ExtArgs>>
    ): Prisma__WheelClient<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Wheels.
     *     @param {WheelCreateManyArgs} args - Arguments to create many Wheels.
     *     @example
     *     // Create many Wheels
     *     const wheel = await prisma.wheel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WheelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wheel.
     * @param {WheelDeleteArgs} args - Arguments to delete one Wheel.
     * @example
     * // Delete one Wheel
     * const Wheel = await prisma.wheel.delete({
     *   where: {
     *     // ... filter to delete one Wheel
     *   }
     * })
     * 
    **/
    delete<T extends WheelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WheelDeleteArgs<ExtArgs>>
    ): Prisma__WheelClient<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Wheel.
     * @param {WheelUpdateArgs} args - Arguments to update one Wheel.
     * @example
     * // Update one Wheel
     * const wheel = await prisma.wheel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WheelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WheelUpdateArgs<ExtArgs>>
    ): Prisma__WheelClient<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Wheels.
     * @param {WheelDeleteManyArgs} args - Arguments to filter Wheels to delete.
     * @example
     * // Delete a few Wheels
     * const { count } = await prisma.wheel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WheelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WheelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wheels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wheels
     * const wheel = await prisma.wheel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WheelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WheelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wheel.
     * @param {WheelUpsertArgs} args - Arguments to update or create a Wheel.
     * @example
     * // Update or create a Wheel
     * const wheel = await prisma.wheel.upsert({
     *   create: {
     *     // ... data to create a Wheel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wheel we want to update
     *   }
     * })
    **/
    upsert<T extends WheelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WheelUpsertArgs<ExtArgs>>
    ): Prisma__WheelClient<$Result.GetResult<Prisma.$WheelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Wheels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelCountArgs} args - Arguments to filter Wheels to count.
     * @example
     * // Count the number of Wheels
     * const count = await prisma.wheel.count({
     *   where: {
     *     // ... the filter for the Wheels we want to count
     *   }
     * })
    **/
    count<T extends WheelCountArgs>(
      args?: Subset<T, WheelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WheelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wheel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WheelAggregateArgs>(args: Subset<T, WheelAggregateArgs>): Prisma.PrismaPromise<GetWheelAggregateType<T>>

    /**
     * Group by Wheel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WheelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WheelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WheelGroupByArgs['orderBy'] }
        : { orderBy?: WheelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WheelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWheelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wheel model
   */
  readonly fields: WheelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wheel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WheelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    hub<T extends Wheel$hubArgs<ExtArgs> = {}>(args?: Subset<T, Wheel$hubArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rim<T extends Wheel$rimArgs<ExtArgs> = {}>(args?: Subset<T, Wheel$rimArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    spokes<T extends Wheel$spokesArgs<ExtArgs> = {}>(args?: Subset<T, Wheel$spokesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WheelSpokePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Wheel model
   */ 
  interface WheelFieldRefs {
    readonly id: FieldRef<"Wheel", 'Int'>
    readonly name: FieldRef<"Wheel", 'String'>
    readonly notes: FieldRef<"Wheel", 'String'>
    readonly hubId: FieldRef<"Wheel", 'Int'>
    readonly rimId: FieldRef<"Wheel", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Wheel findUnique
   */
  export type WheelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    /**
     * Filter, which Wheel to fetch.
     */
    where: WheelWhereUniqueInput
  }


  /**
   * Wheel findUniqueOrThrow
   */
  export type WheelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    /**
     * Filter, which Wheel to fetch.
     */
    where: WheelWhereUniqueInput
  }


  /**
   * Wheel findFirst
   */
  export type WheelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    /**
     * Filter, which Wheel to fetch.
     */
    where?: WheelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wheels to fetch.
     */
    orderBy?: WheelOrderByWithRelationInput | WheelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wheels.
     */
    cursor?: WheelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wheels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wheels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wheels.
     */
    distinct?: WheelScalarFieldEnum | WheelScalarFieldEnum[]
  }


  /**
   * Wheel findFirstOrThrow
   */
  export type WheelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    /**
     * Filter, which Wheel to fetch.
     */
    where?: WheelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wheels to fetch.
     */
    orderBy?: WheelOrderByWithRelationInput | WheelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wheels.
     */
    cursor?: WheelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wheels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wheels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wheels.
     */
    distinct?: WheelScalarFieldEnum | WheelScalarFieldEnum[]
  }


  /**
   * Wheel findMany
   */
  export type WheelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    /**
     * Filter, which Wheels to fetch.
     */
    where?: WheelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wheels to fetch.
     */
    orderBy?: WheelOrderByWithRelationInput | WheelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wheels.
     */
    cursor?: WheelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wheels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wheels.
     */
    skip?: number
    distinct?: WheelScalarFieldEnum | WheelScalarFieldEnum[]
  }


  /**
   * Wheel create
   */
  export type WheelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    /**
     * The data needed to create a Wheel.
     */
    data?: XOR<WheelCreateInput, WheelUncheckedCreateInput>
  }


  /**
   * Wheel createMany
   */
  export type WheelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wheels.
     */
    data: WheelCreateManyInput | WheelCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Wheel update
   */
  export type WheelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    /**
     * The data needed to update a Wheel.
     */
    data: XOR<WheelUpdateInput, WheelUncheckedUpdateInput>
    /**
     * Choose, which Wheel to update.
     */
    where: WheelWhereUniqueInput
  }


  /**
   * Wheel updateMany
   */
  export type WheelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wheels.
     */
    data: XOR<WheelUpdateManyMutationInput, WheelUncheckedUpdateManyInput>
    /**
     * Filter which Wheels to update
     */
    where?: WheelWhereInput
  }


  /**
   * Wheel upsert
   */
  export type WheelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    /**
     * The filter to search for the Wheel to update in case it exists.
     */
    where: WheelWhereUniqueInput
    /**
     * In case the Wheel found by the `where` argument doesn't exist, create a new Wheel with this data.
     */
    create: XOR<WheelCreateInput, WheelUncheckedCreateInput>
    /**
     * In case the Wheel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WheelUpdateInput, WheelUncheckedUpdateInput>
  }


  /**
   * Wheel delete
   */
  export type WheelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
    /**
     * Filter which Wheel to delete.
     */
    where: WheelWhereUniqueInput
  }


  /**
   * Wheel deleteMany
   */
  export type WheelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wheels to delete
     */
    where?: WheelWhereInput
  }


  /**
   * Wheel.hub
   */
  export type Wheel$hubArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
  }


  /**
   * Wheel.rim
   */
  export type Wheel$rimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
  }


  /**
   * Wheel.spokes
   */
  export type Wheel$spokesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WheelSpoke
     */
    select?: WheelSpokeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelSpokeInclude<ExtArgs> | null
    where?: WheelSpokeWhereInput
    orderBy?: WheelSpokeOrderByWithRelationInput | WheelSpokeOrderByWithRelationInput[]
    cursor?: WheelSpokeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WheelSpokeScalarFieldEnum | WheelSpokeScalarFieldEnum[]
  }


  /**
   * Wheel without action
   */
  export type WheelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wheel
     */
    select?: WheelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WheelInclude<ExtArgs> | null
  }



  /**
   * Model BuildPart
   */

  export type AggregateBuildPart = {
    _count: BuildPartCountAggregateOutputType | null
    _avg: BuildPartAvgAggregateOutputType | null
    _sum: BuildPartSumAggregateOutputType | null
    _min: BuildPartMinAggregateOutputType | null
    _max: BuildPartMaxAggregateOutputType | null
  }

  export type BuildPartAvgAggregateOutputType = {
    id: number | null
    buildId: number | null
    partId: number | null
  }

  export type BuildPartSumAggregateOutputType = {
    id: number | null
    buildId: number | null
    partId: number | null
  }

  export type BuildPartMinAggregateOutputType = {
    id: number | null
    buildId: number | null
    partId: number | null
  }

  export type BuildPartMaxAggregateOutputType = {
    id: number | null
    buildId: number | null
    partId: number | null
  }

  export type BuildPartCountAggregateOutputType = {
    id: number
    buildId: number
    partId: number
    _all: number
  }


  export type BuildPartAvgAggregateInputType = {
    id?: true
    buildId?: true
    partId?: true
  }

  export type BuildPartSumAggregateInputType = {
    id?: true
    buildId?: true
    partId?: true
  }

  export type BuildPartMinAggregateInputType = {
    id?: true
    buildId?: true
    partId?: true
  }

  export type BuildPartMaxAggregateInputType = {
    id?: true
    buildId?: true
    partId?: true
  }

  export type BuildPartCountAggregateInputType = {
    id?: true
    buildId?: true
    partId?: true
    _all?: true
  }

  export type BuildPartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildPart to aggregate.
     */
    where?: BuildPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildParts to fetch.
     */
    orderBy?: BuildPartOrderByWithRelationInput | BuildPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuildParts
    **/
    _count?: true | BuildPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildPartMaxAggregateInputType
  }

  export type GetBuildPartAggregateType<T extends BuildPartAggregateArgs> = {
        [P in keyof T & keyof AggregateBuildPart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuildPart[P]>
      : GetScalarType<T[P], AggregateBuildPart[P]>
  }




  export type BuildPartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildPartWhereInput
    orderBy?: BuildPartOrderByWithAggregationInput | BuildPartOrderByWithAggregationInput[]
    by: BuildPartScalarFieldEnum[] | BuildPartScalarFieldEnum
    having?: BuildPartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildPartCountAggregateInputType | true
    _avg?: BuildPartAvgAggregateInputType
    _sum?: BuildPartSumAggregateInputType
    _min?: BuildPartMinAggregateInputType
    _max?: BuildPartMaxAggregateInputType
  }

  export type BuildPartGroupByOutputType = {
    id: number
    buildId: number | null
    partId: number | null
    _count: BuildPartCountAggregateOutputType | null
    _avg: BuildPartAvgAggregateOutputType | null
    _sum: BuildPartSumAggregateOutputType | null
    _min: BuildPartMinAggregateOutputType | null
    _max: BuildPartMaxAggregateOutputType | null
  }

  type GetBuildPartGroupByPayload<T extends BuildPartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildPartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildPartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildPartGroupByOutputType[P]>
            : GetScalarType<T[P], BuildPartGroupByOutputType[P]>
        }
      >
    >


  export type BuildPartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buildId?: boolean
    partId?: boolean
    build?: boolean | BuildPart$buildArgs<ExtArgs>
    part?: boolean | BuildPart$partArgs<ExtArgs>
  }, ExtArgs["result"]["buildPart"]>

  export type BuildPartSelectScalar = {
    id?: boolean
    buildId?: boolean
    partId?: boolean
  }

  export type BuildPartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    build?: boolean | BuildPart$buildArgs<ExtArgs>
    part?: boolean | BuildPart$partArgs<ExtArgs>
  }


  export type $BuildPartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuildPart"
    objects: {
      build: Prisma.$BuildPayload<ExtArgs> | null
      part: Prisma.$PartPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      buildId: number | null
      partId: number | null
    }, ExtArgs["result"]["buildPart"]>
    composites: {}
  }


  type BuildPartGetPayload<S extends boolean | null | undefined | BuildPartDefaultArgs> = $Result.GetResult<Prisma.$BuildPartPayload, S>

  type BuildPartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildPartFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BuildPartCountAggregateInputType | true
    }

  export interface BuildPartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuildPart'], meta: { name: 'BuildPart' } }
    /**
     * Find zero or one BuildPart that matches the filter.
     * @param {BuildPartFindUniqueArgs} args - Arguments to find a BuildPart
     * @example
     * // Get one BuildPart
     * const buildPart = await prisma.buildPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildPartFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildPartFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildPartClient<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BuildPart that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildPartFindUniqueOrThrowArgs} args - Arguments to find a BuildPart
     * @example
     * // Get one BuildPart
     * const buildPart = await prisma.buildPart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildPartFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildPartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildPartClient<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BuildPart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildPartFindFirstArgs} args - Arguments to find a BuildPart
     * @example
     * // Get one BuildPart
     * const buildPart = await prisma.buildPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildPartFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildPartFindFirstArgs<ExtArgs>>
    ): Prisma__BuildPartClient<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BuildPart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildPartFindFirstOrThrowArgs} args - Arguments to find a BuildPart
     * @example
     * // Get one BuildPart
     * const buildPart = await prisma.buildPart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildPartFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildPartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildPartClient<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BuildParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildPartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuildParts
     * const buildParts = await prisma.buildPart.findMany()
     * 
     * // Get first 10 BuildParts
     * const buildParts = await prisma.buildPart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildPartWithIdOnly = await prisma.buildPart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildPartFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildPartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BuildPart.
     * @param {BuildPartCreateArgs} args - Arguments to create a BuildPart.
     * @example
     * // Create one BuildPart
     * const BuildPart = await prisma.buildPart.create({
     *   data: {
     *     // ... data to create a BuildPart
     *   }
     * })
     * 
    **/
    create<T extends BuildPartCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildPartCreateArgs<ExtArgs>>
    ): Prisma__BuildPartClient<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BuildParts.
     *     @param {BuildPartCreateManyArgs} args - Arguments to create many BuildParts.
     *     @example
     *     // Create many BuildParts
     *     const buildPart = await prisma.buildPart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildPartCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildPartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuildPart.
     * @param {BuildPartDeleteArgs} args - Arguments to delete one BuildPart.
     * @example
     * // Delete one BuildPart
     * const BuildPart = await prisma.buildPart.delete({
     *   where: {
     *     // ... filter to delete one BuildPart
     *   }
     * })
     * 
    **/
    delete<T extends BuildPartDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildPartDeleteArgs<ExtArgs>>
    ): Prisma__BuildPartClient<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BuildPart.
     * @param {BuildPartUpdateArgs} args - Arguments to update one BuildPart.
     * @example
     * // Update one BuildPart
     * const buildPart = await prisma.buildPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildPartUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildPartUpdateArgs<ExtArgs>>
    ): Prisma__BuildPartClient<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BuildParts.
     * @param {BuildPartDeleteManyArgs} args - Arguments to filter BuildParts to delete.
     * @example
     * // Delete a few BuildParts
     * const { count } = await prisma.buildPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildPartDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildPartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuildParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuildParts
     * const buildPart = await prisma.buildPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildPartUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildPartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuildPart.
     * @param {BuildPartUpsertArgs} args - Arguments to update or create a BuildPart.
     * @example
     * // Update or create a BuildPart
     * const buildPart = await prisma.buildPart.upsert({
     *   create: {
     *     // ... data to create a BuildPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuildPart we want to update
     *   }
     * })
    **/
    upsert<T extends BuildPartUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildPartUpsertArgs<ExtArgs>>
    ): Prisma__BuildPartClient<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BuildParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildPartCountArgs} args - Arguments to filter BuildParts to count.
     * @example
     * // Count the number of BuildParts
     * const count = await prisma.buildPart.count({
     *   where: {
     *     // ... the filter for the BuildParts we want to count
     *   }
     * })
    **/
    count<T extends BuildPartCountArgs>(
      args?: Subset<T, BuildPartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuildPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildPartAggregateArgs>(args: Subset<T, BuildPartAggregateArgs>): Prisma.PrismaPromise<GetBuildPartAggregateType<T>>

    /**
     * Group by BuildPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildPartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildPartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildPartGroupByArgs['orderBy'] }
        : { orderBy?: BuildPartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildPartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuildPart model
   */
  readonly fields: BuildPartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuildPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildPartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    build<T extends BuildPart$buildArgs<ExtArgs> = {}>(args?: Subset<T, BuildPart$buildArgs<ExtArgs>>): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    part<T extends BuildPart$partArgs<ExtArgs> = {}>(args?: Subset<T, BuildPart$partArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BuildPart model
   */ 
  interface BuildPartFieldRefs {
    readonly id: FieldRef<"BuildPart", 'Int'>
    readonly buildId: FieldRef<"BuildPart", 'Int'>
    readonly partId: FieldRef<"BuildPart", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * BuildPart findUnique
   */
  export type BuildPartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    /**
     * Filter, which BuildPart to fetch.
     */
    where: BuildPartWhereUniqueInput
  }


  /**
   * BuildPart findUniqueOrThrow
   */
  export type BuildPartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    /**
     * Filter, which BuildPart to fetch.
     */
    where: BuildPartWhereUniqueInput
  }


  /**
   * BuildPart findFirst
   */
  export type BuildPartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    /**
     * Filter, which BuildPart to fetch.
     */
    where?: BuildPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildParts to fetch.
     */
    orderBy?: BuildPartOrderByWithRelationInput | BuildPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildParts.
     */
    cursor?: BuildPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildParts.
     */
    distinct?: BuildPartScalarFieldEnum | BuildPartScalarFieldEnum[]
  }


  /**
   * BuildPart findFirstOrThrow
   */
  export type BuildPartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    /**
     * Filter, which BuildPart to fetch.
     */
    where?: BuildPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildParts to fetch.
     */
    orderBy?: BuildPartOrderByWithRelationInput | BuildPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuildParts.
     */
    cursor?: BuildPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuildParts.
     */
    distinct?: BuildPartScalarFieldEnum | BuildPartScalarFieldEnum[]
  }


  /**
   * BuildPart findMany
   */
  export type BuildPartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    /**
     * Filter, which BuildParts to fetch.
     */
    where?: BuildPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuildParts to fetch.
     */
    orderBy?: BuildPartOrderByWithRelationInput | BuildPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuildParts.
     */
    cursor?: BuildPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuildParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuildParts.
     */
    skip?: number
    distinct?: BuildPartScalarFieldEnum | BuildPartScalarFieldEnum[]
  }


  /**
   * BuildPart create
   */
  export type BuildPartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    /**
     * The data needed to create a BuildPart.
     */
    data?: XOR<BuildPartCreateInput, BuildPartUncheckedCreateInput>
  }


  /**
   * BuildPart createMany
   */
  export type BuildPartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuildParts.
     */
    data: BuildPartCreateManyInput | BuildPartCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BuildPart update
   */
  export type BuildPartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    /**
     * The data needed to update a BuildPart.
     */
    data: XOR<BuildPartUpdateInput, BuildPartUncheckedUpdateInput>
    /**
     * Choose, which BuildPart to update.
     */
    where: BuildPartWhereUniqueInput
  }


  /**
   * BuildPart updateMany
   */
  export type BuildPartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuildParts.
     */
    data: XOR<BuildPartUpdateManyMutationInput, BuildPartUncheckedUpdateManyInput>
    /**
     * Filter which BuildParts to update
     */
    where?: BuildPartWhereInput
  }


  /**
   * BuildPart upsert
   */
  export type BuildPartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    /**
     * The filter to search for the BuildPart to update in case it exists.
     */
    where: BuildPartWhereUniqueInput
    /**
     * In case the BuildPart found by the `where` argument doesn't exist, create a new BuildPart with this data.
     */
    create: XOR<BuildPartCreateInput, BuildPartUncheckedCreateInput>
    /**
     * In case the BuildPart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildPartUpdateInput, BuildPartUncheckedUpdateInput>
  }


  /**
   * BuildPart delete
   */
  export type BuildPartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    /**
     * Filter which BuildPart to delete.
     */
    where: BuildPartWhereUniqueInput
  }


  /**
   * BuildPart deleteMany
   */
  export type BuildPartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuildParts to delete
     */
    where?: BuildPartWhereInput
  }


  /**
   * BuildPart.build
   */
  export type BuildPart$buildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    where?: BuildWhereInput
  }


  /**
   * BuildPart.part
   */
  export type BuildPart$partArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
  }


  /**
   * BuildPart without action
   */
  export type BuildPartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
  }



  /**
   * Model Build
   */

  export type AggregateBuild = {
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  export type BuildAvgAggregateOutputType = {
    id: number | null
  }

  export type BuildSumAggregateOutputType = {
    id: number | null
  }

  export type BuildMinAggregateOutputType = {
    id: number | null
    name: string | null
    status: string | null
    notes: string | null
  }

  export type BuildMaxAggregateOutputType = {
    id: number | null
    name: string | null
    status: string | null
    notes: string | null
  }

  export type BuildCountAggregateOutputType = {
    id: number
    name: number
    status: number
    notes: number
    _all: number
  }


  export type BuildAvgAggregateInputType = {
    id?: true
  }

  export type BuildSumAggregateInputType = {
    id?: true
  }

  export type BuildMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    notes?: true
  }

  export type BuildMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    notes?: true
  }

  export type BuildCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type BuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Build to aggregate.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Builds
    **/
    _count?: true | BuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildMaxAggregateInputType
  }

  export type GetBuildAggregateType<T extends BuildAggregateArgs> = {
        [P in keyof T & keyof AggregateBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuild[P]>
      : GetScalarType<T[P], AggregateBuild[P]>
  }




  export type BuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildWhereInput
    orderBy?: BuildOrderByWithAggregationInput | BuildOrderByWithAggregationInput[]
    by: BuildScalarFieldEnum[] | BuildScalarFieldEnum
    having?: BuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildCountAggregateInputType | true
    _avg?: BuildAvgAggregateInputType
    _sum?: BuildSumAggregateInputType
    _min?: BuildMinAggregateInputType
    _max?: BuildMaxAggregateInputType
  }

  export type BuildGroupByOutputType = {
    id: number
    name: string | null
    status: string | null
    notes: string | null
    _count: BuildCountAggregateOutputType | null
    _avg: BuildAvgAggregateOutputType | null
    _sum: BuildSumAggregateOutputType | null
    _min: BuildMinAggregateOutputType | null
    _max: BuildMaxAggregateOutputType | null
  }

  type GetBuildGroupByPayload<T extends BuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildGroupByOutputType[P]>
            : GetScalarType<T[P], BuildGroupByOutputType[P]>
        }
      >
    >


  export type BuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    notes?: boolean
    parts?: boolean | Build$partsArgs<ExtArgs>
    _count?: boolean | BuildCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["build"]>

  export type BuildSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    notes?: boolean
  }

  export type BuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parts?: boolean | Build$partsArgs<ExtArgs>
    _count?: boolean | BuildCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Build"
    objects: {
      parts: Prisma.$BuildPartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      status: string | null
      notes: string | null
    }, ExtArgs["result"]["build"]>
    composites: {}
  }


  type BuildGetPayload<S extends boolean | null | undefined | BuildDefaultArgs> = $Result.GetResult<Prisma.$BuildPayload, S>

  type BuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BuildCountAggregateInputType | true
    }

  export interface BuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Build'], meta: { name: 'Build' } }
    /**
     * Find zero or one Build that matches the filter.
     * @param {BuildFindUniqueArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Build that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildFindUniqueOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Build that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindFirstArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Build that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindFirstOrThrowArgs} args - Arguments to find a Build
     * @example
     * // Get one Build
     * const build = await prisma.build.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Builds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Builds
     * const builds = await prisma.build.findMany()
     * 
     * // Get first 10 Builds
     * const builds = await prisma.build.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildWithIdOnly = await prisma.build.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Build.
     * @param {BuildCreateArgs} args - Arguments to create a Build.
     * @example
     * // Create one Build
     * const Build = await prisma.build.create({
     *   data: {
     *     // ... data to create a Build
     *   }
     * })
     * 
    **/
    create<T extends BuildCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildCreateArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Builds.
     *     @param {BuildCreateManyArgs} args - Arguments to create many Builds.
     *     @example
     *     // Create many Builds
     *     const build = await prisma.build.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Build.
     * @param {BuildDeleteArgs} args - Arguments to delete one Build.
     * @example
     * // Delete one Build
     * const Build = await prisma.build.delete({
     *   where: {
     *     // ... filter to delete one Build
     *   }
     * })
     * 
    **/
    delete<T extends BuildDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildDeleteArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Build.
     * @param {BuildUpdateArgs} args - Arguments to update one Build.
     * @example
     * // Update one Build
     * const build = await prisma.build.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUpdateArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Builds.
     * @param {BuildDeleteManyArgs} args - Arguments to filter Builds to delete.
     * @example
     * // Delete a few Builds
     * const { count } = await prisma.build.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Builds
     * const build = await prisma.build.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Build.
     * @param {BuildUpsertArgs} args - Arguments to update or create a Build.
     * @example
     * // Update or create a Build
     * const build = await prisma.build.upsert({
     *   create: {
     *     // ... data to create a Build
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Build we want to update
     *   }
     * })
    **/
    upsert<T extends BuildUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildUpsertArgs<ExtArgs>>
    ): Prisma__BuildClient<$Result.GetResult<Prisma.$BuildPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Builds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildCountArgs} args - Arguments to filter Builds to count.
     * @example
     * // Count the number of Builds
     * const count = await prisma.build.count({
     *   where: {
     *     // ... the filter for the Builds we want to count
     *   }
     * })
    **/
    count<T extends BuildCountArgs>(
      args?: Subset<T, BuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildAggregateArgs>(args: Subset<T, BuildAggregateArgs>): Prisma.PrismaPromise<GetBuildAggregateType<T>>

    /**
     * Group by Build.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildGroupByArgs['orderBy'] }
        : { orderBy?: BuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Build model
   */
  readonly fields: BuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Build.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    parts<T extends Build$partsArgs<ExtArgs> = {}>(args?: Subset<T, Build$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildPartPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Build model
   */ 
  interface BuildFieldRefs {
    readonly id: FieldRef<"Build", 'Int'>
    readonly name: FieldRef<"Build", 'String'>
    readonly status: FieldRef<"Build", 'String'>
    readonly notes: FieldRef<"Build", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Build findUnique
   */
  export type BuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build findUniqueOrThrow
   */
  export type BuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build findFirst
   */
  export type BuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     */
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Build findFirstOrThrow
   */
  export type BuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Build to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Builds.
     */
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Build findMany
   */
  export type BuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter, which Builds to fetch.
     */
    where?: BuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Builds to fetch.
     */
    orderBy?: BuildOrderByWithRelationInput | BuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Builds.
     */
    cursor?: BuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Builds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Builds.
     */
    skip?: number
    distinct?: BuildScalarFieldEnum | BuildScalarFieldEnum[]
  }


  /**
   * Build create
   */
  export type BuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The data needed to create a Build.
     */
    data?: XOR<BuildCreateInput, BuildUncheckedCreateInput>
  }


  /**
   * Build createMany
   */
  export type BuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Builds.
     */
    data: BuildCreateManyInput | BuildCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Build update
   */
  export type BuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The data needed to update a Build.
     */
    data: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
    /**
     * Choose, which Build to update.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build updateMany
   */
  export type BuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Builds.
     */
    data: XOR<BuildUpdateManyMutationInput, BuildUncheckedUpdateManyInput>
    /**
     * Filter which Builds to update
     */
    where?: BuildWhereInput
  }


  /**
   * Build upsert
   */
  export type BuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * The filter to search for the Build to update in case it exists.
     */
    where: BuildWhereUniqueInput
    /**
     * In case the Build found by the `where` argument doesn't exist, create a new Build with this data.
     */
    create: XOR<BuildCreateInput, BuildUncheckedCreateInput>
    /**
     * In case the Build was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildUpdateInput, BuildUncheckedUpdateInput>
  }


  /**
   * Build delete
   */
  export type BuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
    /**
     * Filter which Build to delete.
     */
    where: BuildWhereUniqueInput
  }


  /**
   * Build deleteMany
   */
  export type BuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Builds to delete
     */
    where?: BuildWhereInput
  }


  /**
   * Build.parts
   */
  export type Build$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildPart
     */
    select?: BuildPartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildPartInclude<ExtArgs> | null
    where?: BuildPartWhereInput
    orderBy?: BuildPartOrderByWithRelationInput | BuildPartOrderByWithRelationInput[]
    cursor?: BuildPartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildPartScalarFieldEnum | BuildPartScalarFieldEnum[]
  }


  /**
   * Build without action
   */
  export type BuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Build
     */
    select?: BuildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameLast: 'nameLast',
    nameFirst: 'nameFirst',
    providerId: 'providerId',
    provider: 'provider',
    roles: 'roles',
    registered: 'registered',
    lastLogIn: 'lastLogIn'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    claimType: 'claimType',
    acquired: 'acquired',
    condition: 'condition',
    notes: 'notes',
    ownerId: 'ownerId',
    partId: 'partId'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameShort: 'nameShort',
    nameAbbreviation: 'nameAbbreviation',
    notes: 'notes',
    webAddress: 'webAddress'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const BrandMemberScalarFieldEnum: {
    id: 'id',
    productLineId: 'productLineId',
    brandId: 'brandId'
  };

  export type BrandMemberScalarFieldEnum = (typeof BrandMemberScalarFieldEnum)[keyof typeof BrandMemberScalarFieldEnum]


  export const ProductLineScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    nameShort: 'nameShort',
    nameAbbreviation: 'nameAbbreviation',
    notes: 'notes',
    webAddress: 'webAddress'
  };

  export type ProductLineScalarFieldEnum = (typeof ProductLineScalarFieldEnum)[keyof typeof ProductLineScalarFieldEnum]


  export const PropertyGroupScalarFieldEnum: {
    id: 'id',
    order: 'order',
    name: 'name',
    description: 'description'
  };

  export type PropertyGroupScalarFieldEnum = (typeof PropertyGroupScalarFieldEnum)[keyof typeof PropertyGroupScalarFieldEnum]


  export const PropertyGroupMembershipScalarFieldEnum: {
    id: 'id',
    partTypeId: 'partTypeId',
    propertyTypeId: 'propertyTypeId',
    groupId: 'groupId'
  };

  export type PropertyGroupMembershipScalarFieldEnum = (typeof PropertyGroupMembershipScalarFieldEnum)[keyof typeof PropertyGroupMembershipScalarFieldEnum]


  export const PropertyTypeScalarFieldEnum: {
    id: 'id',
    order: 'order',
    name: 'name',
    description: 'description',
    valueDataType: 'valueDataType',
    valueDataTypeModifier: 'valueDataTypeModifier',
    variation: 'variation'
  };

  export type PropertyTypeScalarFieldEnum = (typeof PropertyTypeScalarFieldEnum)[keyof typeof PropertyTypeScalarFieldEnum]


  export const PropertyLookupScalarFieldEnum: {
    id: 'id',
    value: 'value',
    propertyTypeId: 'propertyTypeId'
  };

  export type PropertyLookupScalarFieldEnum = (typeof PropertyLookupScalarFieldEnum)[keyof typeof PropertyLookupScalarFieldEnum]


  export const PartClassScalarFieldEnum: {
    id: 'id',
    order: 'order',
    name: 'name'
  };

  export type PartClassScalarFieldEnum = (typeof PartClassScalarFieldEnum)[keyof typeof PartClassScalarFieldEnum]


  export const PartClassMembershipScalarFieldEnum: {
    id: 'id',
    partClassId: 'partClassId',
    partTypeId: 'partTypeId'
  };

  export type PartClassMembershipScalarFieldEnum = (typeof PartClassMembershipScalarFieldEnum)[keyof typeof PartClassMembershipScalarFieldEnum]


  export const PartTypeScalarFieldEnum: {
    id: 'id',
    order: 'order',
    name: 'name',
    description: 'description'
  };

  export type PartTypeScalarFieldEnum = (typeof PartTypeScalarFieldEnum)[keyof typeof PartTypeScalarFieldEnum]


  export const PartGroupScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PartGroupScalarFieldEnum = (typeof PartGroupScalarFieldEnum)[keyof typeof PartGroupScalarFieldEnum]


  export const PartGroupMembershipScalarFieldEnum: {
    id: 'id',
    partId: 'partId',
    groupId: 'groupId'
  };

  export type PartGroupMembershipScalarFieldEnum = (typeof PartGroupMembershipScalarFieldEnum)[keyof typeof PartGroupMembershipScalarFieldEnum]


  export const PartScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    notes: 'notes',
    weight: 'weight',
    weightUnit: 'weightUnit',
    productLineId: 'productLineId'
  };

  export type PartScalarFieldEnum = (typeof PartScalarFieldEnum)[keyof typeof PartScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    value: 'value',
    valueDataMethod: 'valueDataMethod',
    propertyTypeId: 'propertyTypeId'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const WheelSpokeScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    length: 'length',
    tensionApplied: 'tensionApplied',
    tensionUnit: 'tensionUnit',
    preparation: 'preparation',
    notes: 'notes',
    spokeId: 'spokeId',
    wheelId: 'wheelId'
  };

  export type WheelSpokeScalarFieldEnum = (typeof WheelSpokeScalarFieldEnum)[keyof typeof WheelSpokeScalarFieldEnum]


  export const WheelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    notes: 'notes',
    hubId: 'hubId',
    rimId: 'rimId'
  };

  export type WheelScalarFieldEnum = (typeof WheelScalarFieldEnum)[keyof typeof WheelScalarFieldEnum]


  export const BuildPartScalarFieldEnum: {
    id: 'id',
    buildId: 'buildId',
    partId: 'partId'
  };

  export type BuildPartScalarFieldEnum = (typeof BuildPartScalarFieldEnum)[keyof typeof BuildPartScalarFieldEnum]


  export const BuildScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    notes: 'notes'
  };

  export type BuildScalarFieldEnum = (typeof BuildScalarFieldEnum)[keyof typeof BuildScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringNullableFilter<"User"> | string | null
    nameLast?: StringNullableFilter<"User"> | string | null
    nameFirst?: StringNullableFilter<"User"> | string | null
    providerId?: StringFilter<"User"> | string
    provider?: StringNullableFilter<"User"> | string | null
    roles?: StringNullableFilter<"User"> | string | null
    registered?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLogIn?: DateTimeNullableFilter<"User"> | Date | string | null
    claims?: ClaimListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    nameLast?: SortOrderInput | SortOrder
    nameFirst?: SortOrderInput | SortOrder
    providerId?: SortOrder
    provider?: SortOrderInput | SortOrder
    roles?: SortOrderInput | SortOrder
    registered?: SortOrderInput | SortOrder
    lastLogIn?: SortOrderInput | SortOrder
    claims?: ClaimOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    providerId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    nameLast?: StringNullableFilter<"User"> | string | null
    nameFirst?: StringNullableFilter<"User"> | string | null
    provider?: StringNullableFilter<"User"> | string | null
    roles?: StringNullableFilter<"User"> | string | null
    registered?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLogIn?: DateTimeNullableFilter<"User"> | Date | string | null
    claims?: ClaimListRelationFilter
  }, "id" | "providerId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    nameLast?: SortOrderInput | SortOrder
    nameFirst?: SortOrderInput | SortOrder
    providerId?: SortOrder
    provider?: SortOrderInput | SortOrder
    roles?: SortOrderInput | SortOrder
    registered?: SortOrderInput | SortOrder
    lastLogIn?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    nameLast?: StringNullableWithAggregatesFilter<"User"> | string | null
    nameFirst?: StringNullableWithAggregatesFilter<"User"> | string | null
    providerId?: StringWithAggregatesFilter<"User"> | string
    provider?: StringNullableWithAggregatesFilter<"User"> | string | null
    roles?: StringNullableWithAggregatesFilter<"User"> | string | null
    registered?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLogIn?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type ClaimWhereInput = {
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    id?: IntFilter<"Claim"> | number
    claimType?: StringNullableFilter<"Claim"> | string | null
    acquired?: DateTimeNullableFilter<"Claim"> | Date | string | null
    condition?: StringNullableFilter<"Claim"> | string | null
    notes?: StringNullableFilter<"Claim"> | string | null
    ownerId?: IntNullableFilter<"Claim"> | number | null
    partId?: IntNullableFilter<"Claim"> | number | null
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    part?: XOR<PartNullableRelationFilter, PartWhereInput> | null
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    claimType?: SortOrderInput | SortOrder
    acquired?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    partId?: SortOrderInput | SortOrder
    owner?: UserOrderByWithRelationInput
    part?: PartOrderByWithRelationInput
  }

  export type ClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    claimType?: StringNullableFilter<"Claim"> | string | null
    acquired?: DateTimeNullableFilter<"Claim"> | Date | string | null
    condition?: StringNullableFilter<"Claim"> | string | null
    notes?: StringNullableFilter<"Claim"> | string | null
    ownerId?: IntNullableFilter<"Claim"> | number | null
    partId?: IntNullableFilter<"Claim"> | number | null
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    part?: XOR<PartNullableRelationFilter, PartWhereInput> | null
  }, "id">

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    claimType?: SortOrderInput | SortOrder
    acquired?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    partId?: SortOrderInput | SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _avg?: ClaimAvgOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
    _sum?: ClaimSumOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    OR?: ClaimScalarWhereWithAggregatesInput[]
    NOT?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Claim"> | number
    claimType?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    acquired?: DateTimeNullableWithAggregatesFilter<"Claim"> | Date | string | null
    condition?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    ownerId?: IntNullableWithAggregatesFilter<"Claim"> | number | null
    partId?: IntNullableWithAggregatesFilter<"Claim"> | number | null
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: IntFilter<"Brand"> | number
    name?: StringNullableFilter<"Brand"> | string | null
    nameShort?: StringNullableFilter<"Brand"> | string | null
    nameAbbreviation?: StringNullableFilter<"Brand"> | string | null
    notes?: StringNullableFilter<"Brand"> | string | null
    webAddress?: StringNullableFilter<"Brand"> | string | null
    labelMemberships?: BrandMemberListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    nameShort?: SortOrderInput | SortOrder
    nameAbbreviation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    webAddress?: SortOrderInput | SortOrder
    labelMemberships?: BrandMemberOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    name?: StringNullableFilter<"Brand"> | string | null
    nameShort?: StringNullableFilter<"Brand"> | string | null
    nameAbbreviation?: StringNullableFilter<"Brand"> | string | null
    notes?: StringNullableFilter<"Brand"> | string | null
    webAddress?: StringNullableFilter<"Brand"> | string | null
    labelMemberships?: BrandMemberListRelationFilter
  }, "id">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    nameShort?: SortOrderInput | SortOrder
    nameAbbreviation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    webAddress?: SortOrderInput | SortOrder
    _count?: BrandCountOrderByAggregateInput
    _avg?: BrandAvgOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
    _sum?: BrandSumOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Brand"> | number
    name?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    nameShort?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    nameAbbreviation?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    webAddress?: StringNullableWithAggregatesFilter<"Brand"> | string | null
  }

  export type BrandMemberWhereInput = {
    AND?: BrandMemberWhereInput | BrandMemberWhereInput[]
    OR?: BrandMemberWhereInput[]
    NOT?: BrandMemberWhereInput | BrandMemberWhereInput[]
    id?: IntFilter<"BrandMember"> | number
    productLineId?: IntNullableFilter<"BrandMember"> | number | null
    brandId?: IntNullableFilter<"BrandMember"> | number | null
    productLine?: XOR<ProductLineNullableRelationFilter, ProductLineWhereInput> | null
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
  }

  export type BrandMemberOrderByWithRelationInput = {
    id?: SortOrder
    productLineId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    productLine?: ProductLineOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
  }

  export type BrandMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BrandMemberWhereInput | BrandMemberWhereInput[]
    OR?: BrandMemberWhereInput[]
    NOT?: BrandMemberWhereInput | BrandMemberWhereInput[]
    productLineId?: IntNullableFilter<"BrandMember"> | number | null
    brandId?: IntNullableFilter<"BrandMember"> | number | null
    productLine?: XOR<ProductLineNullableRelationFilter, ProductLineWhereInput> | null
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
  }, "id">

  export type BrandMemberOrderByWithAggregationInput = {
    id?: SortOrder
    productLineId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    _count?: BrandMemberCountOrderByAggregateInput
    _avg?: BrandMemberAvgOrderByAggregateInput
    _max?: BrandMemberMaxOrderByAggregateInput
    _min?: BrandMemberMinOrderByAggregateInput
    _sum?: BrandMemberSumOrderByAggregateInput
  }

  export type BrandMemberScalarWhereWithAggregatesInput = {
    AND?: BrandMemberScalarWhereWithAggregatesInput | BrandMemberScalarWhereWithAggregatesInput[]
    OR?: BrandMemberScalarWhereWithAggregatesInput[]
    NOT?: BrandMemberScalarWhereWithAggregatesInput | BrandMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BrandMember"> | number
    productLineId?: IntNullableWithAggregatesFilter<"BrandMember"> | number | null
    brandId?: IntNullableWithAggregatesFilter<"BrandMember"> | number | null
  }

  export type ProductLineWhereInput = {
    AND?: ProductLineWhereInput | ProductLineWhereInput[]
    OR?: ProductLineWhereInput[]
    NOT?: ProductLineWhereInput | ProductLineWhereInput[]
    id?: IntFilter<"ProductLine"> | number
    type?: StringNullableFilter<"ProductLine"> | string | null
    name?: StringNullableFilter<"ProductLine"> | string | null
    nameShort?: StringNullableFilter<"ProductLine"> | string | null
    nameAbbreviation?: StringNullableFilter<"ProductLine"> | string | null
    notes?: StringNullableFilter<"ProductLine"> | string | null
    webAddress?: StringNullableFilter<"ProductLine"> | string | null
    labelMemberships?: BrandMemberListRelationFilter
    items?: PartListRelationFilter
  }

  export type ProductLineOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    nameShort?: SortOrderInput | SortOrder
    nameAbbreviation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    webAddress?: SortOrderInput | SortOrder
    labelMemberships?: BrandMemberOrderByRelationAggregateInput
    items?: PartOrderByRelationAggregateInput
  }

  export type ProductLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductLineWhereInput | ProductLineWhereInput[]
    OR?: ProductLineWhereInput[]
    NOT?: ProductLineWhereInput | ProductLineWhereInput[]
    type?: StringNullableFilter<"ProductLine"> | string | null
    name?: StringNullableFilter<"ProductLine"> | string | null
    nameShort?: StringNullableFilter<"ProductLine"> | string | null
    nameAbbreviation?: StringNullableFilter<"ProductLine"> | string | null
    notes?: StringNullableFilter<"ProductLine"> | string | null
    webAddress?: StringNullableFilter<"ProductLine"> | string | null
    labelMemberships?: BrandMemberListRelationFilter
    items?: PartListRelationFilter
  }, "id">

  export type ProductLineOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    nameShort?: SortOrderInput | SortOrder
    nameAbbreviation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    webAddress?: SortOrderInput | SortOrder
    _count?: ProductLineCountOrderByAggregateInput
    _avg?: ProductLineAvgOrderByAggregateInput
    _max?: ProductLineMaxOrderByAggregateInput
    _min?: ProductLineMinOrderByAggregateInput
    _sum?: ProductLineSumOrderByAggregateInput
  }

  export type ProductLineScalarWhereWithAggregatesInput = {
    AND?: ProductLineScalarWhereWithAggregatesInput | ProductLineScalarWhereWithAggregatesInput[]
    OR?: ProductLineScalarWhereWithAggregatesInput[]
    NOT?: ProductLineScalarWhereWithAggregatesInput | ProductLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductLine"> | number
    type?: StringNullableWithAggregatesFilter<"ProductLine"> | string | null
    name?: StringNullableWithAggregatesFilter<"ProductLine"> | string | null
    nameShort?: StringNullableWithAggregatesFilter<"ProductLine"> | string | null
    nameAbbreviation?: StringNullableWithAggregatesFilter<"ProductLine"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ProductLine"> | string | null
    webAddress?: StringNullableWithAggregatesFilter<"ProductLine"> | string | null
  }

  export type PropertyGroupWhereInput = {
    AND?: PropertyGroupWhereInput | PropertyGroupWhereInput[]
    OR?: PropertyGroupWhereInput[]
    NOT?: PropertyGroupWhereInput | PropertyGroupWhereInput[]
    id?: IntFilter<"PropertyGroup"> | number
    order?: IntNullableFilter<"PropertyGroup"> | number | null
    name?: StringFilter<"PropertyGroup"> | string
    description?: StringNullableFilter<"PropertyGroup"> | string | null
    propertyTypes?: PropertyGroupMembershipListRelationFilter
  }

  export type PropertyGroupOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    propertyTypes?: PropertyGroupMembershipOrderByRelationAggregateInput
  }

  export type PropertyGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PropertyGroupWhereInput | PropertyGroupWhereInput[]
    OR?: PropertyGroupWhereInput[]
    NOT?: PropertyGroupWhereInput | PropertyGroupWhereInput[]
    order?: IntNullableFilter<"PropertyGroup"> | number | null
    description?: StringNullableFilter<"PropertyGroup"> | string | null
    propertyTypes?: PropertyGroupMembershipListRelationFilter
  }, "id" | "name">

  export type PropertyGroupOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PropertyGroupCountOrderByAggregateInput
    _avg?: PropertyGroupAvgOrderByAggregateInput
    _max?: PropertyGroupMaxOrderByAggregateInput
    _min?: PropertyGroupMinOrderByAggregateInput
    _sum?: PropertyGroupSumOrderByAggregateInput
  }

  export type PropertyGroupScalarWhereWithAggregatesInput = {
    AND?: PropertyGroupScalarWhereWithAggregatesInput | PropertyGroupScalarWhereWithAggregatesInput[]
    OR?: PropertyGroupScalarWhereWithAggregatesInput[]
    NOT?: PropertyGroupScalarWhereWithAggregatesInput | PropertyGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PropertyGroup"> | number
    order?: IntNullableWithAggregatesFilter<"PropertyGroup"> | number | null
    name?: StringWithAggregatesFilter<"PropertyGroup"> | string
    description?: StringNullableWithAggregatesFilter<"PropertyGroup"> | string | null
  }

  export type PropertyGroupMembershipWhereInput = {
    AND?: PropertyGroupMembershipWhereInput | PropertyGroupMembershipWhereInput[]
    OR?: PropertyGroupMembershipWhereInput[]
    NOT?: PropertyGroupMembershipWhereInput | PropertyGroupMembershipWhereInput[]
    id?: IntFilter<"PropertyGroupMembership"> | number
    partTypeId?: IntNullableFilter<"PropertyGroupMembership"> | number | null
    propertyTypeId?: IntNullableFilter<"PropertyGroupMembership"> | number | null
    groupId?: IntNullableFilter<"PropertyGroupMembership"> | number | null
    partType?: XOR<PartTypeNullableRelationFilter, PartTypeWhereInput> | null
    propertyType?: XOR<PropertyTypeNullableRelationFilter, PropertyTypeWhereInput> | null
    group?: XOR<PropertyGroupNullableRelationFilter, PropertyGroupWhereInput> | null
  }

  export type PropertyGroupMembershipOrderByWithRelationInput = {
    id?: SortOrder
    partTypeId?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    partType?: PartTypeOrderByWithRelationInput
    propertyType?: PropertyTypeOrderByWithRelationInput
    group?: PropertyGroupOrderByWithRelationInput
  }

  export type PropertyGroupMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PropertyGroupMembershipWhereInput | PropertyGroupMembershipWhereInput[]
    OR?: PropertyGroupMembershipWhereInput[]
    NOT?: PropertyGroupMembershipWhereInput | PropertyGroupMembershipWhereInput[]
    partTypeId?: IntNullableFilter<"PropertyGroupMembership"> | number | null
    propertyTypeId?: IntNullableFilter<"PropertyGroupMembership"> | number | null
    groupId?: IntNullableFilter<"PropertyGroupMembership"> | number | null
    partType?: XOR<PartTypeNullableRelationFilter, PartTypeWhereInput> | null
    propertyType?: XOR<PropertyTypeNullableRelationFilter, PropertyTypeWhereInput> | null
    group?: XOR<PropertyGroupNullableRelationFilter, PropertyGroupWhereInput> | null
  }, "id">

  export type PropertyGroupMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    partTypeId?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    _count?: PropertyGroupMembershipCountOrderByAggregateInput
    _avg?: PropertyGroupMembershipAvgOrderByAggregateInput
    _max?: PropertyGroupMembershipMaxOrderByAggregateInput
    _min?: PropertyGroupMembershipMinOrderByAggregateInput
    _sum?: PropertyGroupMembershipSumOrderByAggregateInput
  }

  export type PropertyGroupMembershipScalarWhereWithAggregatesInput = {
    AND?: PropertyGroupMembershipScalarWhereWithAggregatesInput | PropertyGroupMembershipScalarWhereWithAggregatesInput[]
    OR?: PropertyGroupMembershipScalarWhereWithAggregatesInput[]
    NOT?: PropertyGroupMembershipScalarWhereWithAggregatesInput | PropertyGroupMembershipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PropertyGroupMembership"> | number
    partTypeId?: IntNullableWithAggregatesFilter<"PropertyGroupMembership"> | number | null
    propertyTypeId?: IntNullableWithAggregatesFilter<"PropertyGroupMembership"> | number | null
    groupId?: IntNullableWithAggregatesFilter<"PropertyGroupMembership"> | number | null
  }

  export type PropertyTypeWhereInput = {
    AND?: PropertyTypeWhereInput | PropertyTypeWhereInput[]
    OR?: PropertyTypeWhereInput[]
    NOT?: PropertyTypeWhereInput | PropertyTypeWhereInput[]
    id?: IntFilter<"PropertyType"> | number
    order?: IntNullableFilter<"PropertyType"> | number | null
    name?: StringNullableFilter<"PropertyType"> | string | null
    description?: StringNullableFilter<"PropertyType"> | string | null
    valueDataType?: StringNullableFilter<"PropertyType"> | string | null
    valueDataTypeModifier?: StringNullableFilter<"PropertyType"> | string | null
    variation?: StringNullableFilter<"PropertyType"> | string | null
    groups?: PropertyGroupMembershipListRelationFilter
    properties?: PropertyListRelationFilter
    lookupValues?: PropertyLookupListRelationFilter
  }

  export type PropertyTypeOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    valueDataType?: SortOrderInput | SortOrder
    valueDataTypeModifier?: SortOrderInput | SortOrder
    variation?: SortOrderInput | SortOrder
    groups?: PropertyGroupMembershipOrderByRelationAggregateInput
    properties?: PropertyOrderByRelationAggregateInput
    lookupValues?: PropertyLookupOrderByRelationAggregateInput
  }

  export type PropertyTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PropertyTypeWhereInput | PropertyTypeWhereInput[]
    OR?: PropertyTypeWhereInput[]
    NOT?: PropertyTypeWhereInput | PropertyTypeWhereInput[]
    order?: IntNullableFilter<"PropertyType"> | number | null
    name?: StringNullableFilter<"PropertyType"> | string | null
    description?: StringNullableFilter<"PropertyType"> | string | null
    valueDataType?: StringNullableFilter<"PropertyType"> | string | null
    valueDataTypeModifier?: StringNullableFilter<"PropertyType"> | string | null
    variation?: StringNullableFilter<"PropertyType"> | string | null
    groups?: PropertyGroupMembershipListRelationFilter
    properties?: PropertyListRelationFilter
    lookupValues?: PropertyLookupListRelationFilter
  }, "id">

  export type PropertyTypeOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    valueDataType?: SortOrderInput | SortOrder
    valueDataTypeModifier?: SortOrderInput | SortOrder
    variation?: SortOrderInput | SortOrder
    _count?: PropertyTypeCountOrderByAggregateInput
    _avg?: PropertyTypeAvgOrderByAggregateInput
    _max?: PropertyTypeMaxOrderByAggregateInput
    _min?: PropertyTypeMinOrderByAggregateInput
    _sum?: PropertyTypeSumOrderByAggregateInput
  }

  export type PropertyTypeScalarWhereWithAggregatesInput = {
    AND?: PropertyTypeScalarWhereWithAggregatesInput | PropertyTypeScalarWhereWithAggregatesInput[]
    OR?: PropertyTypeScalarWhereWithAggregatesInput[]
    NOT?: PropertyTypeScalarWhereWithAggregatesInput | PropertyTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PropertyType"> | number
    order?: IntNullableWithAggregatesFilter<"PropertyType"> | number | null
    name?: StringNullableWithAggregatesFilter<"PropertyType"> | string | null
    description?: StringNullableWithAggregatesFilter<"PropertyType"> | string | null
    valueDataType?: StringNullableWithAggregatesFilter<"PropertyType"> | string | null
    valueDataTypeModifier?: StringNullableWithAggregatesFilter<"PropertyType"> | string | null
    variation?: StringNullableWithAggregatesFilter<"PropertyType"> | string | null
  }

  export type PropertyLookupWhereInput = {
    AND?: PropertyLookupWhereInput | PropertyLookupWhereInput[]
    OR?: PropertyLookupWhereInput[]
    NOT?: PropertyLookupWhereInput | PropertyLookupWhereInput[]
    id?: IntFilter<"PropertyLookup"> | number
    value?: StringNullableFilter<"PropertyLookup"> | string | null
    propertyTypeId?: IntNullableFilter<"PropertyLookup"> | number | null
    propertyType?: XOR<PropertyTypeNullableRelationFilter, PropertyTypeWhereInput> | null
  }

  export type PropertyLookupOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    propertyType?: PropertyTypeOrderByWithRelationInput
  }

  export type PropertyLookupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PropertyLookupWhereInput | PropertyLookupWhereInput[]
    OR?: PropertyLookupWhereInput[]
    NOT?: PropertyLookupWhereInput | PropertyLookupWhereInput[]
    value?: StringNullableFilter<"PropertyLookup"> | string | null
    propertyTypeId?: IntNullableFilter<"PropertyLookup"> | number | null
    propertyType?: XOR<PropertyTypeNullableRelationFilter, PropertyTypeWhereInput> | null
  }, "id">

  export type PropertyLookupOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    _count?: PropertyLookupCountOrderByAggregateInput
    _avg?: PropertyLookupAvgOrderByAggregateInput
    _max?: PropertyLookupMaxOrderByAggregateInput
    _min?: PropertyLookupMinOrderByAggregateInput
    _sum?: PropertyLookupSumOrderByAggregateInput
  }

  export type PropertyLookupScalarWhereWithAggregatesInput = {
    AND?: PropertyLookupScalarWhereWithAggregatesInput | PropertyLookupScalarWhereWithAggregatesInput[]
    OR?: PropertyLookupScalarWhereWithAggregatesInput[]
    NOT?: PropertyLookupScalarWhereWithAggregatesInput | PropertyLookupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PropertyLookup"> | number
    value?: StringNullableWithAggregatesFilter<"PropertyLookup"> | string | null
    propertyTypeId?: IntNullableWithAggregatesFilter<"PropertyLookup"> | number | null
  }

  export type PartClassWhereInput = {
    AND?: PartClassWhereInput | PartClassWhereInput[]
    OR?: PartClassWhereInput[]
    NOT?: PartClassWhereInput | PartClassWhereInput[]
    id?: IntFilter<"PartClass"> | number
    order?: IntNullableFilter<"PartClass"> | number | null
    name?: StringFilter<"PartClass"> | string
    partTypes?: PartClassMembershipListRelationFilter
  }

  export type PartClassOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrderInput | SortOrder
    name?: SortOrder
    partTypes?: PartClassMembershipOrderByRelationAggregateInput
  }

  export type PartClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PartClassWhereInput | PartClassWhereInput[]
    OR?: PartClassWhereInput[]
    NOT?: PartClassWhereInput | PartClassWhereInput[]
    order?: IntNullableFilter<"PartClass"> | number | null
    partTypes?: PartClassMembershipListRelationFilter
  }, "id" | "name">

  export type PartClassOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrderInput | SortOrder
    name?: SortOrder
    _count?: PartClassCountOrderByAggregateInput
    _avg?: PartClassAvgOrderByAggregateInput
    _max?: PartClassMaxOrderByAggregateInput
    _min?: PartClassMinOrderByAggregateInput
    _sum?: PartClassSumOrderByAggregateInput
  }

  export type PartClassScalarWhereWithAggregatesInput = {
    AND?: PartClassScalarWhereWithAggregatesInput | PartClassScalarWhereWithAggregatesInput[]
    OR?: PartClassScalarWhereWithAggregatesInput[]
    NOT?: PartClassScalarWhereWithAggregatesInput | PartClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PartClass"> | number
    order?: IntNullableWithAggregatesFilter<"PartClass"> | number | null
    name?: StringWithAggregatesFilter<"PartClass"> | string
  }

  export type PartClassMembershipWhereInput = {
    AND?: PartClassMembershipWhereInput | PartClassMembershipWhereInput[]
    OR?: PartClassMembershipWhereInput[]
    NOT?: PartClassMembershipWhereInput | PartClassMembershipWhereInput[]
    id?: IntFilter<"PartClassMembership"> | number
    partClassId?: IntNullableFilter<"PartClassMembership"> | number | null
    partTypeId?: IntNullableFilter<"PartClassMembership"> | number | null
    partClass?: XOR<PartClassNullableRelationFilter, PartClassWhereInput> | null
    partType?: XOR<PartTypeNullableRelationFilter, PartTypeWhereInput> | null
  }

  export type PartClassMembershipOrderByWithRelationInput = {
    id?: SortOrder
    partClassId?: SortOrderInput | SortOrder
    partTypeId?: SortOrderInput | SortOrder
    partClass?: PartClassOrderByWithRelationInput
    partType?: PartTypeOrderByWithRelationInput
  }

  export type PartClassMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PartClassMembershipWhereInput | PartClassMembershipWhereInput[]
    OR?: PartClassMembershipWhereInput[]
    NOT?: PartClassMembershipWhereInput | PartClassMembershipWhereInput[]
    partClassId?: IntNullableFilter<"PartClassMembership"> | number | null
    partTypeId?: IntNullableFilter<"PartClassMembership"> | number | null
    partClass?: XOR<PartClassNullableRelationFilter, PartClassWhereInput> | null
    partType?: XOR<PartTypeNullableRelationFilter, PartTypeWhereInput> | null
  }, "id">

  export type PartClassMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    partClassId?: SortOrderInput | SortOrder
    partTypeId?: SortOrderInput | SortOrder
    _count?: PartClassMembershipCountOrderByAggregateInput
    _avg?: PartClassMembershipAvgOrderByAggregateInput
    _max?: PartClassMembershipMaxOrderByAggregateInput
    _min?: PartClassMembershipMinOrderByAggregateInput
    _sum?: PartClassMembershipSumOrderByAggregateInput
  }

  export type PartClassMembershipScalarWhereWithAggregatesInput = {
    AND?: PartClassMembershipScalarWhereWithAggregatesInput | PartClassMembershipScalarWhereWithAggregatesInput[]
    OR?: PartClassMembershipScalarWhereWithAggregatesInput[]
    NOT?: PartClassMembershipScalarWhereWithAggregatesInput | PartClassMembershipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PartClassMembership"> | number
    partClassId?: IntNullableWithAggregatesFilter<"PartClassMembership"> | number | null
    partTypeId?: IntNullableWithAggregatesFilter<"PartClassMembership"> | number | null
  }

  export type PartTypeWhereInput = {
    AND?: PartTypeWhereInput | PartTypeWhereInput[]
    OR?: PartTypeWhereInput[]
    NOT?: PartTypeWhereInput | PartTypeWhereInput[]
    id?: IntFilter<"PartType"> | number
    order?: IntNullableFilter<"PartType"> | number | null
    name?: StringFilter<"PartType"> | string
    description?: StringNullableFilter<"PartType"> | string | null
    propertyTypes?: PropertyGroupMembershipListRelationFilter
    classes?: PartClassMembershipListRelationFilter
  }

  export type PartTypeOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    propertyTypes?: PropertyGroupMembershipOrderByRelationAggregateInput
    classes?: PartClassMembershipOrderByRelationAggregateInput
  }

  export type PartTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PartTypeWhereInput | PartTypeWhereInput[]
    OR?: PartTypeWhereInput[]
    NOT?: PartTypeWhereInput | PartTypeWhereInput[]
    order?: IntNullableFilter<"PartType"> | number | null
    description?: StringNullableFilter<"PartType"> | string | null
    propertyTypes?: PropertyGroupMembershipListRelationFilter
    classes?: PartClassMembershipListRelationFilter
  }, "id" | "name">

  export type PartTypeOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PartTypeCountOrderByAggregateInput
    _avg?: PartTypeAvgOrderByAggregateInput
    _max?: PartTypeMaxOrderByAggregateInput
    _min?: PartTypeMinOrderByAggregateInput
    _sum?: PartTypeSumOrderByAggregateInput
  }

  export type PartTypeScalarWhereWithAggregatesInput = {
    AND?: PartTypeScalarWhereWithAggregatesInput | PartTypeScalarWhereWithAggregatesInput[]
    OR?: PartTypeScalarWhereWithAggregatesInput[]
    NOT?: PartTypeScalarWhereWithAggregatesInput | PartTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PartType"> | number
    order?: IntNullableWithAggregatesFilter<"PartType"> | number | null
    name?: StringWithAggregatesFilter<"PartType"> | string
    description?: StringNullableWithAggregatesFilter<"PartType"> | string | null
  }

  export type PartGroupWhereInput = {
    AND?: PartGroupWhereInput | PartGroupWhereInput[]
    OR?: PartGroupWhereInput[]
    NOT?: PartGroupWhereInput | PartGroupWhereInput[]
    id?: IntFilter<"PartGroup"> | number
    name?: StringNullableFilter<"PartGroup"> | string | null
    parts?: PartGroupMembershipListRelationFilter
  }

  export type PartGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    parts?: PartGroupMembershipOrderByRelationAggregateInput
  }

  export type PartGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PartGroupWhereInput | PartGroupWhereInput[]
    OR?: PartGroupWhereInput[]
    NOT?: PartGroupWhereInput | PartGroupWhereInput[]
    name?: StringNullableFilter<"PartGroup"> | string | null
    parts?: PartGroupMembershipListRelationFilter
  }, "id">

  export type PartGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    _count?: PartGroupCountOrderByAggregateInput
    _avg?: PartGroupAvgOrderByAggregateInput
    _max?: PartGroupMaxOrderByAggregateInput
    _min?: PartGroupMinOrderByAggregateInput
    _sum?: PartGroupSumOrderByAggregateInput
  }

  export type PartGroupScalarWhereWithAggregatesInput = {
    AND?: PartGroupScalarWhereWithAggregatesInput | PartGroupScalarWhereWithAggregatesInput[]
    OR?: PartGroupScalarWhereWithAggregatesInput[]
    NOT?: PartGroupScalarWhereWithAggregatesInput | PartGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PartGroup"> | number
    name?: StringNullableWithAggregatesFilter<"PartGroup"> | string | null
  }

  export type PartGroupMembershipWhereInput = {
    AND?: PartGroupMembershipWhereInput | PartGroupMembershipWhereInput[]
    OR?: PartGroupMembershipWhereInput[]
    NOT?: PartGroupMembershipWhereInput | PartGroupMembershipWhereInput[]
    id?: IntFilter<"PartGroupMembership"> | number
    partId?: IntNullableFilter<"PartGroupMembership"> | number | null
    groupId?: IntNullableFilter<"PartGroupMembership"> | number | null
    part?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    group?: XOR<PartGroupNullableRelationFilter, PartGroupWhereInput> | null
  }

  export type PartGroupMembershipOrderByWithRelationInput = {
    id?: SortOrder
    partId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    part?: PartOrderByWithRelationInput
    group?: PartGroupOrderByWithRelationInput
  }

  export type PartGroupMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PartGroupMembershipWhereInput | PartGroupMembershipWhereInput[]
    OR?: PartGroupMembershipWhereInput[]
    NOT?: PartGroupMembershipWhereInput | PartGroupMembershipWhereInput[]
    partId?: IntNullableFilter<"PartGroupMembership"> | number | null
    groupId?: IntNullableFilter<"PartGroupMembership"> | number | null
    part?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    group?: XOR<PartGroupNullableRelationFilter, PartGroupWhereInput> | null
  }, "id">

  export type PartGroupMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    partId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    _count?: PartGroupMembershipCountOrderByAggregateInput
    _avg?: PartGroupMembershipAvgOrderByAggregateInput
    _max?: PartGroupMembershipMaxOrderByAggregateInput
    _min?: PartGroupMembershipMinOrderByAggregateInput
    _sum?: PartGroupMembershipSumOrderByAggregateInput
  }

  export type PartGroupMembershipScalarWhereWithAggregatesInput = {
    AND?: PartGroupMembershipScalarWhereWithAggregatesInput | PartGroupMembershipScalarWhereWithAggregatesInput[]
    OR?: PartGroupMembershipScalarWhereWithAggregatesInput[]
    NOT?: PartGroupMembershipScalarWhereWithAggregatesInput | PartGroupMembershipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PartGroupMembership"> | number
    partId?: IntNullableWithAggregatesFilter<"PartGroupMembership"> | number | null
    groupId?: IntNullableWithAggregatesFilter<"PartGroupMembership"> | number | null
  }

  export type PartWhereInput = {
    AND?: PartWhereInput | PartWhereInput[]
    OR?: PartWhereInput[]
    NOT?: PartWhereInput | PartWhereInput[]
    id?: IntFilter<"Part"> | number
    type?: StringNullableFilter<"Part"> | string | null
    name?: StringNullableFilter<"Part"> | string | null
    notes?: StringNullableFilter<"Part"> | string | null
    weight?: DecimalNullableFilter<"Part"> | Decimal | DecimalJsLike | number | string | null
    weightUnit?: StringNullableFilter<"Part"> | string | null
    productLineId?: IntNullableFilter<"Part"> | number | null
    productLine?: XOR<ProductLineNullableRelationFilter, ProductLineWhereInput> | null
    wheelHubs?: WheelListRelationFilter
    wheelRims?: WheelListRelationFilter
    wheelSpokes?: WheelSpokeListRelationFilter
    properties?: PropertyListRelationFilter
    claims?: ClaimListRelationFilter
    groups?: PartGroupMembershipListRelationFilter
    builds?: BuildPartListRelationFilter
  }

  export type PartOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrderInput | SortOrder
    productLineId?: SortOrderInput | SortOrder
    productLine?: ProductLineOrderByWithRelationInput
    wheelHubs?: WheelOrderByRelationAggregateInput
    wheelRims?: WheelOrderByRelationAggregateInput
    wheelSpokes?: WheelSpokeOrderByRelationAggregateInput
    properties?: PropertyOrderByRelationAggregateInput
    claims?: ClaimOrderByRelationAggregateInput
    groups?: PartGroupMembershipOrderByRelationAggregateInput
    builds?: BuildPartOrderByRelationAggregateInput
  }

  export type PartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PartWhereInput | PartWhereInput[]
    OR?: PartWhereInput[]
    NOT?: PartWhereInput | PartWhereInput[]
    type?: StringNullableFilter<"Part"> | string | null
    name?: StringNullableFilter<"Part"> | string | null
    notes?: StringNullableFilter<"Part"> | string | null
    weight?: DecimalNullableFilter<"Part"> | Decimal | DecimalJsLike | number | string | null
    weightUnit?: StringNullableFilter<"Part"> | string | null
    productLineId?: IntNullableFilter<"Part"> | number | null
    productLine?: XOR<ProductLineNullableRelationFilter, ProductLineWhereInput> | null
    wheelHubs?: WheelListRelationFilter
    wheelRims?: WheelListRelationFilter
    wheelSpokes?: WheelSpokeListRelationFilter
    properties?: PropertyListRelationFilter
    claims?: ClaimListRelationFilter
    groups?: PartGroupMembershipListRelationFilter
    builds?: BuildPartListRelationFilter
  }, "id">

  export type PartOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrderInput | SortOrder
    productLineId?: SortOrderInput | SortOrder
    _count?: PartCountOrderByAggregateInput
    _avg?: PartAvgOrderByAggregateInput
    _max?: PartMaxOrderByAggregateInput
    _min?: PartMinOrderByAggregateInput
    _sum?: PartSumOrderByAggregateInput
  }

  export type PartScalarWhereWithAggregatesInput = {
    AND?: PartScalarWhereWithAggregatesInput | PartScalarWhereWithAggregatesInput[]
    OR?: PartScalarWhereWithAggregatesInput[]
    NOT?: PartScalarWhereWithAggregatesInput | PartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Part"> | number
    type?: StringNullableWithAggregatesFilter<"Part"> | string | null
    name?: StringNullableWithAggregatesFilter<"Part"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Part"> | string | null
    weight?: DecimalNullableWithAggregatesFilter<"Part"> | Decimal | DecimalJsLike | number | string | null
    weightUnit?: StringNullableWithAggregatesFilter<"Part"> | string | null
    productLineId?: IntNullableWithAggregatesFilter<"Part"> | number | null
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: IntFilter<"Property"> | number
    itemId?: IntNullableFilter<"Property"> | number | null
    value?: StringNullableFilter<"Property"> | string | null
    valueDataMethod?: StringNullableFilter<"Property"> | string | null
    propertyTypeId?: IntNullableFilter<"Property"> | number | null
    part?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    propertyType?: XOR<PropertyTypeNullableRelationFilter, PropertyTypeWhereInput> | null
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    valueDataMethod?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    part?: PartOrderByWithRelationInput
    propertyType?: PropertyTypeOrderByWithRelationInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    itemId?: number
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    value?: StringNullableFilter<"Property"> | string | null
    valueDataMethod?: StringNullableFilter<"Property"> | string | null
    propertyTypeId?: IntNullableFilter<"Property"> | number | null
    part?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    propertyType?: XOR<PropertyTypeNullableRelationFilter, PropertyTypeWhereInput> | null
  }, "id" | "itemId">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    valueDataMethod?: SortOrderInput | SortOrder
    propertyTypeId?: SortOrderInput | SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Property"> | number
    itemId?: IntNullableWithAggregatesFilter<"Property"> | number | null
    value?: StringNullableWithAggregatesFilter<"Property"> | string | null
    valueDataMethod?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyTypeId?: IntNullableWithAggregatesFilter<"Property"> | number | null
  }

  export type WheelSpokeWhereInput = {
    AND?: WheelSpokeWhereInput | WheelSpokeWhereInput[]
    OR?: WheelSpokeWhereInput[]
    NOT?: WheelSpokeWhereInput | WheelSpokeWhereInput[]
    id?: IntFilter<"WheelSpoke"> | number
    quantity?: IntNullableFilter<"WheelSpoke"> | number | null
    length?: DecimalNullableFilter<"WheelSpoke"> | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: DecimalNullableFilter<"WheelSpoke"> | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: StringNullableFilter<"WheelSpoke"> | string | null
    preparation?: StringNullableFilter<"WheelSpoke"> | string | null
    notes?: StringNullableFilter<"WheelSpoke"> | string | null
    spokeId?: IntNullableFilter<"WheelSpoke"> | number | null
    wheelId?: IntNullableFilter<"WheelSpoke"> | number | null
    spoke?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    wheel?: XOR<WheelNullableRelationFilter, WheelWhereInput> | null
  }

  export type WheelSpokeOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    tensionApplied?: SortOrderInput | SortOrder
    tensionUnit?: SortOrderInput | SortOrder
    preparation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    spokeId?: SortOrderInput | SortOrder
    wheelId?: SortOrderInput | SortOrder
    spoke?: PartOrderByWithRelationInput
    wheel?: WheelOrderByWithRelationInput
  }

  export type WheelSpokeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WheelSpokeWhereInput | WheelSpokeWhereInput[]
    OR?: WheelSpokeWhereInput[]
    NOT?: WheelSpokeWhereInput | WheelSpokeWhereInput[]
    quantity?: IntNullableFilter<"WheelSpoke"> | number | null
    length?: DecimalNullableFilter<"WheelSpoke"> | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: DecimalNullableFilter<"WheelSpoke"> | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: StringNullableFilter<"WheelSpoke"> | string | null
    preparation?: StringNullableFilter<"WheelSpoke"> | string | null
    notes?: StringNullableFilter<"WheelSpoke"> | string | null
    spokeId?: IntNullableFilter<"WheelSpoke"> | number | null
    wheelId?: IntNullableFilter<"WheelSpoke"> | number | null
    spoke?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    wheel?: XOR<WheelNullableRelationFilter, WheelWhereInput> | null
  }, "id">

  export type WheelSpokeOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrderInput | SortOrder
    length?: SortOrderInput | SortOrder
    tensionApplied?: SortOrderInput | SortOrder
    tensionUnit?: SortOrderInput | SortOrder
    preparation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    spokeId?: SortOrderInput | SortOrder
    wheelId?: SortOrderInput | SortOrder
    _count?: WheelSpokeCountOrderByAggregateInput
    _avg?: WheelSpokeAvgOrderByAggregateInput
    _max?: WheelSpokeMaxOrderByAggregateInput
    _min?: WheelSpokeMinOrderByAggregateInput
    _sum?: WheelSpokeSumOrderByAggregateInput
  }

  export type WheelSpokeScalarWhereWithAggregatesInput = {
    AND?: WheelSpokeScalarWhereWithAggregatesInput | WheelSpokeScalarWhereWithAggregatesInput[]
    OR?: WheelSpokeScalarWhereWithAggregatesInput[]
    NOT?: WheelSpokeScalarWhereWithAggregatesInput | WheelSpokeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WheelSpoke"> | number
    quantity?: IntNullableWithAggregatesFilter<"WheelSpoke"> | number | null
    length?: DecimalNullableWithAggregatesFilter<"WheelSpoke"> | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: DecimalNullableWithAggregatesFilter<"WheelSpoke"> | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: StringNullableWithAggregatesFilter<"WheelSpoke"> | string | null
    preparation?: StringNullableWithAggregatesFilter<"WheelSpoke"> | string | null
    notes?: StringNullableWithAggregatesFilter<"WheelSpoke"> | string | null
    spokeId?: IntNullableWithAggregatesFilter<"WheelSpoke"> | number | null
    wheelId?: IntNullableWithAggregatesFilter<"WheelSpoke"> | number | null
  }

  export type WheelWhereInput = {
    AND?: WheelWhereInput | WheelWhereInput[]
    OR?: WheelWhereInput[]
    NOT?: WheelWhereInput | WheelWhereInput[]
    id?: IntFilter<"Wheel"> | number
    name?: StringNullableFilter<"Wheel"> | string | null
    notes?: StringNullableFilter<"Wheel"> | string | null
    hubId?: IntNullableFilter<"Wheel"> | number | null
    rimId?: IntNullableFilter<"Wheel"> | number | null
    hub?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    rim?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    spokes?: WheelSpokeListRelationFilter
  }

  export type WheelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    hubId?: SortOrderInput | SortOrder
    rimId?: SortOrderInput | SortOrder
    hub?: PartOrderByWithRelationInput
    rim?: PartOrderByWithRelationInput
    spokes?: WheelSpokeOrderByRelationAggregateInput
  }

  export type WheelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WheelWhereInput | WheelWhereInput[]
    OR?: WheelWhereInput[]
    NOT?: WheelWhereInput | WheelWhereInput[]
    name?: StringNullableFilter<"Wheel"> | string | null
    notes?: StringNullableFilter<"Wheel"> | string | null
    hubId?: IntNullableFilter<"Wheel"> | number | null
    rimId?: IntNullableFilter<"Wheel"> | number | null
    hub?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    rim?: XOR<PartNullableRelationFilter, PartWhereInput> | null
    spokes?: WheelSpokeListRelationFilter
  }, "id">

  export type WheelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    hubId?: SortOrderInput | SortOrder
    rimId?: SortOrderInput | SortOrder
    _count?: WheelCountOrderByAggregateInput
    _avg?: WheelAvgOrderByAggregateInput
    _max?: WheelMaxOrderByAggregateInput
    _min?: WheelMinOrderByAggregateInput
    _sum?: WheelSumOrderByAggregateInput
  }

  export type WheelScalarWhereWithAggregatesInput = {
    AND?: WheelScalarWhereWithAggregatesInput | WheelScalarWhereWithAggregatesInput[]
    OR?: WheelScalarWhereWithAggregatesInput[]
    NOT?: WheelScalarWhereWithAggregatesInput | WheelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Wheel"> | number
    name?: StringNullableWithAggregatesFilter<"Wheel"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Wheel"> | string | null
    hubId?: IntNullableWithAggregatesFilter<"Wheel"> | number | null
    rimId?: IntNullableWithAggregatesFilter<"Wheel"> | number | null
  }

  export type BuildPartWhereInput = {
    AND?: BuildPartWhereInput | BuildPartWhereInput[]
    OR?: BuildPartWhereInput[]
    NOT?: BuildPartWhereInput | BuildPartWhereInput[]
    id?: IntFilter<"BuildPart"> | number
    buildId?: IntNullableFilter<"BuildPart"> | number | null
    partId?: IntNullableFilter<"BuildPart"> | number | null
    build?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
    part?: XOR<PartNullableRelationFilter, PartWhereInput> | null
  }

  export type BuildPartOrderByWithRelationInput = {
    id?: SortOrder
    buildId?: SortOrderInput | SortOrder
    partId?: SortOrderInput | SortOrder
    build?: BuildOrderByWithRelationInput
    part?: PartOrderByWithRelationInput
  }

  export type BuildPartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuildPartWhereInput | BuildPartWhereInput[]
    OR?: BuildPartWhereInput[]
    NOT?: BuildPartWhereInput | BuildPartWhereInput[]
    buildId?: IntNullableFilter<"BuildPart"> | number | null
    partId?: IntNullableFilter<"BuildPart"> | number | null
    build?: XOR<BuildNullableRelationFilter, BuildWhereInput> | null
    part?: XOR<PartNullableRelationFilter, PartWhereInput> | null
  }, "id">

  export type BuildPartOrderByWithAggregationInput = {
    id?: SortOrder
    buildId?: SortOrderInput | SortOrder
    partId?: SortOrderInput | SortOrder
    _count?: BuildPartCountOrderByAggregateInput
    _avg?: BuildPartAvgOrderByAggregateInput
    _max?: BuildPartMaxOrderByAggregateInput
    _min?: BuildPartMinOrderByAggregateInput
    _sum?: BuildPartSumOrderByAggregateInput
  }

  export type BuildPartScalarWhereWithAggregatesInput = {
    AND?: BuildPartScalarWhereWithAggregatesInput | BuildPartScalarWhereWithAggregatesInput[]
    OR?: BuildPartScalarWhereWithAggregatesInput[]
    NOT?: BuildPartScalarWhereWithAggregatesInput | BuildPartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuildPart"> | number
    buildId?: IntNullableWithAggregatesFilter<"BuildPart"> | number | null
    partId?: IntNullableWithAggregatesFilter<"BuildPart"> | number | null
  }

  export type BuildWhereInput = {
    AND?: BuildWhereInput | BuildWhereInput[]
    OR?: BuildWhereInput[]
    NOT?: BuildWhereInput | BuildWhereInput[]
    id?: IntFilter<"Build"> | number
    name?: StringNullableFilter<"Build"> | string | null
    status?: StringNullableFilter<"Build"> | string | null
    notes?: StringNullableFilter<"Build"> | string | null
    parts?: BuildPartListRelationFilter
  }

  export type BuildOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    parts?: BuildPartOrderByRelationAggregateInput
  }

  export type BuildWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuildWhereInput | BuildWhereInput[]
    OR?: BuildWhereInput[]
    NOT?: BuildWhereInput | BuildWhereInput[]
    name?: StringNullableFilter<"Build"> | string | null
    status?: StringNullableFilter<"Build"> | string | null
    notes?: StringNullableFilter<"Build"> | string | null
    parts?: BuildPartListRelationFilter
  }, "id">

  export type BuildOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: BuildCountOrderByAggregateInput
    _avg?: BuildAvgOrderByAggregateInput
    _max?: BuildMaxOrderByAggregateInput
    _min?: BuildMinOrderByAggregateInput
    _sum?: BuildSumOrderByAggregateInput
  }

  export type BuildScalarWhereWithAggregatesInput = {
    AND?: BuildScalarWhereWithAggregatesInput | BuildScalarWhereWithAggregatesInput[]
    OR?: BuildScalarWhereWithAggregatesInput[]
    NOT?: BuildScalarWhereWithAggregatesInput | BuildScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Build"> | number
    name?: StringNullableWithAggregatesFilter<"Build"> | string | null
    status?: StringNullableWithAggregatesFilter<"Build"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Build"> | string | null
  }

  export type UserCreateInput = {
    name?: string | null
    nameLast?: string | null
    nameFirst?: string | null
    providerId: string
    provider?: string | null
    roles?: string | null
    registered?: Date | string | null
    lastLogIn?: Date | string | null
    claims?: ClaimCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name?: string | null
    nameLast?: string | null
    nameFirst?: string | null
    providerId: string
    provider?: string | null
    roles?: string | null
    registered?: Date | string | null
    lastLogIn?: Date | string | null
    claims?: ClaimUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameLast?: NullableStringFieldUpdateOperationsInput | string | null
    nameFirst?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claims?: ClaimUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameLast?: NullableStringFieldUpdateOperationsInput | string | null
    nameFirst?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claims?: ClaimUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name?: string | null
    nameLast?: string | null
    nameFirst?: string | null
    providerId: string
    provider?: string | null
    roles?: string | null
    registered?: Date | string | null
    lastLogIn?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameLast?: NullableStringFieldUpdateOperationsInput | string | null
    nameFirst?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameLast?: NullableStringFieldUpdateOperationsInput | string | null
    nameFirst?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClaimCreateInput = {
    claimType?: string | null
    acquired?: Date | string | null
    condition?: string | null
    notes?: string | null
    owner?: UserCreateNestedOneWithoutClaimsInput
    part?: PartCreateNestedOneWithoutClaimsInput
  }

  export type ClaimUncheckedCreateInput = {
    id?: number
    claimType?: string | null
    acquired?: Date | string | null
    condition?: string | null
    notes?: string | null
    ownerId?: number | null
    partId?: number | null
  }

  export type ClaimUpdateInput = {
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneWithoutClaimsNestedInput
    part?: PartUpdateOneWithoutClaimsNestedInput
  }

  export type ClaimUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClaimCreateManyInput = {
    id?: number
    claimType?: string | null
    acquired?: Date | string | null
    condition?: string | null
    notes?: string | null
    ownerId?: number | null
    partId?: number | null
  }

  export type ClaimUpdateManyMutationInput = {
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClaimUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BrandCreateInput = {
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
    labelMemberships?: BrandMemberCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: number
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
    labelMemberships?: BrandMemberUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
    labelMemberships?: BrandMemberUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
    labelMemberships?: BrandMemberUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: number
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
  }

  export type BrandUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandMemberCreateInput = {
    productLine?: ProductLineCreateNestedOneWithoutLabelMembershipsInput
    brand?: BrandCreateNestedOneWithoutLabelMembershipsInput
  }

  export type BrandMemberUncheckedCreateInput = {
    id?: number
    productLineId?: number | null
    brandId?: number | null
  }

  export type BrandMemberUpdateInput = {
    productLine?: ProductLineUpdateOneWithoutLabelMembershipsNestedInput
    brand?: BrandUpdateOneWithoutLabelMembershipsNestedInput
  }

  export type BrandMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BrandMemberCreateManyInput = {
    id?: number
    productLineId?: number | null
    brandId?: number | null
  }

  export type BrandMemberUpdateManyMutationInput = {

  }

  export type BrandMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductLineCreateInput = {
    type?: string | null
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
    labelMemberships?: BrandMemberCreateNestedManyWithoutProductLineInput
    items?: PartCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineUncheckedCreateInput = {
    id?: number
    type?: string | null
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
    labelMemberships?: BrandMemberUncheckedCreateNestedManyWithoutProductLineInput
    items?: PartUncheckedCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
    labelMemberships?: BrandMemberUpdateManyWithoutProductLineNestedInput
    items?: PartUpdateManyWithoutProductLineNestedInput
  }

  export type ProductLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
    labelMemberships?: BrandMemberUncheckedUpdateManyWithoutProductLineNestedInput
    items?: PartUncheckedUpdateManyWithoutProductLineNestedInput
  }

  export type ProductLineCreateManyInput = {
    id?: number
    type?: string | null
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
  }

  export type ProductLineUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyGroupCreateInput = {
    order?: number | null
    name: string
    description?: string | null
    propertyTypes?: PropertyGroupMembershipCreateNestedManyWithoutGroupInput
  }

  export type PropertyGroupUncheckedCreateInput = {
    id?: number
    order?: number | null
    name: string
    description?: string | null
    propertyTypes?: PropertyGroupMembershipUncheckedCreateNestedManyWithoutGroupInput
  }

  export type PropertyGroupUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypes?: PropertyGroupMembershipUpdateManyWithoutGroupNestedInput
  }

  export type PropertyGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypes?: PropertyGroupMembershipUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type PropertyGroupCreateManyInput = {
    id?: number
    order?: number | null
    name: string
    description?: string | null
  }

  export type PropertyGroupUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyGroupMembershipCreateInput = {
    partType?: PartTypeCreateNestedOneWithoutPropertyTypesInput
    propertyType?: PropertyTypeCreateNestedOneWithoutGroupsInput
    group?: PropertyGroupCreateNestedOneWithoutPropertyTypesInput
  }

  export type PropertyGroupMembershipUncheckedCreateInput = {
    id?: number
    partTypeId?: number | null
    propertyTypeId?: number | null
    groupId?: number | null
  }

  export type PropertyGroupMembershipUpdateInput = {
    partType?: PartTypeUpdateOneWithoutPropertyTypesNestedInput
    propertyType?: PropertyTypeUpdateOneWithoutGroupsNestedInput
    group?: PropertyGroupUpdateOneWithoutPropertyTypesNestedInput
  }

  export type PropertyGroupMembershipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyGroupMembershipCreateManyInput = {
    id?: number
    partTypeId?: number | null
    propertyTypeId?: number | null
    groupId?: number | null
  }

  export type PropertyGroupMembershipUpdateManyMutationInput = {

  }

  export type PropertyGroupMembershipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyTypeCreateInput = {
    order?: number | null
    name?: string | null
    description?: string | null
    valueDataType?: string | null
    valueDataTypeModifier?: string | null
    variation?: string | null
    groups?: PropertyGroupMembershipCreateNestedManyWithoutPropertyTypeInput
    properties?: PropertyCreateNestedManyWithoutPropertyTypeInput
    lookupValues?: PropertyLookupCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeUncheckedCreateInput = {
    id?: number
    order?: number | null
    name?: string | null
    description?: string | null
    valueDataType?: string | null
    valueDataTypeModifier?: string | null
    variation?: string | null
    groups?: PropertyGroupMembershipUncheckedCreateNestedManyWithoutPropertyTypeInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyTypeInput
    lookupValues?: PropertyLookupUncheckedCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: PropertyGroupMembershipUpdateManyWithoutPropertyTypeNestedInput
    properties?: PropertyUpdateManyWithoutPropertyTypeNestedInput
    lookupValues?: PropertyLookupUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: PropertyGroupMembershipUncheckedUpdateManyWithoutPropertyTypeNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPropertyTypeNestedInput
    lookupValues?: PropertyLookupUncheckedUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeCreateManyInput = {
    id?: number
    order?: number | null
    name?: string | null
    description?: string | null
    valueDataType?: string | null
    valueDataTypeModifier?: string | null
    variation?: string | null
  }

  export type PropertyTypeUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyLookupCreateInput = {
    value?: string | null
    propertyType?: PropertyTypeCreateNestedOneWithoutLookupValuesInput
  }

  export type PropertyLookupUncheckedCreateInput = {
    id?: number
    value?: string | null
    propertyTypeId?: number | null
  }

  export type PropertyLookupUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: PropertyTypeUpdateOneWithoutLookupValuesNestedInput
  }

  export type PropertyLookupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyLookupCreateManyInput = {
    id?: number
    value?: string | null
    propertyTypeId?: number | null
  }

  export type PropertyLookupUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyLookupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartClassCreateInput = {
    order?: number | null
    name: string
    partTypes?: PartClassMembershipCreateNestedManyWithoutPartClassInput
  }

  export type PartClassUncheckedCreateInput = {
    id?: number
    order?: number | null
    name: string
    partTypes?: PartClassMembershipUncheckedCreateNestedManyWithoutPartClassInput
  }

  export type PartClassUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    partTypes?: PartClassMembershipUpdateManyWithoutPartClassNestedInput
  }

  export type PartClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    partTypes?: PartClassMembershipUncheckedUpdateManyWithoutPartClassNestedInput
  }

  export type PartClassCreateManyInput = {
    id?: number
    order?: number | null
    name: string
  }

  export type PartClassUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PartClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PartClassMembershipCreateInput = {
    partClass?: PartClassCreateNestedOneWithoutPartTypesInput
    partType?: PartTypeCreateNestedOneWithoutClassesInput
  }

  export type PartClassMembershipUncheckedCreateInput = {
    id?: number
    partClassId?: number | null
    partTypeId?: number | null
  }

  export type PartClassMembershipUpdateInput = {
    partClass?: PartClassUpdateOneWithoutPartTypesNestedInput
    partType?: PartTypeUpdateOneWithoutClassesNestedInput
  }

  export type PartClassMembershipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    partClassId?: NullableIntFieldUpdateOperationsInput | number | null
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartClassMembershipCreateManyInput = {
    id?: number
    partClassId?: number | null
    partTypeId?: number | null
  }

  export type PartClassMembershipUpdateManyMutationInput = {

  }

  export type PartClassMembershipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    partClassId?: NullableIntFieldUpdateOperationsInput | number | null
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartTypeCreateInput = {
    order?: number | null
    name: string
    description?: string | null
    propertyTypes?: PropertyGroupMembershipCreateNestedManyWithoutPartTypeInput
    classes?: PartClassMembershipCreateNestedManyWithoutPartTypeInput
  }

  export type PartTypeUncheckedCreateInput = {
    id?: number
    order?: number | null
    name: string
    description?: string | null
    propertyTypes?: PropertyGroupMembershipUncheckedCreateNestedManyWithoutPartTypeInput
    classes?: PartClassMembershipUncheckedCreateNestedManyWithoutPartTypeInput
  }

  export type PartTypeUpdateInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypes?: PropertyGroupMembershipUpdateManyWithoutPartTypeNestedInput
    classes?: PartClassMembershipUpdateManyWithoutPartTypeNestedInput
  }

  export type PartTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypes?: PropertyGroupMembershipUncheckedUpdateManyWithoutPartTypeNestedInput
    classes?: PartClassMembershipUncheckedUpdateManyWithoutPartTypeNestedInput
  }

  export type PartTypeCreateManyInput = {
    id?: number
    order?: number | null
    name: string
    description?: string | null
  }

  export type PartTypeUpdateManyMutationInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartGroupCreateInput = {
    name?: string | null
    parts?: PartGroupMembershipCreateNestedManyWithoutGroupInput
  }

  export type PartGroupUncheckedCreateInput = {
    id?: number
    name?: string | null
    parts?: PartGroupMembershipUncheckedCreateNestedManyWithoutGroupInput
  }

  export type PartGroupUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: PartGroupMembershipUpdateManyWithoutGroupNestedInput
  }

  export type PartGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: PartGroupMembershipUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type PartGroupCreateManyInput = {
    id?: number
    name?: string | null
  }

  export type PartGroupUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartGroupMembershipCreateInput = {
    part?: PartCreateNestedOneWithoutGroupsInput
    group?: PartGroupCreateNestedOneWithoutPartsInput
  }

  export type PartGroupMembershipUncheckedCreateInput = {
    id?: number
    partId?: number | null
    groupId?: number | null
  }

  export type PartGroupMembershipUpdateInput = {
    part?: PartUpdateOneWithoutGroupsNestedInput
    group?: PartGroupUpdateOneWithoutPartsNestedInput
  }

  export type PartGroupMembershipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    partId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartGroupMembershipCreateManyInput = {
    id?: number
    partId?: number | null
    groupId?: number | null
  }

  export type PartGroupMembershipUpdateManyMutationInput = {

  }

  export type PartGroupMembershipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    partId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartCreateInput = {
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLine?: ProductLineCreateNestedOneWithoutItemsInput
    wheelHubs?: WheelCreateNestedManyWithoutHubInput
    wheelRims?: WheelCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeCreateNestedManyWithoutSpokeInput
    properties?: PropertyCreateNestedManyWithoutPartInput
    claims?: ClaimCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipCreateNestedManyWithoutPartInput
    builds?: BuildPartCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLineId?: number | null
    wheelHubs?: WheelUncheckedCreateNestedManyWithoutHubInput
    wheelRims?: WheelUncheckedCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeUncheckedCreateNestedManyWithoutSpokeInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPartInput
    claims?: ClaimUncheckedCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipUncheckedCreateNestedManyWithoutPartInput
    builds?: BuildPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLine?: ProductLineUpdateOneWithoutItemsNestedInput
    wheelHubs?: WheelUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUpdateManyWithoutPartNestedInput
    claims?: ClaimUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUpdateManyWithoutPartNestedInput
    builds?: BuildPartUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelHubs?: WheelUncheckedUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUncheckedUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUncheckedUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPartNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUncheckedUpdateManyWithoutPartNestedInput
    builds?: BuildPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartCreateManyInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLineId?: number | null
  }

  export type PartUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyCreateInput = {
    value?: string | null
    valueDataMethod?: string | null
    part?: PartCreateNestedOneWithoutPropertiesInput
    propertyType?: PropertyTypeCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: number
    itemId?: number | null
    value?: string | null
    valueDataMethod?: string | null
    propertyTypeId?: number | null
  }

  export type PropertyUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
    part?: PartUpdateOneWithoutPropertiesNestedInput
    propertyType?: PropertyTypeUpdateOneWithoutPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyCreateManyInput = {
    id?: number
    itemId?: number | null
    value?: string | null
    valueDataMethod?: string | null
    propertyTypeId?: number | null
  }

  export type PropertyUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WheelSpokeCreateInput = {
    quantity?: number | null
    length?: Decimal | DecimalJsLike | number | string | null
    tensionApplied?: Decimal | DecimalJsLike | number | string | null
    tensionUnit?: string | null
    preparation?: string | null
    notes?: string | null
    spoke?: PartCreateNestedOneWithoutWheelSpokesInput
    wheel?: WheelCreateNestedOneWithoutSpokesInput
  }

  export type WheelSpokeUncheckedCreateInput = {
    id?: number
    quantity?: number | null
    length?: Decimal | DecimalJsLike | number | string | null
    tensionApplied?: Decimal | DecimalJsLike | number | string | null
    tensionUnit?: string | null
    preparation?: string | null
    notes?: string | null
    spokeId?: number | null
    wheelId?: number | null
  }

  export type WheelSpokeUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    spoke?: PartUpdateOneWithoutWheelSpokesNestedInput
    wheel?: WheelUpdateOneWithoutSpokesNestedInput
  }

  export type WheelSpokeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    spokeId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WheelSpokeCreateManyInput = {
    id?: number
    quantity?: number | null
    length?: Decimal | DecimalJsLike | number | string | null
    tensionApplied?: Decimal | DecimalJsLike | number | string | null
    tensionUnit?: string | null
    preparation?: string | null
    notes?: string | null
    spokeId?: number | null
    wheelId?: number | null
  }

  export type WheelSpokeUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WheelSpokeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    spokeId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WheelCreateInput = {
    name?: string | null
    notes?: string | null
    hub?: PartCreateNestedOneWithoutWheelHubsInput
    rim?: PartCreateNestedOneWithoutWheelRimsInput
    spokes?: WheelSpokeCreateNestedManyWithoutWheelInput
  }

  export type WheelUncheckedCreateInput = {
    id?: number
    name?: string | null
    notes?: string | null
    hubId?: number | null
    rimId?: number | null
    spokes?: WheelSpokeUncheckedCreateNestedManyWithoutWheelInput
  }

  export type WheelUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hub?: PartUpdateOneWithoutWheelHubsNestedInput
    rim?: PartUpdateOneWithoutWheelRimsNestedInput
    spokes?: WheelSpokeUpdateManyWithoutWheelNestedInput
  }

  export type WheelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hubId?: NullableIntFieldUpdateOperationsInput | number | null
    rimId?: NullableIntFieldUpdateOperationsInput | number | null
    spokes?: WheelSpokeUncheckedUpdateManyWithoutWheelNestedInput
  }

  export type WheelCreateManyInput = {
    id?: number
    name?: string | null
    notes?: string | null
    hubId?: number | null
    rimId?: number | null
  }

  export type WheelUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WheelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hubId?: NullableIntFieldUpdateOperationsInput | number | null
    rimId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuildPartCreateInput = {
    build?: BuildCreateNestedOneWithoutPartsInput
    part?: PartCreateNestedOneWithoutBuildsInput
  }

  export type BuildPartUncheckedCreateInput = {
    id?: number
    buildId?: number | null
    partId?: number | null
  }

  export type BuildPartUpdateInput = {
    build?: BuildUpdateOneWithoutPartsNestedInput
    part?: PartUpdateOneWithoutBuildsNestedInput
  }

  export type BuildPartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuildPartCreateManyInput = {
    id?: number
    buildId?: number | null
    partId?: number | null
  }

  export type BuildPartUpdateManyMutationInput = {

  }

  export type BuildPartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuildCreateInput = {
    name?: string | null
    status?: string | null
    notes?: string | null
    parts?: BuildPartCreateNestedManyWithoutBuildInput
  }

  export type BuildUncheckedCreateInput = {
    id?: number
    name?: string | null
    status?: string | null
    notes?: string | null
    parts?: BuildPartUncheckedCreateNestedManyWithoutBuildInput
  }

  export type BuildUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: BuildPartUpdateManyWithoutBuildNestedInput
  }

  export type BuildUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: BuildPartUncheckedUpdateManyWithoutBuildNestedInput
  }

  export type BuildCreateManyInput = {
    id?: number
    name?: string | null
    status?: string | null
    notes?: string | null
  }

  export type BuildUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClaimListRelationFilter = {
    every?: ClaimWhereInput
    some?: ClaimWhereInput
    none?: ClaimWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameLast?: SortOrder
    nameFirst?: SortOrder
    providerId?: SortOrder
    provider?: SortOrder
    roles?: SortOrder
    registered?: SortOrder
    lastLogIn?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameLast?: SortOrder
    nameFirst?: SortOrder
    providerId?: SortOrder
    provider?: SortOrder
    roles?: SortOrder
    registered?: SortOrder
    lastLogIn?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameLast?: SortOrder
    nameFirst?: SortOrder
    providerId?: SortOrder
    provider?: SortOrder
    roles?: SortOrder
    registered?: SortOrder
    lastLogIn?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PartNullableRelationFilter = {
    is?: PartWhereInput | null
    isNot?: PartWhereInput | null
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    claimType?: SortOrder
    acquired?: SortOrder
    condition?: SortOrder
    notes?: SortOrder
    ownerId?: SortOrder
    partId?: SortOrder
  }

  export type ClaimAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    partId?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    claimType?: SortOrder
    acquired?: SortOrder
    condition?: SortOrder
    notes?: SortOrder
    ownerId?: SortOrder
    partId?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    claimType?: SortOrder
    acquired?: SortOrder
    condition?: SortOrder
    notes?: SortOrder
    ownerId?: SortOrder
    partId?: SortOrder
  }

  export type ClaimSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    partId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BrandMemberListRelationFilter = {
    every?: BrandMemberWhereInput
    some?: BrandMemberWhereInput
    none?: BrandMemberWhereInput
  }

  export type BrandMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameShort?: SortOrder
    nameAbbreviation?: SortOrder
    notes?: SortOrder
    webAddress?: SortOrder
  }

  export type BrandAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameShort?: SortOrder
    nameAbbreviation?: SortOrder
    notes?: SortOrder
    webAddress?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameShort?: SortOrder
    nameAbbreviation?: SortOrder
    notes?: SortOrder
    webAddress?: SortOrder
  }

  export type BrandSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductLineNullableRelationFilter = {
    is?: ProductLineWhereInput | null
    isNot?: ProductLineWhereInput | null
  }

  export type BrandNullableRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type BrandMemberCountOrderByAggregateInput = {
    id?: SortOrder
    productLineId?: SortOrder
    brandId?: SortOrder
  }

  export type BrandMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    productLineId?: SortOrder
    brandId?: SortOrder
  }

  export type BrandMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    productLineId?: SortOrder
    brandId?: SortOrder
  }

  export type BrandMemberMinOrderByAggregateInput = {
    id?: SortOrder
    productLineId?: SortOrder
    brandId?: SortOrder
  }

  export type BrandMemberSumOrderByAggregateInput = {
    id?: SortOrder
    productLineId?: SortOrder
    brandId?: SortOrder
  }

  export type PartListRelationFilter = {
    every?: PartWhereInput
    some?: PartWhereInput
    none?: PartWhereInput
  }

  export type PartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductLineCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    nameShort?: SortOrder
    nameAbbreviation?: SortOrder
    notes?: SortOrder
    webAddress?: SortOrder
  }

  export type ProductLineAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductLineMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    nameShort?: SortOrder
    nameAbbreviation?: SortOrder
    notes?: SortOrder
    webAddress?: SortOrder
  }

  export type ProductLineMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    nameShort?: SortOrder
    nameAbbreviation?: SortOrder
    notes?: SortOrder
    webAddress?: SortOrder
  }

  export type ProductLineSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PropertyGroupMembershipListRelationFilter = {
    every?: PropertyGroupMembershipWhereInput
    some?: PropertyGroupMembershipWhereInput
    none?: PropertyGroupMembershipWhereInput
  }

  export type PropertyGroupMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyGroupCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PropertyGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type PropertyGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PropertyGroupMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PropertyGroupSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type PartTypeNullableRelationFilter = {
    is?: PartTypeWhereInput | null
    isNot?: PartTypeWhereInput | null
  }

  export type PropertyTypeNullableRelationFilter = {
    is?: PropertyTypeWhereInput | null
    isNot?: PropertyTypeWhereInput | null
  }

  export type PropertyGroupNullableRelationFilter = {
    is?: PropertyGroupWhereInput | null
    isNot?: PropertyGroupWhereInput | null
  }

  export type PropertyGroupMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    partTypeId?: SortOrder
    propertyTypeId?: SortOrder
    groupId?: SortOrder
  }

  export type PropertyGroupMembershipAvgOrderByAggregateInput = {
    id?: SortOrder
    partTypeId?: SortOrder
    propertyTypeId?: SortOrder
    groupId?: SortOrder
  }

  export type PropertyGroupMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    partTypeId?: SortOrder
    propertyTypeId?: SortOrder
    groupId?: SortOrder
  }

  export type PropertyGroupMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    partTypeId?: SortOrder
    propertyTypeId?: SortOrder
    groupId?: SortOrder
  }

  export type PropertyGroupMembershipSumOrderByAggregateInput = {
    id?: SortOrder
    partTypeId?: SortOrder
    propertyTypeId?: SortOrder
    groupId?: SortOrder
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type PropertyLookupListRelationFilter = {
    every?: PropertyLookupWhereInput
    some?: PropertyLookupWhereInput
    none?: PropertyLookupWhereInput
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyLookupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyTypeCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
    valueDataType?: SortOrder
    valueDataTypeModifier?: SortOrder
    variation?: SortOrder
  }

  export type PropertyTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type PropertyTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
    valueDataType?: SortOrder
    valueDataTypeModifier?: SortOrder
    variation?: SortOrder
  }

  export type PropertyTypeMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
    valueDataType?: SortOrder
    valueDataTypeModifier?: SortOrder
    variation?: SortOrder
  }

  export type PropertyTypeSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type PropertyLookupCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type PropertyLookupAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type PropertyLookupMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type PropertyLookupMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type PropertyLookupSumOrderByAggregateInput = {
    id?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type PartClassMembershipListRelationFilter = {
    every?: PartClassMembershipWhereInput
    some?: PartClassMembershipWhereInput
    none?: PartClassMembershipWhereInput
  }

  export type PartClassMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartClassCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
  }

  export type PartClassAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type PartClassMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
  }

  export type PartClassMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
  }

  export type PartClassSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type PartClassNullableRelationFilter = {
    is?: PartClassWhereInput | null
    isNot?: PartClassWhereInput | null
  }

  export type PartClassMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    partClassId?: SortOrder
    partTypeId?: SortOrder
  }

  export type PartClassMembershipAvgOrderByAggregateInput = {
    id?: SortOrder
    partClassId?: SortOrder
    partTypeId?: SortOrder
  }

  export type PartClassMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    partClassId?: SortOrder
    partTypeId?: SortOrder
  }

  export type PartClassMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    partClassId?: SortOrder
    partTypeId?: SortOrder
  }

  export type PartClassMembershipSumOrderByAggregateInput = {
    id?: SortOrder
    partClassId?: SortOrder
    partTypeId?: SortOrder
  }

  export type PartTypeCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PartTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type PartTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PartTypeMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type PartTypeSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type PartGroupMembershipListRelationFilter = {
    every?: PartGroupMembershipWhereInput
    some?: PartGroupMembershipWhereInput
    none?: PartGroupMembershipWhereInput
  }

  export type PartGroupMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PartGroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PartGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PartGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PartGroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PartGroupNullableRelationFilter = {
    is?: PartGroupWhereInput | null
    isNot?: PartGroupWhereInput | null
  }

  export type PartGroupMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    groupId?: SortOrder
  }

  export type PartGroupMembershipAvgOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    groupId?: SortOrder
  }

  export type PartGroupMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    groupId?: SortOrder
  }

  export type PartGroupMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    groupId?: SortOrder
  }

  export type PartGroupMembershipSumOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
    groupId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type WheelListRelationFilter = {
    every?: WheelWhereInput
    some?: WheelWhereInput
    none?: WheelWhereInput
  }

  export type WheelSpokeListRelationFilter = {
    every?: WheelSpokeWhereInput
    some?: WheelSpokeWhereInput
    none?: WheelSpokeWhereInput
  }

  export type BuildPartListRelationFilter = {
    every?: BuildPartWhereInput
    some?: BuildPartWhereInput
    none?: BuildPartWhereInput
  }

  export type WheelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WheelSpokeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildPartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    productLineId?: SortOrder
  }

  export type PartAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    productLineId?: SortOrder
  }

  export type PartMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    productLineId?: SortOrder
  }

  export type PartMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    productLineId?: SortOrder
  }

  export type PartSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    productLineId?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    value?: SortOrder
    valueDataMethod?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    value?: SortOrder
    valueDataMethod?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    value?: SortOrder
    valueDataMethod?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    propertyTypeId?: SortOrder
  }

  export type WheelNullableRelationFilter = {
    is?: WheelWhereInput | null
    isNot?: WheelWhereInput | null
  }

  export type WheelSpokeCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    length?: SortOrder
    tensionApplied?: SortOrder
    tensionUnit?: SortOrder
    preparation?: SortOrder
    notes?: SortOrder
    spokeId?: SortOrder
    wheelId?: SortOrder
  }

  export type WheelSpokeAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    length?: SortOrder
    tensionApplied?: SortOrder
    spokeId?: SortOrder
    wheelId?: SortOrder
  }

  export type WheelSpokeMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    length?: SortOrder
    tensionApplied?: SortOrder
    tensionUnit?: SortOrder
    preparation?: SortOrder
    notes?: SortOrder
    spokeId?: SortOrder
    wheelId?: SortOrder
  }

  export type WheelSpokeMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    length?: SortOrder
    tensionApplied?: SortOrder
    tensionUnit?: SortOrder
    preparation?: SortOrder
    notes?: SortOrder
    spokeId?: SortOrder
    wheelId?: SortOrder
  }

  export type WheelSpokeSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    length?: SortOrder
    tensionApplied?: SortOrder
    spokeId?: SortOrder
    wheelId?: SortOrder
  }

  export type WheelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    hubId?: SortOrder
    rimId?: SortOrder
  }

  export type WheelAvgOrderByAggregateInput = {
    id?: SortOrder
    hubId?: SortOrder
    rimId?: SortOrder
  }

  export type WheelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    hubId?: SortOrder
    rimId?: SortOrder
  }

  export type WheelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    hubId?: SortOrder
    rimId?: SortOrder
  }

  export type WheelSumOrderByAggregateInput = {
    id?: SortOrder
    hubId?: SortOrder
    rimId?: SortOrder
  }

  export type BuildNullableRelationFilter = {
    is?: BuildWhereInput | null
    isNot?: BuildWhereInput | null
  }

  export type BuildPartCountOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    partId?: SortOrder
  }

  export type BuildPartAvgOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    partId?: SortOrder
  }

  export type BuildPartMaxOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    partId?: SortOrder
  }

  export type BuildPartMinOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    partId?: SortOrder
  }

  export type BuildPartSumOrderByAggregateInput = {
    id?: SortOrder
    buildId?: SortOrder
    partId?: SortOrder
  }

  export type BuildCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type BuildAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BuildMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type BuildMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type BuildSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClaimCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ClaimCreateWithoutOwnerInput, ClaimUncheckedCreateWithoutOwnerInput> | ClaimCreateWithoutOwnerInput[] | ClaimUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutOwnerInput | ClaimCreateOrConnectWithoutOwnerInput[]
    createMany?: ClaimCreateManyOwnerInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ClaimCreateWithoutOwnerInput, ClaimUncheckedCreateWithoutOwnerInput> | ClaimCreateWithoutOwnerInput[] | ClaimUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutOwnerInput | ClaimCreateOrConnectWithoutOwnerInput[]
    createMany?: ClaimCreateManyOwnerInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClaimUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ClaimCreateWithoutOwnerInput, ClaimUncheckedCreateWithoutOwnerInput> | ClaimCreateWithoutOwnerInput[] | ClaimUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutOwnerInput | ClaimCreateOrConnectWithoutOwnerInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutOwnerInput | ClaimUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ClaimCreateManyOwnerInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutOwnerInput | ClaimUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutOwnerInput | ClaimUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClaimUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ClaimCreateWithoutOwnerInput, ClaimUncheckedCreateWithoutOwnerInput> | ClaimCreateWithoutOwnerInput[] | ClaimUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutOwnerInput | ClaimCreateOrConnectWithoutOwnerInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutOwnerInput | ClaimUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ClaimCreateManyOwnerInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutOwnerInput | ClaimUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutOwnerInput | ClaimUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClaimsInput = {
    create?: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInput
    connect?: UserWhereUniqueInput
  }

  export type PartCreateNestedOneWithoutClaimsInput = {
    create?: XOR<PartCreateWithoutClaimsInput, PartUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: PartCreateOrConnectWithoutClaimsInput
    connect?: PartWhereUniqueInput
  }

  export type UserUpdateOneWithoutClaimsNestedInput = {
    create?: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInput
    upsert?: UserUpsertWithoutClaimsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClaimsInput, UserUpdateWithoutClaimsInput>, UserUncheckedUpdateWithoutClaimsInput>
  }

  export type PartUpdateOneWithoutClaimsNestedInput = {
    create?: XOR<PartCreateWithoutClaimsInput, PartUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: PartCreateOrConnectWithoutClaimsInput
    upsert?: PartUpsertWithoutClaimsInput
    disconnect?: PartWhereInput | boolean
    delete?: PartWhereInput | boolean
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutClaimsInput, PartUpdateWithoutClaimsInput>, PartUncheckedUpdateWithoutClaimsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BrandMemberCreateNestedManyWithoutBrandInput = {
    create?: XOR<BrandMemberCreateWithoutBrandInput, BrandMemberUncheckedCreateWithoutBrandInput> | BrandMemberCreateWithoutBrandInput[] | BrandMemberUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: BrandMemberCreateOrConnectWithoutBrandInput | BrandMemberCreateOrConnectWithoutBrandInput[]
    createMany?: BrandMemberCreateManyBrandInputEnvelope
    connect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
  }

  export type BrandMemberUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<BrandMemberCreateWithoutBrandInput, BrandMemberUncheckedCreateWithoutBrandInput> | BrandMemberCreateWithoutBrandInput[] | BrandMemberUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: BrandMemberCreateOrConnectWithoutBrandInput | BrandMemberCreateOrConnectWithoutBrandInput[]
    createMany?: BrandMemberCreateManyBrandInputEnvelope
    connect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
  }

  export type BrandMemberUpdateManyWithoutBrandNestedInput = {
    create?: XOR<BrandMemberCreateWithoutBrandInput, BrandMemberUncheckedCreateWithoutBrandInput> | BrandMemberCreateWithoutBrandInput[] | BrandMemberUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: BrandMemberCreateOrConnectWithoutBrandInput | BrandMemberCreateOrConnectWithoutBrandInput[]
    upsert?: BrandMemberUpsertWithWhereUniqueWithoutBrandInput | BrandMemberUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: BrandMemberCreateManyBrandInputEnvelope
    set?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    disconnect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    delete?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    connect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    update?: BrandMemberUpdateWithWhereUniqueWithoutBrandInput | BrandMemberUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: BrandMemberUpdateManyWithWhereWithoutBrandInput | BrandMemberUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: BrandMemberScalarWhereInput | BrandMemberScalarWhereInput[]
  }

  export type BrandMemberUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<BrandMemberCreateWithoutBrandInput, BrandMemberUncheckedCreateWithoutBrandInput> | BrandMemberCreateWithoutBrandInput[] | BrandMemberUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: BrandMemberCreateOrConnectWithoutBrandInput | BrandMemberCreateOrConnectWithoutBrandInput[]
    upsert?: BrandMemberUpsertWithWhereUniqueWithoutBrandInput | BrandMemberUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: BrandMemberCreateManyBrandInputEnvelope
    set?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    disconnect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    delete?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    connect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    update?: BrandMemberUpdateWithWhereUniqueWithoutBrandInput | BrandMemberUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: BrandMemberUpdateManyWithWhereWithoutBrandInput | BrandMemberUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: BrandMemberScalarWhereInput | BrandMemberScalarWhereInput[]
  }

  export type ProductLineCreateNestedOneWithoutLabelMembershipsInput = {
    create?: XOR<ProductLineCreateWithoutLabelMembershipsInput, ProductLineUncheckedCreateWithoutLabelMembershipsInput>
    connectOrCreate?: ProductLineCreateOrConnectWithoutLabelMembershipsInput
    connect?: ProductLineWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutLabelMembershipsInput = {
    create?: XOR<BrandCreateWithoutLabelMembershipsInput, BrandUncheckedCreateWithoutLabelMembershipsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutLabelMembershipsInput
    connect?: BrandWhereUniqueInput
  }

  export type ProductLineUpdateOneWithoutLabelMembershipsNestedInput = {
    create?: XOR<ProductLineCreateWithoutLabelMembershipsInput, ProductLineUncheckedCreateWithoutLabelMembershipsInput>
    connectOrCreate?: ProductLineCreateOrConnectWithoutLabelMembershipsInput
    upsert?: ProductLineUpsertWithoutLabelMembershipsInput
    disconnect?: ProductLineWhereInput | boolean
    delete?: ProductLineWhereInput | boolean
    connect?: ProductLineWhereUniqueInput
    update?: XOR<XOR<ProductLineUpdateToOneWithWhereWithoutLabelMembershipsInput, ProductLineUpdateWithoutLabelMembershipsInput>, ProductLineUncheckedUpdateWithoutLabelMembershipsInput>
  }

  export type BrandUpdateOneWithoutLabelMembershipsNestedInput = {
    create?: XOR<BrandCreateWithoutLabelMembershipsInput, BrandUncheckedCreateWithoutLabelMembershipsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutLabelMembershipsInput
    upsert?: BrandUpsertWithoutLabelMembershipsInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutLabelMembershipsInput, BrandUpdateWithoutLabelMembershipsInput>, BrandUncheckedUpdateWithoutLabelMembershipsInput>
  }

  export type BrandMemberCreateNestedManyWithoutProductLineInput = {
    create?: XOR<BrandMemberCreateWithoutProductLineInput, BrandMemberUncheckedCreateWithoutProductLineInput> | BrandMemberCreateWithoutProductLineInput[] | BrandMemberUncheckedCreateWithoutProductLineInput[]
    connectOrCreate?: BrandMemberCreateOrConnectWithoutProductLineInput | BrandMemberCreateOrConnectWithoutProductLineInput[]
    createMany?: BrandMemberCreateManyProductLineInputEnvelope
    connect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
  }

  export type PartCreateNestedManyWithoutProductLineInput = {
    create?: XOR<PartCreateWithoutProductLineInput, PartUncheckedCreateWithoutProductLineInput> | PartCreateWithoutProductLineInput[] | PartUncheckedCreateWithoutProductLineInput[]
    connectOrCreate?: PartCreateOrConnectWithoutProductLineInput | PartCreateOrConnectWithoutProductLineInput[]
    createMany?: PartCreateManyProductLineInputEnvelope
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
  }

  export type BrandMemberUncheckedCreateNestedManyWithoutProductLineInput = {
    create?: XOR<BrandMemberCreateWithoutProductLineInput, BrandMemberUncheckedCreateWithoutProductLineInput> | BrandMemberCreateWithoutProductLineInput[] | BrandMemberUncheckedCreateWithoutProductLineInput[]
    connectOrCreate?: BrandMemberCreateOrConnectWithoutProductLineInput | BrandMemberCreateOrConnectWithoutProductLineInput[]
    createMany?: BrandMemberCreateManyProductLineInputEnvelope
    connect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
  }

  export type PartUncheckedCreateNestedManyWithoutProductLineInput = {
    create?: XOR<PartCreateWithoutProductLineInput, PartUncheckedCreateWithoutProductLineInput> | PartCreateWithoutProductLineInput[] | PartUncheckedCreateWithoutProductLineInput[]
    connectOrCreate?: PartCreateOrConnectWithoutProductLineInput | PartCreateOrConnectWithoutProductLineInput[]
    createMany?: PartCreateManyProductLineInputEnvelope
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
  }

  export type BrandMemberUpdateManyWithoutProductLineNestedInput = {
    create?: XOR<BrandMemberCreateWithoutProductLineInput, BrandMemberUncheckedCreateWithoutProductLineInput> | BrandMemberCreateWithoutProductLineInput[] | BrandMemberUncheckedCreateWithoutProductLineInput[]
    connectOrCreate?: BrandMemberCreateOrConnectWithoutProductLineInput | BrandMemberCreateOrConnectWithoutProductLineInput[]
    upsert?: BrandMemberUpsertWithWhereUniqueWithoutProductLineInput | BrandMemberUpsertWithWhereUniqueWithoutProductLineInput[]
    createMany?: BrandMemberCreateManyProductLineInputEnvelope
    set?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    disconnect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    delete?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    connect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    update?: BrandMemberUpdateWithWhereUniqueWithoutProductLineInput | BrandMemberUpdateWithWhereUniqueWithoutProductLineInput[]
    updateMany?: BrandMemberUpdateManyWithWhereWithoutProductLineInput | BrandMemberUpdateManyWithWhereWithoutProductLineInput[]
    deleteMany?: BrandMemberScalarWhereInput | BrandMemberScalarWhereInput[]
  }

  export type PartUpdateManyWithoutProductLineNestedInput = {
    create?: XOR<PartCreateWithoutProductLineInput, PartUncheckedCreateWithoutProductLineInput> | PartCreateWithoutProductLineInput[] | PartUncheckedCreateWithoutProductLineInput[]
    connectOrCreate?: PartCreateOrConnectWithoutProductLineInput | PartCreateOrConnectWithoutProductLineInput[]
    upsert?: PartUpsertWithWhereUniqueWithoutProductLineInput | PartUpsertWithWhereUniqueWithoutProductLineInput[]
    createMany?: PartCreateManyProductLineInputEnvelope
    set?: PartWhereUniqueInput | PartWhereUniqueInput[]
    disconnect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    delete?: PartWhereUniqueInput | PartWhereUniqueInput[]
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    update?: PartUpdateWithWhereUniqueWithoutProductLineInput | PartUpdateWithWhereUniqueWithoutProductLineInput[]
    updateMany?: PartUpdateManyWithWhereWithoutProductLineInput | PartUpdateManyWithWhereWithoutProductLineInput[]
    deleteMany?: PartScalarWhereInput | PartScalarWhereInput[]
  }

  export type BrandMemberUncheckedUpdateManyWithoutProductLineNestedInput = {
    create?: XOR<BrandMemberCreateWithoutProductLineInput, BrandMemberUncheckedCreateWithoutProductLineInput> | BrandMemberCreateWithoutProductLineInput[] | BrandMemberUncheckedCreateWithoutProductLineInput[]
    connectOrCreate?: BrandMemberCreateOrConnectWithoutProductLineInput | BrandMemberCreateOrConnectWithoutProductLineInput[]
    upsert?: BrandMemberUpsertWithWhereUniqueWithoutProductLineInput | BrandMemberUpsertWithWhereUniqueWithoutProductLineInput[]
    createMany?: BrandMemberCreateManyProductLineInputEnvelope
    set?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    disconnect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    delete?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    connect?: BrandMemberWhereUniqueInput | BrandMemberWhereUniqueInput[]
    update?: BrandMemberUpdateWithWhereUniqueWithoutProductLineInput | BrandMemberUpdateWithWhereUniqueWithoutProductLineInput[]
    updateMany?: BrandMemberUpdateManyWithWhereWithoutProductLineInput | BrandMemberUpdateManyWithWhereWithoutProductLineInput[]
    deleteMany?: BrandMemberScalarWhereInput | BrandMemberScalarWhereInput[]
  }

  export type PartUncheckedUpdateManyWithoutProductLineNestedInput = {
    create?: XOR<PartCreateWithoutProductLineInput, PartUncheckedCreateWithoutProductLineInput> | PartCreateWithoutProductLineInput[] | PartUncheckedCreateWithoutProductLineInput[]
    connectOrCreate?: PartCreateOrConnectWithoutProductLineInput | PartCreateOrConnectWithoutProductLineInput[]
    upsert?: PartUpsertWithWhereUniqueWithoutProductLineInput | PartUpsertWithWhereUniqueWithoutProductLineInput[]
    createMany?: PartCreateManyProductLineInputEnvelope
    set?: PartWhereUniqueInput | PartWhereUniqueInput[]
    disconnect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    delete?: PartWhereUniqueInput | PartWhereUniqueInput[]
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    update?: PartUpdateWithWhereUniqueWithoutProductLineInput | PartUpdateWithWhereUniqueWithoutProductLineInput[]
    updateMany?: PartUpdateManyWithWhereWithoutProductLineInput | PartUpdateManyWithWhereWithoutProductLineInput[]
    deleteMany?: PartScalarWhereInput | PartScalarWhereInput[]
  }

  export type PropertyGroupMembershipCreateNestedManyWithoutGroupInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutGroupInput, PropertyGroupMembershipUncheckedCreateWithoutGroupInput> | PropertyGroupMembershipCreateWithoutGroupInput[] | PropertyGroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutGroupInput | PropertyGroupMembershipCreateOrConnectWithoutGroupInput[]
    createMany?: PropertyGroupMembershipCreateManyGroupInputEnvelope
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
  }

  export type PropertyGroupMembershipUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutGroupInput, PropertyGroupMembershipUncheckedCreateWithoutGroupInput> | PropertyGroupMembershipCreateWithoutGroupInput[] | PropertyGroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutGroupInput | PropertyGroupMembershipCreateOrConnectWithoutGroupInput[]
    createMany?: PropertyGroupMembershipCreateManyGroupInputEnvelope
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
  }

  export type PropertyGroupMembershipUpdateManyWithoutGroupNestedInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutGroupInput, PropertyGroupMembershipUncheckedCreateWithoutGroupInput> | PropertyGroupMembershipCreateWithoutGroupInput[] | PropertyGroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutGroupInput | PropertyGroupMembershipCreateOrConnectWithoutGroupInput[]
    upsert?: PropertyGroupMembershipUpsertWithWhereUniqueWithoutGroupInput | PropertyGroupMembershipUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: PropertyGroupMembershipCreateManyGroupInputEnvelope
    set?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    disconnect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    delete?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    update?: PropertyGroupMembershipUpdateWithWhereUniqueWithoutGroupInput | PropertyGroupMembershipUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: PropertyGroupMembershipUpdateManyWithWhereWithoutGroupInput | PropertyGroupMembershipUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: PropertyGroupMembershipScalarWhereInput | PropertyGroupMembershipScalarWhereInput[]
  }

  export type PropertyGroupMembershipUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutGroupInput, PropertyGroupMembershipUncheckedCreateWithoutGroupInput> | PropertyGroupMembershipCreateWithoutGroupInput[] | PropertyGroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutGroupInput | PropertyGroupMembershipCreateOrConnectWithoutGroupInput[]
    upsert?: PropertyGroupMembershipUpsertWithWhereUniqueWithoutGroupInput | PropertyGroupMembershipUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: PropertyGroupMembershipCreateManyGroupInputEnvelope
    set?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    disconnect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    delete?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    update?: PropertyGroupMembershipUpdateWithWhereUniqueWithoutGroupInput | PropertyGroupMembershipUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: PropertyGroupMembershipUpdateManyWithWhereWithoutGroupInput | PropertyGroupMembershipUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: PropertyGroupMembershipScalarWhereInput | PropertyGroupMembershipScalarWhereInput[]
  }

  export type PartTypeCreateNestedOneWithoutPropertyTypesInput = {
    create?: XOR<PartTypeCreateWithoutPropertyTypesInput, PartTypeUncheckedCreateWithoutPropertyTypesInput>
    connectOrCreate?: PartTypeCreateOrConnectWithoutPropertyTypesInput
    connect?: PartTypeWhereUniqueInput
  }

  export type PropertyTypeCreateNestedOneWithoutGroupsInput = {
    create?: XOR<PropertyTypeCreateWithoutGroupsInput, PropertyTypeUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: PropertyTypeCreateOrConnectWithoutGroupsInput
    connect?: PropertyTypeWhereUniqueInput
  }

  export type PropertyGroupCreateNestedOneWithoutPropertyTypesInput = {
    create?: XOR<PropertyGroupCreateWithoutPropertyTypesInput, PropertyGroupUncheckedCreateWithoutPropertyTypesInput>
    connectOrCreate?: PropertyGroupCreateOrConnectWithoutPropertyTypesInput
    connect?: PropertyGroupWhereUniqueInput
  }

  export type PartTypeUpdateOneWithoutPropertyTypesNestedInput = {
    create?: XOR<PartTypeCreateWithoutPropertyTypesInput, PartTypeUncheckedCreateWithoutPropertyTypesInput>
    connectOrCreate?: PartTypeCreateOrConnectWithoutPropertyTypesInput
    upsert?: PartTypeUpsertWithoutPropertyTypesInput
    disconnect?: PartTypeWhereInput | boolean
    delete?: PartTypeWhereInput | boolean
    connect?: PartTypeWhereUniqueInput
    update?: XOR<XOR<PartTypeUpdateToOneWithWhereWithoutPropertyTypesInput, PartTypeUpdateWithoutPropertyTypesInput>, PartTypeUncheckedUpdateWithoutPropertyTypesInput>
  }

  export type PropertyTypeUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<PropertyTypeCreateWithoutGroupsInput, PropertyTypeUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: PropertyTypeCreateOrConnectWithoutGroupsInput
    upsert?: PropertyTypeUpsertWithoutGroupsInput
    disconnect?: PropertyTypeWhereInput | boolean
    delete?: PropertyTypeWhereInput | boolean
    connect?: PropertyTypeWhereUniqueInput
    update?: XOR<XOR<PropertyTypeUpdateToOneWithWhereWithoutGroupsInput, PropertyTypeUpdateWithoutGroupsInput>, PropertyTypeUncheckedUpdateWithoutGroupsInput>
  }

  export type PropertyGroupUpdateOneWithoutPropertyTypesNestedInput = {
    create?: XOR<PropertyGroupCreateWithoutPropertyTypesInput, PropertyGroupUncheckedCreateWithoutPropertyTypesInput>
    connectOrCreate?: PropertyGroupCreateOrConnectWithoutPropertyTypesInput
    upsert?: PropertyGroupUpsertWithoutPropertyTypesInput
    disconnect?: PropertyGroupWhereInput | boolean
    delete?: PropertyGroupWhereInput | boolean
    connect?: PropertyGroupWhereUniqueInput
    update?: XOR<XOR<PropertyGroupUpdateToOneWithWhereWithoutPropertyTypesInput, PropertyGroupUpdateWithoutPropertyTypesInput>, PropertyGroupUncheckedUpdateWithoutPropertyTypesInput>
  }

  export type PropertyGroupMembershipCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutPropertyTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput> | PropertyGroupMembershipCreateWithoutPropertyTypeInput[] | PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutPropertyTypeInput | PropertyGroupMembershipCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyGroupMembershipCreateManyPropertyTypeInputEnvelope
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyLookupCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyLookupCreateWithoutPropertyTypeInput, PropertyLookupUncheckedCreateWithoutPropertyTypeInput> | PropertyLookupCreateWithoutPropertyTypeInput[] | PropertyLookupUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyLookupCreateOrConnectWithoutPropertyTypeInput | PropertyLookupCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyLookupCreateManyPropertyTypeInputEnvelope
    connect?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
  }

  export type PropertyGroupMembershipUncheckedCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutPropertyTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput> | PropertyGroupMembershipCreateWithoutPropertyTypeInput[] | PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutPropertyTypeInput | PropertyGroupMembershipCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyGroupMembershipCreateManyPropertyTypeInputEnvelope
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyLookupUncheckedCreateNestedManyWithoutPropertyTypeInput = {
    create?: XOR<PropertyLookupCreateWithoutPropertyTypeInput, PropertyLookupUncheckedCreateWithoutPropertyTypeInput> | PropertyLookupCreateWithoutPropertyTypeInput[] | PropertyLookupUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyLookupCreateOrConnectWithoutPropertyTypeInput | PropertyLookupCreateOrConnectWithoutPropertyTypeInput[]
    createMany?: PropertyLookupCreateManyPropertyTypeInputEnvelope
    connect?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
  }

  export type PropertyGroupMembershipUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutPropertyTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput> | PropertyGroupMembershipCreateWithoutPropertyTypeInput[] | PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutPropertyTypeInput | PropertyGroupMembershipCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyGroupMembershipUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyGroupMembershipUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyGroupMembershipCreateManyPropertyTypeInputEnvelope
    set?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    disconnect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    delete?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    update?: PropertyGroupMembershipUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyGroupMembershipUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyGroupMembershipUpdateManyWithWhereWithoutPropertyTypeInput | PropertyGroupMembershipUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyGroupMembershipScalarWhereInput | PropertyGroupMembershipScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyTypeInput | PropertyUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyLookupUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyLookupCreateWithoutPropertyTypeInput, PropertyLookupUncheckedCreateWithoutPropertyTypeInput> | PropertyLookupCreateWithoutPropertyTypeInput[] | PropertyLookupUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyLookupCreateOrConnectWithoutPropertyTypeInput | PropertyLookupCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyLookupUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyLookupUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyLookupCreateManyPropertyTypeInputEnvelope
    set?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
    disconnect?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
    delete?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
    connect?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
    update?: PropertyLookupUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyLookupUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyLookupUpdateManyWithWhereWithoutPropertyTypeInput | PropertyLookupUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyLookupScalarWhereInput | PropertyLookupScalarWhereInput[]
  }

  export type PropertyGroupMembershipUncheckedUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutPropertyTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput> | PropertyGroupMembershipCreateWithoutPropertyTypeInput[] | PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutPropertyTypeInput | PropertyGroupMembershipCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyGroupMembershipUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyGroupMembershipUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyGroupMembershipCreateManyPropertyTypeInputEnvelope
    set?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    disconnect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    delete?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    update?: PropertyGroupMembershipUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyGroupMembershipUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyGroupMembershipUpdateManyWithWhereWithoutPropertyTypeInput | PropertyGroupMembershipUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyGroupMembershipScalarWhereInput | PropertyGroupMembershipScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput> | PropertyCreateWithoutPropertyTypeInput[] | PropertyUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTypeInput | PropertyCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyCreateManyPropertyTypeInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyTypeInput | PropertyUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyLookupUncheckedUpdateManyWithoutPropertyTypeNestedInput = {
    create?: XOR<PropertyLookupCreateWithoutPropertyTypeInput, PropertyLookupUncheckedCreateWithoutPropertyTypeInput> | PropertyLookupCreateWithoutPropertyTypeInput[] | PropertyLookupUncheckedCreateWithoutPropertyTypeInput[]
    connectOrCreate?: PropertyLookupCreateOrConnectWithoutPropertyTypeInput | PropertyLookupCreateOrConnectWithoutPropertyTypeInput[]
    upsert?: PropertyLookupUpsertWithWhereUniqueWithoutPropertyTypeInput | PropertyLookupUpsertWithWhereUniqueWithoutPropertyTypeInput[]
    createMany?: PropertyLookupCreateManyPropertyTypeInputEnvelope
    set?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
    disconnect?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
    delete?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
    connect?: PropertyLookupWhereUniqueInput | PropertyLookupWhereUniqueInput[]
    update?: PropertyLookupUpdateWithWhereUniqueWithoutPropertyTypeInput | PropertyLookupUpdateWithWhereUniqueWithoutPropertyTypeInput[]
    updateMany?: PropertyLookupUpdateManyWithWhereWithoutPropertyTypeInput | PropertyLookupUpdateManyWithWhereWithoutPropertyTypeInput[]
    deleteMany?: PropertyLookupScalarWhereInput | PropertyLookupScalarWhereInput[]
  }

  export type PropertyTypeCreateNestedOneWithoutLookupValuesInput = {
    create?: XOR<PropertyTypeCreateWithoutLookupValuesInput, PropertyTypeUncheckedCreateWithoutLookupValuesInput>
    connectOrCreate?: PropertyTypeCreateOrConnectWithoutLookupValuesInput
    connect?: PropertyTypeWhereUniqueInput
  }

  export type PropertyTypeUpdateOneWithoutLookupValuesNestedInput = {
    create?: XOR<PropertyTypeCreateWithoutLookupValuesInput, PropertyTypeUncheckedCreateWithoutLookupValuesInput>
    connectOrCreate?: PropertyTypeCreateOrConnectWithoutLookupValuesInput
    upsert?: PropertyTypeUpsertWithoutLookupValuesInput
    disconnect?: PropertyTypeWhereInput | boolean
    delete?: PropertyTypeWhereInput | boolean
    connect?: PropertyTypeWhereUniqueInput
    update?: XOR<XOR<PropertyTypeUpdateToOneWithWhereWithoutLookupValuesInput, PropertyTypeUpdateWithoutLookupValuesInput>, PropertyTypeUncheckedUpdateWithoutLookupValuesInput>
  }

  export type PartClassMembershipCreateNestedManyWithoutPartClassInput = {
    create?: XOR<PartClassMembershipCreateWithoutPartClassInput, PartClassMembershipUncheckedCreateWithoutPartClassInput> | PartClassMembershipCreateWithoutPartClassInput[] | PartClassMembershipUncheckedCreateWithoutPartClassInput[]
    connectOrCreate?: PartClassMembershipCreateOrConnectWithoutPartClassInput | PartClassMembershipCreateOrConnectWithoutPartClassInput[]
    createMany?: PartClassMembershipCreateManyPartClassInputEnvelope
    connect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
  }

  export type PartClassMembershipUncheckedCreateNestedManyWithoutPartClassInput = {
    create?: XOR<PartClassMembershipCreateWithoutPartClassInput, PartClassMembershipUncheckedCreateWithoutPartClassInput> | PartClassMembershipCreateWithoutPartClassInput[] | PartClassMembershipUncheckedCreateWithoutPartClassInput[]
    connectOrCreate?: PartClassMembershipCreateOrConnectWithoutPartClassInput | PartClassMembershipCreateOrConnectWithoutPartClassInput[]
    createMany?: PartClassMembershipCreateManyPartClassInputEnvelope
    connect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
  }

  export type PartClassMembershipUpdateManyWithoutPartClassNestedInput = {
    create?: XOR<PartClassMembershipCreateWithoutPartClassInput, PartClassMembershipUncheckedCreateWithoutPartClassInput> | PartClassMembershipCreateWithoutPartClassInput[] | PartClassMembershipUncheckedCreateWithoutPartClassInput[]
    connectOrCreate?: PartClassMembershipCreateOrConnectWithoutPartClassInput | PartClassMembershipCreateOrConnectWithoutPartClassInput[]
    upsert?: PartClassMembershipUpsertWithWhereUniqueWithoutPartClassInput | PartClassMembershipUpsertWithWhereUniqueWithoutPartClassInput[]
    createMany?: PartClassMembershipCreateManyPartClassInputEnvelope
    set?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    disconnect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    delete?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    connect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    update?: PartClassMembershipUpdateWithWhereUniqueWithoutPartClassInput | PartClassMembershipUpdateWithWhereUniqueWithoutPartClassInput[]
    updateMany?: PartClassMembershipUpdateManyWithWhereWithoutPartClassInput | PartClassMembershipUpdateManyWithWhereWithoutPartClassInput[]
    deleteMany?: PartClassMembershipScalarWhereInput | PartClassMembershipScalarWhereInput[]
  }

  export type PartClassMembershipUncheckedUpdateManyWithoutPartClassNestedInput = {
    create?: XOR<PartClassMembershipCreateWithoutPartClassInput, PartClassMembershipUncheckedCreateWithoutPartClassInput> | PartClassMembershipCreateWithoutPartClassInput[] | PartClassMembershipUncheckedCreateWithoutPartClassInput[]
    connectOrCreate?: PartClassMembershipCreateOrConnectWithoutPartClassInput | PartClassMembershipCreateOrConnectWithoutPartClassInput[]
    upsert?: PartClassMembershipUpsertWithWhereUniqueWithoutPartClassInput | PartClassMembershipUpsertWithWhereUniqueWithoutPartClassInput[]
    createMany?: PartClassMembershipCreateManyPartClassInputEnvelope
    set?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    disconnect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    delete?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    connect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    update?: PartClassMembershipUpdateWithWhereUniqueWithoutPartClassInput | PartClassMembershipUpdateWithWhereUniqueWithoutPartClassInput[]
    updateMany?: PartClassMembershipUpdateManyWithWhereWithoutPartClassInput | PartClassMembershipUpdateManyWithWhereWithoutPartClassInput[]
    deleteMany?: PartClassMembershipScalarWhereInput | PartClassMembershipScalarWhereInput[]
  }

  export type PartClassCreateNestedOneWithoutPartTypesInput = {
    create?: XOR<PartClassCreateWithoutPartTypesInput, PartClassUncheckedCreateWithoutPartTypesInput>
    connectOrCreate?: PartClassCreateOrConnectWithoutPartTypesInput
    connect?: PartClassWhereUniqueInput
  }

  export type PartTypeCreateNestedOneWithoutClassesInput = {
    create?: XOR<PartTypeCreateWithoutClassesInput, PartTypeUncheckedCreateWithoutClassesInput>
    connectOrCreate?: PartTypeCreateOrConnectWithoutClassesInput
    connect?: PartTypeWhereUniqueInput
  }

  export type PartClassUpdateOneWithoutPartTypesNestedInput = {
    create?: XOR<PartClassCreateWithoutPartTypesInput, PartClassUncheckedCreateWithoutPartTypesInput>
    connectOrCreate?: PartClassCreateOrConnectWithoutPartTypesInput
    upsert?: PartClassUpsertWithoutPartTypesInput
    disconnect?: PartClassWhereInput | boolean
    delete?: PartClassWhereInput | boolean
    connect?: PartClassWhereUniqueInput
    update?: XOR<XOR<PartClassUpdateToOneWithWhereWithoutPartTypesInput, PartClassUpdateWithoutPartTypesInput>, PartClassUncheckedUpdateWithoutPartTypesInput>
  }

  export type PartTypeUpdateOneWithoutClassesNestedInput = {
    create?: XOR<PartTypeCreateWithoutClassesInput, PartTypeUncheckedCreateWithoutClassesInput>
    connectOrCreate?: PartTypeCreateOrConnectWithoutClassesInput
    upsert?: PartTypeUpsertWithoutClassesInput
    disconnect?: PartTypeWhereInput | boolean
    delete?: PartTypeWhereInput | boolean
    connect?: PartTypeWhereUniqueInput
    update?: XOR<XOR<PartTypeUpdateToOneWithWhereWithoutClassesInput, PartTypeUpdateWithoutClassesInput>, PartTypeUncheckedUpdateWithoutClassesInput>
  }

  export type PropertyGroupMembershipCreateNestedManyWithoutPartTypeInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutPartTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput> | PropertyGroupMembershipCreateWithoutPartTypeInput[] | PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutPartTypeInput | PropertyGroupMembershipCreateOrConnectWithoutPartTypeInput[]
    createMany?: PropertyGroupMembershipCreateManyPartTypeInputEnvelope
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
  }

  export type PartClassMembershipCreateNestedManyWithoutPartTypeInput = {
    create?: XOR<PartClassMembershipCreateWithoutPartTypeInput, PartClassMembershipUncheckedCreateWithoutPartTypeInput> | PartClassMembershipCreateWithoutPartTypeInput[] | PartClassMembershipUncheckedCreateWithoutPartTypeInput[]
    connectOrCreate?: PartClassMembershipCreateOrConnectWithoutPartTypeInput | PartClassMembershipCreateOrConnectWithoutPartTypeInput[]
    createMany?: PartClassMembershipCreateManyPartTypeInputEnvelope
    connect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
  }

  export type PropertyGroupMembershipUncheckedCreateNestedManyWithoutPartTypeInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutPartTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput> | PropertyGroupMembershipCreateWithoutPartTypeInput[] | PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutPartTypeInput | PropertyGroupMembershipCreateOrConnectWithoutPartTypeInput[]
    createMany?: PropertyGroupMembershipCreateManyPartTypeInputEnvelope
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
  }

  export type PartClassMembershipUncheckedCreateNestedManyWithoutPartTypeInput = {
    create?: XOR<PartClassMembershipCreateWithoutPartTypeInput, PartClassMembershipUncheckedCreateWithoutPartTypeInput> | PartClassMembershipCreateWithoutPartTypeInput[] | PartClassMembershipUncheckedCreateWithoutPartTypeInput[]
    connectOrCreate?: PartClassMembershipCreateOrConnectWithoutPartTypeInput | PartClassMembershipCreateOrConnectWithoutPartTypeInput[]
    createMany?: PartClassMembershipCreateManyPartTypeInputEnvelope
    connect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
  }

  export type PropertyGroupMembershipUpdateManyWithoutPartTypeNestedInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutPartTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput> | PropertyGroupMembershipCreateWithoutPartTypeInput[] | PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutPartTypeInput | PropertyGroupMembershipCreateOrConnectWithoutPartTypeInput[]
    upsert?: PropertyGroupMembershipUpsertWithWhereUniqueWithoutPartTypeInput | PropertyGroupMembershipUpsertWithWhereUniqueWithoutPartTypeInput[]
    createMany?: PropertyGroupMembershipCreateManyPartTypeInputEnvelope
    set?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    disconnect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    delete?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    update?: PropertyGroupMembershipUpdateWithWhereUniqueWithoutPartTypeInput | PropertyGroupMembershipUpdateWithWhereUniqueWithoutPartTypeInput[]
    updateMany?: PropertyGroupMembershipUpdateManyWithWhereWithoutPartTypeInput | PropertyGroupMembershipUpdateManyWithWhereWithoutPartTypeInput[]
    deleteMany?: PropertyGroupMembershipScalarWhereInput | PropertyGroupMembershipScalarWhereInput[]
  }

  export type PartClassMembershipUpdateManyWithoutPartTypeNestedInput = {
    create?: XOR<PartClassMembershipCreateWithoutPartTypeInput, PartClassMembershipUncheckedCreateWithoutPartTypeInput> | PartClassMembershipCreateWithoutPartTypeInput[] | PartClassMembershipUncheckedCreateWithoutPartTypeInput[]
    connectOrCreate?: PartClassMembershipCreateOrConnectWithoutPartTypeInput | PartClassMembershipCreateOrConnectWithoutPartTypeInput[]
    upsert?: PartClassMembershipUpsertWithWhereUniqueWithoutPartTypeInput | PartClassMembershipUpsertWithWhereUniqueWithoutPartTypeInput[]
    createMany?: PartClassMembershipCreateManyPartTypeInputEnvelope
    set?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    disconnect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    delete?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    connect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    update?: PartClassMembershipUpdateWithWhereUniqueWithoutPartTypeInput | PartClassMembershipUpdateWithWhereUniqueWithoutPartTypeInput[]
    updateMany?: PartClassMembershipUpdateManyWithWhereWithoutPartTypeInput | PartClassMembershipUpdateManyWithWhereWithoutPartTypeInput[]
    deleteMany?: PartClassMembershipScalarWhereInput | PartClassMembershipScalarWhereInput[]
  }

  export type PropertyGroupMembershipUncheckedUpdateManyWithoutPartTypeNestedInput = {
    create?: XOR<PropertyGroupMembershipCreateWithoutPartTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput> | PropertyGroupMembershipCreateWithoutPartTypeInput[] | PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput[]
    connectOrCreate?: PropertyGroupMembershipCreateOrConnectWithoutPartTypeInput | PropertyGroupMembershipCreateOrConnectWithoutPartTypeInput[]
    upsert?: PropertyGroupMembershipUpsertWithWhereUniqueWithoutPartTypeInput | PropertyGroupMembershipUpsertWithWhereUniqueWithoutPartTypeInput[]
    createMany?: PropertyGroupMembershipCreateManyPartTypeInputEnvelope
    set?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    disconnect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    delete?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    connect?: PropertyGroupMembershipWhereUniqueInput | PropertyGroupMembershipWhereUniqueInput[]
    update?: PropertyGroupMembershipUpdateWithWhereUniqueWithoutPartTypeInput | PropertyGroupMembershipUpdateWithWhereUniqueWithoutPartTypeInput[]
    updateMany?: PropertyGroupMembershipUpdateManyWithWhereWithoutPartTypeInput | PropertyGroupMembershipUpdateManyWithWhereWithoutPartTypeInput[]
    deleteMany?: PropertyGroupMembershipScalarWhereInput | PropertyGroupMembershipScalarWhereInput[]
  }

  export type PartClassMembershipUncheckedUpdateManyWithoutPartTypeNestedInput = {
    create?: XOR<PartClassMembershipCreateWithoutPartTypeInput, PartClassMembershipUncheckedCreateWithoutPartTypeInput> | PartClassMembershipCreateWithoutPartTypeInput[] | PartClassMembershipUncheckedCreateWithoutPartTypeInput[]
    connectOrCreate?: PartClassMembershipCreateOrConnectWithoutPartTypeInput | PartClassMembershipCreateOrConnectWithoutPartTypeInput[]
    upsert?: PartClassMembershipUpsertWithWhereUniqueWithoutPartTypeInput | PartClassMembershipUpsertWithWhereUniqueWithoutPartTypeInput[]
    createMany?: PartClassMembershipCreateManyPartTypeInputEnvelope
    set?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    disconnect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    delete?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    connect?: PartClassMembershipWhereUniqueInput | PartClassMembershipWhereUniqueInput[]
    update?: PartClassMembershipUpdateWithWhereUniqueWithoutPartTypeInput | PartClassMembershipUpdateWithWhereUniqueWithoutPartTypeInput[]
    updateMany?: PartClassMembershipUpdateManyWithWhereWithoutPartTypeInput | PartClassMembershipUpdateManyWithWhereWithoutPartTypeInput[]
    deleteMany?: PartClassMembershipScalarWhereInput | PartClassMembershipScalarWhereInput[]
  }

  export type PartGroupMembershipCreateNestedManyWithoutGroupInput = {
    create?: XOR<PartGroupMembershipCreateWithoutGroupInput, PartGroupMembershipUncheckedCreateWithoutGroupInput> | PartGroupMembershipCreateWithoutGroupInput[] | PartGroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PartGroupMembershipCreateOrConnectWithoutGroupInput | PartGroupMembershipCreateOrConnectWithoutGroupInput[]
    createMany?: PartGroupMembershipCreateManyGroupInputEnvelope
    connect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
  }

  export type PartGroupMembershipUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<PartGroupMembershipCreateWithoutGroupInput, PartGroupMembershipUncheckedCreateWithoutGroupInput> | PartGroupMembershipCreateWithoutGroupInput[] | PartGroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PartGroupMembershipCreateOrConnectWithoutGroupInput | PartGroupMembershipCreateOrConnectWithoutGroupInput[]
    createMany?: PartGroupMembershipCreateManyGroupInputEnvelope
    connect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
  }

  export type PartGroupMembershipUpdateManyWithoutGroupNestedInput = {
    create?: XOR<PartGroupMembershipCreateWithoutGroupInput, PartGroupMembershipUncheckedCreateWithoutGroupInput> | PartGroupMembershipCreateWithoutGroupInput[] | PartGroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PartGroupMembershipCreateOrConnectWithoutGroupInput | PartGroupMembershipCreateOrConnectWithoutGroupInput[]
    upsert?: PartGroupMembershipUpsertWithWhereUniqueWithoutGroupInput | PartGroupMembershipUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: PartGroupMembershipCreateManyGroupInputEnvelope
    set?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    disconnect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    delete?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    connect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    update?: PartGroupMembershipUpdateWithWhereUniqueWithoutGroupInput | PartGroupMembershipUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: PartGroupMembershipUpdateManyWithWhereWithoutGroupInput | PartGroupMembershipUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: PartGroupMembershipScalarWhereInput | PartGroupMembershipScalarWhereInput[]
  }

  export type PartGroupMembershipUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<PartGroupMembershipCreateWithoutGroupInput, PartGroupMembershipUncheckedCreateWithoutGroupInput> | PartGroupMembershipCreateWithoutGroupInput[] | PartGroupMembershipUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PartGroupMembershipCreateOrConnectWithoutGroupInput | PartGroupMembershipCreateOrConnectWithoutGroupInput[]
    upsert?: PartGroupMembershipUpsertWithWhereUniqueWithoutGroupInput | PartGroupMembershipUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: PartGroupMembershipCreateManyGroupInputEnvelope
    set?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    disconnect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    delete?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    connect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    update?: PartGroupMembershipUpdateWithWhereUniqueWithoutGroupInput | PartGroupMembershipUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: PartGroupMembershipUpdateManyWithWhereWithoutGroupInput | PartGroupMembershipUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: PartGroupMembershipScalarWhereInput | PartGroupMembershipScalarWhereInput[]
  }

  export type PartCreateNestedOneWithoutGroupsInput = {
    create?: XOR<PartCreateWithoutGroupsInput, PartUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: PartCreateOrConnectWithoutGroupsInput
    connect?: PartWhereUniqueInput
  }

  export type PartGroupCreateNestedOneWithoutPartsInput = {
    create?: XOR<PartGroupCreateWithoutPartsInput, PartGroupUncheckedCreateWithoutPartsInput>
    connectOrCreate?: PartGroupCreateOrConnectWithoutPartsInput
    connect?: PartGroupWhereUniqueInput
  }

  export type PartUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<PartCreateWithoutGroupsInput, PartUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: PartCreateOrConnectWithoutGroupsInput
    upsert?: PartUpsertWithoutGroupsInput
    disconnect?: PartWhereInput | boolean
    delete?: PartWhereInput | boolean
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutGroupsInput, PartUpdateWithoutGroupsInput>, PartUncheckedUpdateWithoutGroupsInput>
  }

  export type PartGroupUpdateOneWithoutPartsNestedInput = {
    create?: XOR<PartGroupCreateWithoutPartsInput, PartGroupUncheckedCreateWithoutPartsInput>
    connectOrCreate?: PartGroupCreateOrConnectWithoutPartsInput
    upsert?: PartGroupUpsertWithoutPartsInput
    disconnect?: PartGroupWhereInput | boolean
    delete?: PartGroupWhereInput | boolean
    connect?: PartGroupWhereUniqueInput
    update?: XOR<XOR<PartGroupUpdateToOneWithWhereWithoutPartsInput, PartGroupUpdateWithoutPartsInput>, PartGroupUncheckedUpdateWithoutPartsInput>
  }

  export type ProductLineCreateNestedOneWithoutItemsInput = {
    create?: XOR<ProductLineCreateWithoutItemsInput, ProductLineUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProductLineCreateOrConnectWithoutItemsInput
    connect?: ProductLineWhereUniqueInput
  }

  export type WheelCreateNestedManyWithoutHubInput = {
    create?: XOR<WheelCreateWithoutHubInput, WheelUncheckedCreateWithoutHubInput> | WheelCreateWithoutHubInput[] | WheelUncheckedCreateWithoutHubInput[]
    connectOrCreate?: WheelCreateOrConnectWithoutHubInput | WheelCreateOrConnectWithoutHubInput[]
    createMany?: WheelCreateManyHubInputEnvelope
    connect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
  }

  export type WheelCreateNestedManyWithoutRimInput = {
    create?: XOR<WheelCreateWithoutRimInput, WheelUncheckedCreateWithoutRimInput> | WheelCreateWithoutRimInput[] | WheelUncheckedCreateWithoutRimInput[]
    connectOrCreate?: WheelCreateOrConnectWithoutRimInput | WheelCreateOrConnectWithoutRimInput[]
    createMany?: WheelCreateManyRimInputEnvelope
    connect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
  }

  export type WheelSpokeCreateNestedManyWithoutSpokeInput = {
    create?: XOR<WheelSpokeCreateWithoutSpokeInput, WheelSpokeUncheckedCreateWithoutSpokeInput> | WheelSpokeCreateWithoutSpokeInput[] | WheelSpokeUncheckedCreateWithoutSpokeInput[]
    connectOrCreate?: WheelSpokeCreateOrConnectWithoutSpokeInput | WheelSpokeCreateOrConnectWithoutSpokeInput[]
    createMany?: WheelSpokeCreateManySpokeInputEnvelope
    connect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutPartInput = {
    create?: XOR<PropertyCreateWithoutPartInput, PropertyUncheckedCreateWithoutPartInput> | PropertyCreateWithoutPartInput[] | PropertyUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPartInput | PropertyCreateOrConnectWithoutPartInput[]
    createMany?: PropertyCreateManyPartInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type ClaimCreateNestedManyWithoutPartInput = {
    create?: XOR<ClaimCreateWithoutPartInput, ClaimUncheckedCreateWithoutPartInput> | ClaimCreateWithoutPartInput[] | ClaimUncheckedCreateWithoutPartInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutPartInput | ClaimCreateOrConnectWithoutPartInput[]
    createMany?: ClaimCreateManyPartInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type PartGroupMembershipCreateNestedManyWithoutPartInput = {
    create?: XOR<PartGroupMembershipCreateWithoutPartInput, PartGroupMembershipUncheckedCreateWithoutPartInput> | PartGroupMembershipCreateWithoutPartInput[] | PartGroupMembershipUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PartGroupMembershipCreateOrConnectWithoutPartInput | PartGroupMembershipCreateOrConnectWithoutPartInput[]
    createMany?: PartGroupMembershipCreateManyPartInputEnvelope
    connect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
  }

  export type BuildPartCreateNestedManyWithoutPartInput = {
    create?: XOR<BuildPartCreateWithoutPartInput, BuildPartUncheckedCreateWithoutPartInput> | BuildPartCreateWithoutPartInput[] | BuildPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: BuildPartCreateOrConnectWithoutPartInput | BuildPartCreateOrConnectWithoutPartInput[]
    createMany?: BuildPartCreateManyPartInputEnvelope
    connect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
  }

  export type WheelUncheckedCreateNestedManyWithoutHubInput = {
    create?: XOR<WheelCreateWithoutHubInput, WheelUncheckedCreateWithoutHubInput> | WheelCreateWithoutHubInput[] | WheelUncheckedCreateWithoutHubInput[]
    connectOrCreate?: WheelCreateOrConnectWithoutHubInput | WheelCreateOrConnectWithoutHubInput[]
    createMany?: WheelCreateManyHubInputEnvelope
    connect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
  }

  export type WheelUncheckedCreateNestedManyWithoutRimInput = {
    create?: XOR<WheelCreateWithoutRimInput, WheelUncheckedCreateWithoutRimInput> | WheelCreateWithoutRimInput[] | WheelUncheckedCreateWithoutRimInput[]
    connectOrCreate?: WheelCreateOrConnectWithoutRimInput | WheelCreateOrConnectWithoutRimInput[]
    createMany?: WheelCreateManyRimInputEnvelope
    connect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
  }

  export type WheelSpokeUncheckedCreateNestedManyWithoutSpokeInput = {
    create?: XOR<WheelSpokeCreateWithoutSpokeInput, WheelSpokeUncheckedCreateWithoutSpokeInput> | WheelSpokeCreateWithoutSpokeInput[] | WheelSpokeUncheckedCreateWithoutSpokeInput[]
    connectOrCreate?: WheelSpokeCreateOrConnectWithoutSpokeInput | WheelSpokeCreateOrConnectWithoutSpokeInput[]
    createMany?: WheelSpokeCreateManySpokeInputEnvelope
    connect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<PropertyCreateWithoutPartInput, PropertyUncheckedCreateWithoutPartInput> | PropertyCreateWithoutPartInput[] | PropertyUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPartInput | PropertyCreateOrConnectWithoutPartInput[]
    createMany?: PropertyCreateManyPartInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<ClaimCreateWithoutPartInput, ClaimUncheckedCreateWithoutPartInput> | ClaimCreateWithoutPartInput[] | ClaimUncheckedCreateWithoutPartInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutPartInput | ClaimCreateOrConnectWithoutPartInput[]
    createMany?: ClaimCreateManyPartInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type PartGroupMembershipUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<PartGroupMembershipCreateWithoutPartInput, PartGroupMembershipUncheckedCreateWithoutPartInput> | PartGroupMembershipCreateWithoutPartInput[] | PartGroupMembershipUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PartGroupMembershipCreateOrConnectWithoutPartInput | PartGroupMembershipCreateOrConnectWithoutPartInput[]
    createMany?: PartGroupMembershipCreateManyPartInputEnvelope
    connect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
  }

  export type BuildPartUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<BuildPartCreateWithoutPartInput, BuildPartUncheckedCreateWithoutPartInput> | BuildPartCreateWithoutPartInput[] | BuildPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: BuildPartCreateOrConnectWithoutPartInput | BuildPartCreateOrConnectWithoutPartInput[]
    createMany?: BuildPartCreateManyPartInputEnvelope
    connect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProductLineUpdateOneWithoutItemsNestedInput = {
    create?: XOR<ProductLineCreateWithoutItemsInput, ProductLineUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProductLineCreateOrConnectWithoutItemsInput
    upsert?: ProductLineUpsertWithoutItemsInput
    disconnect?: ProductLineWhereInput | boolean
    delete?: ProductLineWhereInput | boolean
    connect?: ProductLineWhereUniqueInput
    update?: XOR<XOR<ProductLineUpdateToOneWithWhereWithoutItemsInput, ProductLineUpdateWithoutItemsInput>, ProductLineUncheckedUpdateWithoutItemsInput>
  }

  export type WheelUpdateManyWithoutHubNestedInput = {
    create?: XOR<WheelCreateWithoutHubInput, WheelUncheckedCreateWithoutHubInput> | WheelCreateWithoutHubInput[] | WheelUncheckedCreateWithoutHubInput[]
    connectOrCreate?: WheelCreateOrConnectWithoutHubInput | WheelCreateOrConnectWithoutHubInput[]
    upsert?: WheelUpsertWithWhereUniqueWithoutHubInput | WheelUpsertWithWhereUniqueWithoutHubInput[]
    createMany?: WheelCreateManyHubInputEnvelope
    set?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    disconnect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    delete?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    connect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    update?: WheelUpdateWithWhereUniqueWithoutHubInput | WheelUpdateWithWhereUniqueWithoutHubInput[]
    updateMany?: WheelUpdateManyWithWhereWithoutHubInput | WheelUpdateManyWithWhereWithoutHubInput[]
    deleteMany?: WheelScalarWhereInput | WheelScalarWhereInput[]
  }

  export type WheelUpdateManyWithoutRimNestedInput = {
    create?: XOR<WheelCreateWithoutRimInput, WheelUncheckedCreateWithoutRimInput> | WheelCreateWithoutRimInput[] | WheelUncheckedCreateWithoutRimInput[]
    connectOrCreate?: WheelCreateOrConnectWithoutRimInput | WheelCreateOrConnectWithoutRimInput[]
    upsert?: WheelUpsertWithWhereUniqueWithoutRimInput | WheelUpsertWithWhereUniqueWithoutRimInput[]
    createMany?: WheelCreateManyRimInputEnvelope
    set?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    disconnect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    delete?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    connect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    update?: WheelUpdateWithWhereUniqueWithoutRimInput | WheelUpdateWithWhereUniqueWithoutRimInput[]
    updateMany?: WheelUpdateManyWithWhereWithoutRimInput | WheelUpdateManyWithWhereWithoutRimInput[]
    deleteMany?: WheelScalarWhereInput | WheelScalarWhereInput[]
  }

  export type WheelSpokeUpdateManyWithoutSpokeNestedInput = {
    create?: XOR<WheelSpokeCreateWithoutSpokeInput, WheelSpokeUncheckedCreateWithoutSpokeInput> | WheelSpokeCreateWithoutSpokeInput[] | WheelSpokeUncheckedCreateWithoutSpokeInput[]
    connectOrCreate?: WheelSpokeCreateOrConnectWithoutSpokeInput | WheelSpokeCreateOrConnectWithoutSpokeInput[]
    upsert?: WheelSpokeUpsertWithWhereUniqueWithoutSpokeInput | WheelSpokeUpsertWithWhereUniqueWithoutSpokeInput[]
    createMany?: WheelSpokeCreateManySpokeInputEnvelope
    set?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    disconnect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    delete?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    connect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    update?: WheelSpokeUpdateWithWhereUniqueWithoutSpokeInput | WheelSpokeUpdateWithWhereUniqueWithoutSpokeInput[]
    updateMany?: WheelSpokeUpdateManyWithWhereWithoutSpokeInput | WheelSpokeUpdateManyWithWhereWithoutSpokeInput[]
    deleteMany?: WheelSpokeScalarWhereInput | WheelSpokeScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutPartNestedInput = {
    create?: XOR<PropertyCreateWithoutPartInput, PropertyUncheckedCreateWithoutPartInput> | PropertyCreateWithoutPartInput[] | PropertyUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPartInput | PropertyCreateOrConnectWithoutPartInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPartInput | PropertyUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: PropertyCreateManyPartInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPartInput | PropertyUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPartInput | PropertyUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type ClaimUpdateManyWithoutPartNestedInput = {
    create?: XOR<ClaimCreateWithoutPartInput, ClaimUncheckedCreateWithoutPartInput> | ClaimCreateWithoutPartInput[] | ClaimUncheckedCreateWithoutPartInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutPartInput | ClaimCreateOrConnectWithoutPartInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutPartInput | ClaimUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: ClaimCreateManyPartInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutPartInput | ClaimUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutPartInput | ClaimUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type PartGroupMembershipUpdateManyWithoutPartNestedInput = {
    create?: XOR<PartGroupMembershipCreateWithoutPartInput, PartGroupMembershipUncheckedCreateWithoutPartInput> | PartGroupMembershipCreateWithoutPartInput[] | PartGroupMembershipUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PartGroupMembershipCreateOrConnectWithoutPartInput | PartGroupMembershipCreateOrConnectWithoutPartInput[]
    upsert?: PartGroupMembershipUpsertWithWhereUniqueWithoutPartInput | PartGroupMembershipUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: PartGroupMembershipCreateManyPartInputEnvelope
    set?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    disconnect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    delete?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    connect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    update?: PartGroupMembershipUpdateWithWhereUniqueWithoutPartInput | PartGroupMembershipUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: PartGroupMembershipUpdateManyWithWhereWithoutPartInput | PartGroupMembershipUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: PartGroupMembershipScalarWhereInput | PartGroupMembershipScalarWhereInput[]
  }

  export type BuildPartUpdateManyWithoutPartNestedInput = {
    create?: XOR<BuildPartCreateWithoutPartInput, BuildPartUncheckedCreateWithoutPartInput> | BuildPartCreateWithoutPartInput[] | BuildPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: BuildPartCreateOrConnectWithoutPartInput | BuildPartCreateOrConnectWithoutPartInput[]
    upsert?: BuildPartUpsertWithWhereUniqueWithoutPartInput | BuildPartUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: BuildPartCreateManyPartInputEnvelope
    set?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    disconnect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    delete?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    connect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    update?: BuildPartUpdateWithWhereUniqueWithoutPartInput | BuildPartUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: BuildPartUpdateManyWithWhereWithoutPartInput | BuildPartUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: BuildPartScalarWhereInput | BuildPartScalarWhereInput[]
  }

  export type WheelUncheckedUpdateManyWithoutHubNestedInput = {
    create?: XOR<WheelCreateWithoutHubInput, WheelUncheckedCreateWithoutHubInput> | WheelCreateWithoutHubInput[] | WheelUncheckedCreateWithoutHubInput[]
    connectOrCreate?: WheelCreateOrConnectWithoutHubInput | WheelCreateOrConnectWithoutHubInput[]
    upsert?: WheelUpsertWithWhereUniqueWithoutHubInput | WheelUpsertWithWhereUniqueWithoutHubInput[]
    createMany?: WheelCreateManyHubInputEnvelope
    set?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    disconnect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    delete?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    connect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    update?: WheelUpdateWithWhereUniqueWithoutHubInput | WheelUpdateWithWhereUniqueWithoutHubInput[]
    updateMany?: WheelUpdateManyWithWhereWithoutHubInput | WheelUpdateManyWithWhereWithoutHubInput[]
    deleteMany?: WheelScalarWhereInput | WheelScalarWhereInput[]
  }

  export type WheelUncheckedUpdateManyWithoutRimNestedInput = {
    create?: XOR<WheelCreateWithoutRimInput, WheelUncheckedCreateWithoutRimInput> | WheelCreateWithoutRimInput[] | WheelUncheckedCreateWithoutRimInput[]
    connectOrCreate?: WheelCreateOrConnectWithoutRimInput | WheelCreateOrConnectWithoutRimInput[]
    upsert?: WheelUpsertWithWhereUniqueWithoutRimInput | WheelUpsertWithWhereUniqueWithoutRimInput[]
    createMany?: WheelCreateManyRimInputEnvelope
    set?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    disconnect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    delete?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    connect?: WheelWhereUniqueInput | WheelWhereUniqueInput[]
    update?: WheelUpdateWithWhereUniqueWithoutRimInput | WheelUpdateWithWhereUniqueWithoutRimInput[]
    updateMany?: WheelUpdateManyWithWhereWithoutRimInput | WheelUpdateManyWithWhereWithoutRimInput[]
    deleteMany?: WheelScalarWhereInput | WheelScalarWhereInput[]
  }

  export type WheelSpokeUncheckedUpdateManyWithoutSpokeNestedInput = {
    create?: XOR<WheelSpokeCreateWithoutSpokeInput, WheelSpokeUncheckedCreateWithoutSpokeInput> | WheelSpokeCreateWithoutSpokeInput[] | WheelSpokeUncheckedCreateWithoutSpokeInput[]
    connectOrCreate?: WheelSpokeCreateOrConnectWithoutSpokeInput | WheelSpokeCreateOrConnectWithoutSpokeInput[]
    upsert?: WheelSpokeUpsertWithWhereUniqueWithoutSpokeInput | WheelSpokeUpsertWithWhereUniqueWithoutSpokeInput[]
    createMany?: WheelSpokeCreateManySpokeInputEnvelope
    set?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    disconnect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    delete?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    connect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    update?: WheelSpokeUpdateWithWhereUniqueWithoutSpokeInput | WheelSpokeUpdateWithWhereUniqueWithoutSpokeInput[]
    updateMany?: WheelSpokeUpdateManyWithWhereWithoutSpokeInput | WheelSpokeUpdateManyWithWhereWithoutSpokeInput[]
    deleteMany?: WheelSpokeScalarWhereInput | WheelSpokeScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<PropertyCreateWithoutPartInput, PropertyUncheckedCreateWithoutPartInput> | PropertyCreateWithoutPartInput[] | PropertyUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPartInput | PropertyCreateOrConnectWithoutPartInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPartInput | PropertyUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: PropertyCreateManyPartInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPartInput | PropertyUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPartInput | PropertyUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<ClaimCreateWithoutPartInput, ClaimUncheckedCreateWithoutPartInput> | ClaimCreateWithoutPartInput[] | ClaimUncheckedCreateWithoutPartInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutPartInput | ClaimCreateOrConnectWithoutPartInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutPartInput | ClaimUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: ClaimCreateManyPartInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutPartInput | ClaimUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutPartInput | ClaimUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type PartGroupMembershipUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<PartGroupMembershipCreateWithoutPartInput, PartGroupMembershipUncheckedCreateWithoutPartInput> | PartGroupMembershipCreateWithoutPartInput[] | PartGroupMembershipUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PartGroupMembershipCreateOrConnectWithoutPartInput | PartGroupMembershipCreateOrConnectWithoutPartInput[]
    upsert?: PartGroupMembershipUpsertWithWhereUniqueWithoutPartInput | PartGroupMembershipUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: PartGroupMembershipCreateManyPartInputEnvelope
    set?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    disconnect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    delete?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    connect?: PartGroupMembershipWhereUniqueInput | PartGroupMembershipWhereUniqueInput[]
    update?: PartGroupMembershipUpdateWithWhereUniqueWithoutPartInput | PartGroupMembershipUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: PartGroupMembershipUpdateManyWithWhereWithoutPartInput | PartGroupMembershipUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: PartGroupMembershipScalarWhereInput | PartGroupMembershipScalarWhereInput[]
  }

  export type BuildPartUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<BuildPartCreateWithoutPartInput, BuildPartUncheckedCreateWithoutPartInput> | BuildPartCreateWithoutPartInput[] | BuildPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: BuildPartCreateOrConnectWithoutPartInput | BuildPartCreateOrConnectWithoutPartInput[]
    upsert?: BuildPartUpsertWithWhereUniqueWithoutPartInput | BuildPartUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: BuildPartCreateManyPartInputEnvelope
    set?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    disconnect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    delete?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    connect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    update?: BuildPartUpdateWithWhereUniqueWithoutPartInput | BuildPartUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: BuildPartUpdateManyWithWhereWithoutPartInput | BuildPartUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: BuildPartScalarWhereInput | BuildPartScalarWhereInput[]
  }

  export type PartCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PartCreateWithoutPropertiesInput, PartUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PartCreateOrConnectWithoutPropertiesInput
    connect?: PartWhereUniqueInput
  }

  export type PropertyTypeCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyTypeCreateWithoutPropertiesInput, PropertyTypeUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyTypeCreateOrConnectWithoutPropertiesInput
    connect?: PropertyTypeWhereUniqueInput
  }

  export type PartUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PartCreateWithoutPropertiesInput, PartUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PartCreateOrConnectWithoutPropertiesInput
    upsert?: PartUpsertWithoutPropertiesInput
    disconnect?: PartWhereInput | boolean
    delete?: PartWhereInput | boolean
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutPropertiesInput, PartUpdateWithoutPropertiesInput>, PartUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyTypeUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertyTypeCreateWithoutPropertiesInput, PropertyTypeUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyTypeCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyTypeUpsertWithoutPropertiesInput
    disconnect?: PropertyTypeWhereInput | boolean
    delete?: PropertyTypeWhereInput | boolean
    connect?: PropertyTypeWhereUniqueInput
    update?: XOR<XOR<PropertyTypeUpdateToOneWithWhereWithoutPropertiesInput, PropertyTypeUpdateWithoutPropertiesInput>, PropertyTypeUncheckedUpdateWithoutPropertiesInput>
  }

  export type PartCreateNestedOneWithoutWheelSpokesInput = {
    create?: XOR<PartCreateWithoutWheelSpokesInput, PartUncheckedCreateWithoutWheelSpokesInput>
    connectOrCreate?: PartCreateOrConnectWithoutWheelSpokesInput
    connect?: PartWhereUniqueInput
  }

  export type WheelCreateNestedOneWithoutSpokesInput = {
    create?: XOR<WheelCreateWithoutSpokesInput, WheelUncheckedCreateWithoutSpokesInput>
    connectOrCreate?: WheelCreateOrConnectWithoutSpokesInput
    connect?: WheelWhereUniqueInput
  }

  export type PartUpdateOneWithoutWheelSpokesNestedInput = {
    create?: XOR<PartCreateWithoutWheelSpokesInput, PartUncheckedCreateWithoutWheelSpokesInput>
    connectOrCreate?: PartCreateOrConnectWithoutWheelSpokesInput
    upsert?: PartUpsertWithoutWheelSpokesInput
    disconnect?: PartWhereInput | boolean
    delete?: PartWhereInput | boolean
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutWheelSpokesInput, PartUpdateWithoutWheelSpokesInput>, PartUncheckedUpdateWithoutWheelSpokesInput>
  }

  export type WheelUpdateOneWithoutSpokesNestedInput = {
    create?: XOR<WheelCreateWithoutSpokesInput, WheelUncheckedCreateWithoutSpokesInput>
    connectOrCreate?: WheelCreateOrConnectWithoutSpokesInput
    upsert?: WheelUpsertWithoutSpokesInput
    disconnect?: WheelWhereInput | boolean
    delete?: WheelWhereInput | boolean
    connect?: WheelWhereUniqueInput
    update?: XOR<XOR<WheelUpdateToOneWithWhereWithoutSpokesInput, WheelUpdateWithoutSpokesInput>, WheelUncheckedUpdateWithoutSpokesInput>
  }

  export type PartCreateNestedOneWithoutWheelHubsInput = {
    create?: XOR<PartCreateWithoutWheelHubsInput, PartUncheckedCreateWithoutWheelHubsInput>
    connectOrCreate?: PartCreateOrConnectWithoutWheelHubsInput
    connect?: PartWhereUniqueInput
  }

  export type PartCreateNestedOneWithoutWheelRimsInput = {
    create?: XOR<PartCreateWithoutWheelRimsInput, PartUncheckedCreateWithoutWheelRimsInput>
    connectOrCreate?: PartCreateOrConnectWithoutWheelRimsInput
    connect?: PartWhereUniqueInput
  }

  export type WheelSpokeCreateNestedManyWithoutWheelInput = {
    create?: XOR<WheelSpokeCreateWithoutWheelInput, WheelSpokeUncheckedCreateWithoutWheelInput> | WheelSpokeCreateWithoutWheelInput[] | WheelSpokeUncheckedCreateWithoutWheelInput[]
    connectOrCreate?: WheelSpokeCreateOrConnectWithoutWheelInput | WheelSpokeCreateOrConnectWithoutWheelInput[]
    createMany?: WheelSpokeCreateManyWheelInputEnvelope
    connect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
  }

  export type WheelSpokeUncheckedCreateNestedManyWithoutWheelInput = {
    create?: XOR<WheelSpokeCreateWithoutWheelInput, WheelSpokeUncheckedCreateWithoutWheelInput> | WheelSpokeCreateWithoutWheelInput[] | WheelSpokeUncheckedCreateWithoutWheelInput[]
    connectOrCreate?: WheelSpokeCreateOrConnectWithoutWheelInput | WheelSpokeCreateOrConnectWithoutWheelInput[]
    createMany?: WheelSpokeCreateManyWheelInputEnvelope
    connect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
  }

  export type PartUpdateOneWithoutWheelHubsNestedInput = {
    create?: XOR<PartCreateWithoutWheelHubsInput, PartUncheckedCreateWithoutWheelHubsInput>
    connectOrCreate?: PartCreateOrConnectWithoutWheelHubsInput
    upsert?: PartUpsertWithoutWheelHubsInput
    disconnect?: PartWhereInput | boolean
    delete?: PartWhereInput | boolean
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutWheelHubsInput, PartUpdateWithoutWheelHubsInput>, PartUncheckedUpdateWithoutWheelHubsInput>
  }

  export type PartUpdateOneWithoutWheelRimsNestedInput = {
    create?: XOR<PartCreateWithoutWheelRimsInput, PartUncheckedCreateWithoutWheelRimsInput>
    connectOrCreate?: PartCreateOrConnectWithoutWheelRimsInput
    upsert?: PartUpsertWithoutWheelRimsInput
    disconnect?: PartWhereInput | boolean
    delete?: PartWhereInput | boolean
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutWheelRimsInput, PartUpdateWithoutWheelRimsInput>, PartUncheckedUpdateWithoutWheelRimsInput>
  }

  export type WheelSpokeUpdateManyWithoutWheelNestedInput = {
    create?: XOR<WheelSpokeCreateWithoutWheelInput, WheelSpokeUncheckedCreateWithoutWheelInput> | WheelSpokeCreateWithoutWheelInput[] | WheelSpokeUncheckedCreateWithoutWheelInput[]
    connectOrCreate?: WheelSpokeCreateOrConnectWithoutWheelInput | WheelSpokeCreateOrConnectWithoutWheelInput[]
    upsert?: WheelSpokeUpsertWithWhereUniqueWithoutWheelInput | WheelSpokeUpsertWithWhereUniqueWithoutWheelInput[]
    createMany?: WheelSpokeCreateManyWheelInputEnvelope
    set?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    disconnect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    delete?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    connect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    update?: WheelSpokeUpdateWithWhereUniqueWithoutWheelInput | WheelSpokeUpdateWithWhereUniqueWithoutWheelInput[]
    updateMany?: WheelSpokeUpdateManyWithWhereWithoutWheelInput | WheelSpokeUpdateManyWithWhereWithoutWheelInput[]
    deleteMany?: WheelSpokeScalarWhereInput | WheelSpokeScalarWhereInput[]
  }

  export type WheelSpokeUncheckedUpdateManyWithoutWheelNestedInput = {
    create?: XOR<WheelSpokeCreateWithoutWheelInput, WheelSpokeUncheckedCreateWithoutWheelInput> | WheelSpokeCreateWithoutWheelInput[] | WheelSpokeUncheckedCreateWithoutWheelInput[]
    connectOrCreate?: WheelSpokeCreateOrConnectWithoutWheelInput | WheelSpokeCreateOrConnectWithoutWheelInput[]
    upsert?: WheelSpokeUpsertWithWhereUniqueWithoutWheelInput | WheelSpokeUpsertWithWhereUniqueWithoutWheelInput[]
    createMany?: WheelSpokeCreateManyWheelInputEnvelope
    set?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    disconnect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    delete?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    connect?: WheelSpokeWhereUniqueInput | WheelSpokeWhereUniqueInput[]
    update?: WheelSpokeUpdateWithWhereUniqueWithoutWheelInput | WheelSpokeUpdateWithWhereUniqueWithoutWheelInput[]
    updateMany?: WheelSpokeUpdateManyWithWhereWithoutWheelInput | WheelSpokeUpdateManyWithWhereWithoutWheelInput[]
    deleteMany?: WheelSpokeScalarWhereInput | WheelSpokeScalarWhereInput[]
  }

  export type BuildCreateNestedOneWithoutPartsInput = {
    create?: XOR<BuildCreateWithoutPartsInput, BuildUncheckedCreateWithoutPartsInput>
    connectOrCreate?: BuildCreateOrConnectWithoutPartsInput
    connect?: BuildWhereUniqueInput
  }

  export type PartCreateNestedOneWithoutBuildsInput = {
    create?: XOR<PartCreateWithoutBuildsInput, PartUncheckedCreateWithoutBuildsInput>
    connectOrCreate?: PartCreateOrConnectWithoutBuildsInput
    connect?: PartWhereUniqueInput
  }

  export type BuildUpdateOneWithoutPartsNestedInput = {
    create?: XOR<BuildCreateWithoutPartsInput, BuildUncheckedCreateWithoutPartsInput>
    connectOrCreate?: BuildCreateOrConnectWithoutPartsInput
    upsert?: BuildUpsertWithoutPartsInput
    disconnect?: BuildWhereInput | boolean
    delete?: BuildWhereInput | boolean
    connect?: BuildWhereUniqueInput
    update?: XOR<XOR<BuildUpdateToOneWithWhereWithoutPartsInput, BuildUpdateWithoutPartsInput>, BuildUncheckedUpdateWithoutPartsInput>
  }

  export type PartUpdateOneWithoutBuildsNestedInput = {
    create?: XOR<PartCreateWithoutBuildsInput, PartUncheckedCreateWithoutBuildsInput>
    connectOrCreate?: PartCreateOrConnectWithoutBuildsInput
    upsert?: PartUpsertWithoutBuildsInput
    disconnect?: PartWhereInput | boolean
    delete?: PartWhereInput | boolean
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutBuildsInput, PartUpdateWithoutBuildsInput>, PartUncheckedUpdateWithoutBuildsInput>
  }

  export type BuildPartCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildPartCreateWithoutBuildInput, BuildPartUncheckedCreateWithoutBuildInput> | BuildPartCreateWithoutBuildInput[] | BuildPartUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildPartCreateOrConnectWithoutBuildInput | BuildPartCreateOrConnectWithoutBuildInput[]
    createMany?: BuildPartCreateManyBuildInputEnvelope
    connect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
  }

  export type BuildPartUncheckedCreateNestedManyWithoutBuildInput = {
    create?: XOR<BuildPartCreateWithoutBuildInput, BuildPartUncheckedCreateWithoutBuildInput> | BuildPartCreateWithoutBuildInput[] | BuildPartUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildPartCreateOrConnectWithoutBuildInput | BuildPartCreateOrConnectWithoutBuildInput[]
    createMany?: BuildPartCreateManyBuildInputEnvelope
    connect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
  }

  export type BuildPartUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildPartCreateWithoutBuildInput, BuildPartUncheckedCreateWithoutBuildInput> | BuildPartCreateWithoutBuildInput[] | BuildPartUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildPartCreateOrConnectWithoutBuildInput | BuildPartCreateOrConnectWithoutBuildInput[]
    upsert?: BuildPartUpsertWithWhereUniqueWithoutBuildInput | BuildPartUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildPartCreateManyBuildInputEnvelope
    set?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    disconnect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    delete?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    connect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    update?: BuildPartUpdateWithWhereUniqueWithoutBuildInput | BuildPartUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildPartUpdateManyWithWhereWithoutBuildInput | BuildPartUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildPartScalarWhereInput | BuildPartScalarWhereInput[]
  }

  export type BuildPartUncheckedUpdateManyWithoutBuildNestedInput = {
    create?: XOR<BuildPartCreateWithoutBuildInput, BuildPartUncheckedCreateWithoutBuildInput> | BuildPartCreateWithoutBuildInput[] | BuildPartUncheckedCreateWithoutBuildInput[]
    connectOrCreate?: BuildPartCreateOrConnectWithoutBuildInput | BuildPartCreateOrConnectWithoutBuildInput[]
    upsert?: BuildPartUpsertWithWhereUniqueWithoutBuildInput | BuildPartUpsertWithWhereUniqueWithoutBuildInput[]
    createMany?: BuildPartCreateManyBuildInputEnvelope
    set?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    disconnect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    delete?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    connect?: BuildPartWhereUniqueInput | BuildPartWhereUniqueInput[]
    update?: BuildPartUpdateWithWhereUniqueWithoutBuildInput | BuildPartUpdateWithWhereUniqueWithoutBuildInput[]
    updateMany?: BuildPartUpdateManyWithWhereWithoutBuildInput | BuildPartUpdateManyWithWhereWithoutBuildInput[]
    deleteMany?: BuildPartScalarWhereInput | BuildPartScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ClaimCreateWithoutOwnerInput = {
    claimType?: string | null
    acquired?: Date | string | null
    condition?: string | null
    notes?: string | null
    part?: PartCreateNestedOneWithoutClaimsInput
  }

  export type ClaimUncheckedCreateWithoutOwnerInput = {
    id?: number
    claimType?: string | null
    acquired?: Date | string | null
    condition?: string | null
    notes?: string | null
    partId?: number | null
  }

  export type ClaimCreateOrConnectWithoutOwnerInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutOwnerInput, ClaimUncheckedCreateWithoutOwnerInput>
  }

  export type ClaimCreateManyOwnerInputEnvelope = {
    data: ClaimCreateManyOwnerInput | ClaimCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ClaimUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutOwnerInput, ClaimUncheckedUpdateWithoutOwnerInput>
    create: XOR<ClaimCreateWithoutOwnerInput, ClaimUncheckedCreateWithoutOwnerInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutOwnerInput, ClaimUncheckedUpdateWithoutOwnerInput>
  }

  export type ClaimUpdateManyWithWhereWithoutOwnerInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ClaimScalarWhereInput = {
    AND?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    OR?: ClaimScalarWhereInput[]
    NOT?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    id?: IntFilter<"Claim"> | number
    claimType?: StringNullableFilter<"Claim"> | string | null
    acquired?: DateTimeNullableFilter<"Claim"> | Date | string | null
    condition?: StringNullableFilter<"Claim"> | string | null
    notes?: StringNullableFilter<"Claim"> | string | null
    ownerId?: IntNullableFilter<"Claim"> | number | null
    partId?: IntNullableFilter<"Claim"> | number | null
  }

  export type UserCreateWithoutClaimsInput = {
    name?: string | null
    nameLast?: string | null
    nameFirst?: string | null
    providerId: string
    provider?: string | null
    roles?: string | null
    registered?: Date | string | null
    lastLogIn?: Date | string | null
  }

  export type UserUncheckedCreateWithoutClaimsInput = {
    id?: number
    name?: string | null
    nameLast?: string | null
    nameFirst?: string | null
    providerId: string
    provider?: string | null
    roles?: string | null
    registered?: Date | string | null
    lastLogIn?: Date | string | null
  }

  export type UserCreateOrConnectWithoutClaimsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
  }

  export type PartCreateWithoutClaimsInput = {
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLine?: ProductLineCreateNestedOneWithoutItemsInput
    wheelHubs?: WheelCreateNestedManyWithoutHubInput
    wheelRims?: WheelCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeCreateNestedManyWithoutSpokeInput
    properties?: PropertyCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipCreateNestedManyWithoutPartInput
    builds?: BuildPartCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutClaimsInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLineId?: number | null
    wheelHubs?: WheelUncheckedCreateNestedManyWithoutHubInput
    wheelRims?: WheelUncheckedCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeUncheckedCreateNestedManyWithoutSpokeInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipUncheckedCreateNestedManyWithoutPartInput
    builds?: BuildPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutClaimsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutClaimsInput, PartUncheckedCreateWithoutClaimsInput>
  }

  export type UserUpsertWithoutClaimsInput = {
    update: XOR<UserUpdateWithoutClaimsInput, UserUncheckedUpdateWithoutClaimsInput>
    create: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClaimsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClaimsInput, UserUncheckedUpdateWithoutClaimsInput>
  }

  export type UserUpdateWithoutClaimsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameLast?: NullableStringFieldUpdateOperationsInput | string | null
    nameFirst?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateWithoutClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameLast?: NullableStringFieldUpdateOperationsInput | string | null
    nameFirst?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PartUpsertWithoutClaimsInput = {
    update: XOR<PartUpdateWithoutClaimsInput, PartUncheckedUpdateWithoutClaimsInput>
    create: XOR<PartCreateWithoutClaimsInput, PartUncheckedCreateWithoutClaimsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutClaimsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutClaimsInput, PartUncheckedUpdateWithoutClaimsInput>
  }

  export type PartUpdateWithoutClaimsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLine?: ProductLineUpdateOneWithoutItemsNestedInput
    wheelHubs?: WheelUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUpdateManyWithoutPartNestedInput
    builds?: BuildPartUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelHubs?: WheelUncheckedUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUncheckedUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUncheckedUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUncheckedUpdateManyWithoutPartNestedInput
    builds?: BuildPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type BrandMemberCreateWithoutBrandInput = {
    productLine?: ProductLineCreateNestedOneWithoutLabelMembershipsInput
  }

  export type BrandMemberUncheckedCreateWithoutBrandInput = {
    id?: number
    productLineId?: number | null
  }

  export type BrandMemberCreateOrConnectWithoutBrandInput = {
    where: BrandMemberWhereUniqueInput
    create: XOR<BrandMemberCreateWithoutBrandInput, BrandMemberUncheckedCreateWithoutBrandInput>
  }

  export type BrandMemberCreateManyBrandInputEnvelope = {
    data: BrandMemberCreateManyBrandInput | BrandMemberCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type BrandMemberUpsertWithWhereUniqueWithoutBrandInput = {
    where: BrandMemberWhereUniqueInput
    update: XOR<BrandMemberUpdateWithoutBrandInput, BrandMemberUncheckedUpdateWithoutBrandInput>
    create: XOR<BrandMemberCreateWithoutBrandInput, BrandMemberUncheckedCreateWithoutBrandInput>
  }

  export type BrandMemberUpdateWithWhereUniqueWithoutBrandInput = {
    where: BrandMemberWhereUniqueInput
    data: XOR<BrandMemberUpdateWithoutBrandInput, BrandMemberUncheckedUpdateWithoutBrandInput>
  }

  export type BrandMemberUpdateManyWithWhereWithoutBrandInput = {
    where: BrandMemberScalarWhereInput
    data: XOR<BrandMemberUpdateManyMutationInput, BrandMemberUncheckedUpdateManyWithoutBrandInput>
  }

  export type BrandMemberScalarWhereInput = {
    AND?: BrandMemberScalarWhereInput | BrandMemberScalarWhereInput[]
    OR?: BrandMemberScalarWhereInput[]
    NOT?: BrandMemberScalarWhereInput | BrandMemberScalarWhereInput[]
    id?: IntFilter<"BrandMember"> | number
    productLineId?: IntNullableFilter<"BrandMember"> | number | null
    brandId?: IntNullableFilter<"BrandMember"> | number | null
  }

  export type ProductLineCreateWithoutLabelMembershipsInput = {
    type?: string | null
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
    items?: PartCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineUncheckedCreateWithoutLabelMembershipsInput = {
    id?: number
    type?: string | null
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
    items?: PartUncheckedCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineCreateOrConnectWithoutLabelMembershipsInput = {
    where: ProductLineWhereUniqueInput
    create: XOR<ProductLineCreateWithoutLabelMembershipsInput, ProductLineUncheckedCreateWithoutLabelMembershipsInput>
  }

  export type BrandCreateWithoutLabelMembershipsInput = {
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
  }

  export type BrandUncheckedCreateWithoutLabelMembershipsInput = {
    id?: number
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
  }

  export type BrandCreateOrConnectWithoutLabelMembershipsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutLabelMembershipsInput, BrandUncheckedCreateWithoutLabelMembershipsInput>
  }

  export type ProductLineUpsertWithoutLabelMembershipsInput = {
    update: XOR<ProductLineUpdateWithoutLabelMembershipsInput, ProductLineUncheckedUpdateWithoutLabelMembershipsInput>
    create: XOR<ProductLineCreateWithoutLabelMembershipsInput, ProductLineUncheckedCreateWithoutLabelMembershipsInput>
    where?: ProductLineWhereInput
  }

  export type ProductLineUpdateToOneWithWhereWithoutLabelMembershipsInput = {
    where?: ProductLineWhereInput
    data: XOR<ProductLineUpdateWithoutLabelMembershipsInput, ProductLineUncheckedUpdateWithoutLabelMembershipsInput>
  }

  export type ProductLineUpdateWithoutLabelMembershipsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PartUpdateManyWithoutProductLineNestedInput
  }

  export type ProductLineUncheckedUpdateWithoutLabelMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PartUncheckedUpdateManyWithoutProductLineNestedInput
  }

  export type BrandUpsertWithoutLabelMembershipsInput = {
    update: XOR<BrandUpdateWithoutLabelMembershipsInput, BrandUncheckedUpdateWithoutLabelMembershipsInput>
    create: XOR<BrandCreateWithoutLabelMembershipsInput, BrandUncheckedCreateWithoutLabelMembershipsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutLabelMembershipsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutLabelMembershipsInput, BrandUncheckedUpdateWithoutLabelMembershipsInput>
  }

  export type BrandUpdateWithoutLabelMembershipsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandUncheckedUpdateWithoutLabelMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandMemberCreateWithoutProductLineInput = {
    brand?: BrandCreateNestedOneWithoutLabelMembershipsInput
  }

  export type BrandMemberUncheckedCreateWithoutProductLineInput = {
    id?: number
    brandId?: number | null
  }

  export type BrandMemberCreateOrConnectWithoutProductLineInput = {
    where: BrandMemberWhereUniqueInput
    create: XOR<BrandMemberCreateWithoutProductLineInput, BrandMemberUncheckedCreateWithoutProductLineInput>
  }

  export type BrandMemberCreateManyProductLineInputEnvelope = {
    data: BrandMemberCreateManyProductLineInput | BrandMemberCreateManyProductLineInput[]
    skipDuplicates?: boolean
  }

  export type PartCreateWithoutProductLineInput = {
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    wheelHubs?: WheelCreateNestedManyWithoutHubInput
    wheelRims?: WheelCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeCreateNestedManyWithoutSpokeInput
    properties?: PropertyCreateNestedManyWithoutPartInput
    claims?: ClaimCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipCreateNestedManyWithoutPartInput
    builds?: BuildPartCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutProductLineInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    wheelHubs?: WheelUncheckedCreateNestedManyWithoutHubInput
    wheelRims?: WheelUncheckedCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeUncheckedCreateNestedManyWithoutSpokeInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPartInput
    claims?: ClaimUncheckedCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipUncheckedCreateNestedManyWithoutPartInput
    builds?: BuildPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutProductLineInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutProductLineInput, PartUncheckedCreateWithoutProductLineInput>
  }

  export type PartCreateManyProductLineInputEnvelope = {
    data: PartCreateManyProductLineInput | PartCreateManyProductLineInput[]
    skipDuplicates?: boolean
  }

  export type BrandMemberUpsertWithWhereUniqueWithoutProductLineInput = {
    where: BrandMemberWhereUniqueInput
    update: XOR<BrandMemberUpdateWithoutProductLineInput, BrandMemberUncheckedUpdateWithoutProductLineInput>
    create: XOR<BrandMemberCreateWithoutProductLineInput, BrandMemberUncheckedCreateWithoutProductLineInput>
  }

  export type BrandMemberUpdateWithWhereUniqueWithoutProductLineInput = {
    where: BrandMemberWhereUniqueInput
    data: XOR<BrandMemberUpdateWithoutProductLineInput, BrandMemberUncheckedUpdateWithoutProductLineInput>
  }

  export type BrandMemberUpdateManyWithWhereWithoutProductLineInput = {
    where: BrandMemberScalarWhereInput
    data: XOR<BrandMemberUpdateManyMutationInput, BrandMemberUncheckedUpdateManyWithoutProductLineInput>
  }

  export type PartUpsertWithWhereUniqueWithoutProductLineInput = {
    where: PartWhereUniqueInput
    update: XOR<PartUpdateWithoutProductLineInput, PartUncheckedUpdateWithoutProductLineInput>
    create: XOR<PartCreateWithoutProductLineInput, PartUncheckedCreateWithoutProductLineInput>
  }

  export type PartUpdateWithWhereUniqueWithoutProductLineInput = {
    where: PartWhereUniqueInput
    data: XOR<PartUpdateWithoutProductLineInput, PartUncheckedUpdateWithoutProductLineInput>
  }

  export type PartUpdateManyWithWhereWithoutProductLineInput = {
    where: PartScalarWhereInput
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyWithoutProductLineInput>
  }

  export type PartScalarWhereInput = {
    AND?: PartScalarWhereInput | PartScalarWhereInput[]
    OR?: PartScalarWhereInput[]
    NOT?: PartScalarWhereInput | PartScalarWhereInput[]
    id?: IntFilter<"Part"> | number
    type?: StringNullableFilter<"Part"> | string | null
    name?: StringNullableFilter<"Part"> | string | null
    notes?: StringNullableFilter<"Part"> | string | null
    weight?: DecimalNullableFilter<"Part"> | Decimal | DecimalJsLike | number | string | null
    weightUnit?: StringNullableFilter<"Part"> | string | null
    productLineId?: IntNullableFilter<"Part"> | number | null
  }

  export type PropertyGroupMembershipCreateWithoutGroupInput = {
    partType?: PartTypeCreateNestedOneWithoutPropertyTypesInput
    propertyType?: PropertyTypeCreateNestedOneWithoutGroupsInput
  }

  export type PropertyGroupMembershipUncheckedCreateWithoutGroupInput = {
    id?: number
    partTypeId?: number | null
    propertyTypeId?: number | null
  }

  export type PropertyGroupMembershipCreateOrConnectWithoutGroupInput = {
    where: PropertyGroupMembershipWhereUniqueInput
    create: XOR<PropertyGroupMembershipCreateWithoutGroupInput, PropertyGroupMembershipUncheckedCreateWithoutGroupInput>
  }

  export type PropertyGroupMembershipCreateManyGroupInputEnvelope = {
    data: PropertyGroupMembershipCreateManyGroupInput | PropertyGroupMembershipCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type PropertyGroupMembershipUpsertWithWhereUniqueWithoutGroupInput = {
    where: PropertyGroupMembershipWhereUniqueInput
    update: XOR<PropertyGroupMembershipUpdateWithoutGroupInput, PropertyGroupMembershipUncheckedUpdateWithoutGroupInput>
    create: XOR<PropertyGroupMembershipCreateWithoutGroupInput, PropertyGroupMembershipUncheckedCreateWithoutGroupInput>
  }

  export type PropertyGroupMembershipUpdateWithWhereUniqueWithoutGroupInput = {
    where: PropertyGroupMembershipWhereUniqueInput
    data: XOR<PropertyGroupMembershipUpdateWithoutGroupInput, PropertyGroupMembershipUncheckedUpdateWithoutGroupInput>
  }

  export type PropertyGroupMembershipUpdateManyWithWhereWithoutGroupInput = {
    where: PropertyGroupMembershipScalarWhereInput
    data: XOR<PropertyGroupMembershipUpdateManyMutationInput, PropertyGroupMembershipUncheckedUpdateManyWithoutGroupInput>
  }

  export type PropertyGroupMembershipScalarWhereInput = {
    AND?: PropertyGroupMembershipScalarWhereInput | PropertyGroupMembershipScalarWhereInput[]
    OR?: PropertyGroupMembershipScalarWhereInput[]
    NOT?: PropertyGroupMembershipScalarWhereInput | PropertyGroupMembershipScalarWhereInput[]
    id?: IntFilter<"PropertyGroupMembership"> | number
    partTypeId?: IntNullableFilter<"PropertyGroupMembership"> | number | null
    propertyTypeId?: IntNullableFilter<"PropertyGroupMembership"> | number | null
    groupId?: IntNullableFilter<"PropertyGroupMembership"> | number | null
  }

  export type PartTypeCreateWithoutPropertyTypesInput = {
    order?: number | null
    name: string
    description?: string | null
    classes?: PartClassMembershipCreateNestedManyWithoutPartTypeInput
  }

  export type PartTypeUncheckedCreateWithoutPropertyTypesInput = {
    id?: number
    order?: number | null
    name: string
    description?: string | null
    classes?: PartClassMembershipUncheckedCreateNestedManyWithoutPartTypeInput
  }

  export type PartTypeCreateOrConnectWithoutPropertyTypesInput = {
    where: PartTypeWhereUniqueInput
    create: XOR<PartTypeCreateWithoutPropertyTypesInput, PartTypeUncheckedCreateWithoutPropertyTypesInput>
  }

  export type PropertyTypeCreateWithoutGroupsInput = {
    order?: number | null
    name?: string | null
    description?: string | null
    valueDataType?: string | null
    valueDataTypeModifier?: string | null
    variation?: string | null
    properties?: PropertyCreateNestedManyWithoutPropertyTypeInput
    lookupValues?: PropertyLookupCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeUncheckedCreateWithoutGroupsInput = {
    id?: number
    order?: number | null
    name?: string | null
    description?: string | null
    valueDataType?: string | null
    valueDataTypeModifier?: string | null
    variation?: string | null
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyTypeInput
    lookupValues?: PropertyLookupUncheckedCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeCreateOrConnectWithoutGroupsInput = {
    where: PropertyTypeWhereUniqueInput
    create: XOR<PropertyTypeCreateWithoutGroupsInput, PropertyTypeUncheckedCreateWithoutGroupsInput>
  }

  export type PropertyGroupCreateWithoutPropertyTypesInput = {
    order?: number | null
    name: string
    description?: string | null
  }

  export type PropertyGroupUncheckedCreateWithoutPropertyTypesInput = {
    id?: number
    order?: number | null
    name: string
    description?: string | null
  }

  export type PropertyGroupCreateOrConnectWithoutPropertyTypesInput = {
    where: PropertyGroupWhereUniqueInput
    create: XOR<PropertyGroupCreateWithoutPropertyTypesInput, PropertyGroupUncheckedCreateWithoutPropertyTypesInput>
  }

  export type PartTypeUpsertWithoutPropertyTypesInput = {
    update: XOR<PartTypeUpdateWithoutPropertyTypesInput, PartTypeUncheckedUpdateWithoutPropertyTypesInput>
    create: XOR<PartTypeCreateWithoutPropertyTypesInput, PartTypeUncheckedCreateWithoutPropertyTypesInput>
    where?: PartTypeWhereInput
  }

  export type PartTypeUpdateToOneWithWhereWithoutPropertyTypesInput = {
    where?: PartTypeWhereInput
    data: XOR<PartTypeUpdateWithoutPropertyTypesInput, PartTypeUncheckedUpdateWithoutPropertyTypesInput>
  }

  export type PartTypeUpdateWithoutPropertyTypesInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: PartClassMembershipUpdateManyWithoutPartTypeNestedInput
  }

  export type PartTypeUncheckedUpdateWithoutPropertyTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: PartClassMembershipUncheckedUpdateManyWithoutPartTypeNestedInput
  }

  export type PropertyTypeUpsertWithoutGroupsInput = {
    update: XOR<PropertyTypeUpdateWithoutGroupsInput, PropertyTypeUncheckedUpdateWithoutGroupsInput>
    create: XOR<PropertyTypeCreateWithoutGroupsInput, PropertyTypeUncheckedCreateWithoutGroupsInput>
    where?: PropertyTypeWhereInput
  }

  export type PropertyTypeUpdateToOneWithWhereWithoutGroupsInput = {
    where?: PropertyTypeWhereInput
    data: XOR<PropertyTypeUpdateWithoutGroupsInput, PropertyTypeUncheckedUpdateWithoutGroupsInput>
  }

  export type PropertyTypeUpdateWithoutGroupsInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: PropertyUpdateManyWithoutPropertyTypeNestedInput
    lookupValues?: PropertyLookupUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: PropertyUncheckedUpdateManyWithoutPropertyTypeNestedInput
    lookupValues?: PropertyLookupUncheckedUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyGroupUpsertWithoutPropertyTypesInput = {
    update: XOR<PropertyGroupUpdateWithoutPropertyTypesInput, PropertyGroupUncheckedUpdateWithoutPropertyTypesInput>
    create: XOR<PropertyGroupCreateWithoutPropertyTypesInput, PropertyGroupUncheckedCreateWithoutPropertyTypesInput>
    where?: PropertyGroupWhereInput
  }

  export type PropertyGroupUpdateToOneWithWhereWithoutPropertyTypesInput = {
    where?: PropertyGroupWhereInput
    data: XOR<PropertyGroupUpdateWithoutPropertyTypesInput, PropertyGroupUncheckedUpdateWithoutPropertyTypesInput>
  }

  export type PropertyGroupUpdateWithoutPropertyTypesInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyGroupUncheckedUpdateWithoutPropertyTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyGroupMembershipCreateWithoutPropertyTypeInput = {
    partType?: PartTypeCreateNestedOneWithoutPropertyTypesInput
    group?: PropertyGroupCreateNestedOneWithoutPropertyTypesInput
  }

  export type PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput = {
    id?: number
    partTypeId?: number | null
    groupId?: number | null
  }

  export type PropertyGroupMembershipCreateOrConnectWithoutPropertyTypeInput = {
    where: PropertyGroupMembershipWhereUniqueInput
    create: XOR<PropertyGroupMembershipCreateWithoutPropertyTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyGroupMembershipCreateManyPropertyTypeInputEnvelope = {
    data: PropertyGroupMembershipCreateManyPropertyTypeInput | PropertyGroupMembershipCreateManyPropertyTypeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutPropertyTypeInput = {
    value?: string | null
    valueDataMethod?: string | null
    part?: PartCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutPropertyTypeInput = {
    id?: number
    itemId?: number | null
    value?: string | null
    valueDataMethod?: string | null
  }

  export type PropertyCreateOrConnectWithoutPropertyTypeInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyCreateManyPropertyTypeInputEnvelope = {
    data: PropertyCreateManyPropertyTypeInput | PropertyCreateManyPropertyTypeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyLookupCreateWithoutPropertyTypeInput = {
    value?: string | null
  }

  export type PropertyLookupUncheckedCreateWithoutPropertyTypeInput = {
    id?: number
    value?: string | null
  }

  export type PropertyLookupCreateOrConnectWithoutPropertyTypeInput = {
    where: PropertyLookupWhereUniqueInput
    create: XOR<PropertyLookupCreateWithoutPropertyTypeInput, PropertyLookupUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyLookupCreateManyPropertyTypeInputEnvelope = {
    data: PropertyLookupCreateManyPropertyTypeInput | PropertyLookupCreateManyPropertyTypeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyGroupMembershipUpsertWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyGroupMembershipWhereUniqueInput
    update: XOR<PropertyGroupMembershipUpdateWithoutPropertyTypeInput, PropertyGroupMembershipUncheckedUpdateWithoutPropertyTypeInput>
    create: XOR<PropertyGroupMembershipCreateWithoutPropertyTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyGroupMembershipUpdateWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyGroupMembershipWhereUniqueInput
    data: XOR<PropertyGroupMembershipUpdateWithoutPropertyTypeInput, PropertyGroupMembershipUncheckedUpdateWithoutPropertyTypeInput>
  }

  export type PropertyGroupMembershipUpdateManyWithWhereWithoutPropertyTypeInput = {
    where: PropertyGroupMembershipScalarWhereInput
    data: XOR<PropertyGroupMembershipUpdateManyMutationInput, PropertyGroupMembershipUncheckedUpdateManyWithoutPropertyTypeInput>
  }

  export type PropertyUpsertWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutPropertyTypeInput, PropertyUncheckedUpdateWithoutPropertyTypeInput>
    create: XOR<PropertyCreateWithoutPropertyTypeInput, PropertyUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutPropertyTypeInput, PropertyUncheckedUpdateWithoutPropertyTypeInput>
  }

  export type PropertyUpdateManyWithWhereWithoutPropertyTypeInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPropertyTypeInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: IntFilter<"Property"> | number
    itemId?: IntNullableFilter<"Property"> | number | null
    value?: StringNullableFilter<"Property"> | string | null
    valueDataMethod?: StringNullableFilter<"Property"> | string | null
    propertyTypeId?: IntNullableFilter<"Property"> | number | null
  }

  export type PropertyLookupUpsertWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyLookupWhereUniqueInput
    update: XOR<PropertyLookupUpdateWithoutPropertyTypeInput, PropertyLookupUncheckedUpdateWithoutPropertyTypeInput>
    create: XOR<PropertyLookupCreateWithoutPropertyTypeInput, PropertyLookupUncheckedCreateWithoutPropertyTypeInput>
  }

  export type PropertyLookupUpdateWithWhereUniqueWithoutPropertyTypeInput = {
    where: PropertyLookupWhereUniqueInput
    data: XOR<PropertyLookupUpdateWithoutPropertyTypeInput, PropertyLookupUncheckedUpdateWithoutPropertyTypeInput>
  }

  export type PropertyLookupUpdateManyWithWhereWithoutPropertyTypeInput = {
    where: PropertyLookupScalarWhereInput
    data: XOR<PropertyLookupUpdateManyMutationInput, PropertyLookupUncheckedUpdateManyWithoutPropertyTypeInput>
  }

  export type PropertyLookupScalarWhereInput = {
    AND?: PropertyLookupScalarWhereInput | PropertyLookupScalarWhereInput[]
    OR?: PropertyLookupScalarWhereInput[]
    NOT?: PropertyLookupScalarWhereInput | PropertyLookupScalarWhereInput[]
    id?: IntFilter<"PropertyLookup"> | number
    value?: StringNullableFilter<"PropertyLookup"> | string | null
    propertyTypeId?: IntNullableFilter<"PropertyLookup"> | number | null
  }

  export type PropertyTypeCreateWithoutLookupValuesInput = {
    order?: number | null
    name?: string | null
    description?: string | null
    valueDataType?: string | null
    valueDataTypeModifier?: string | null
    variation?: string | null
    groups?: PropertyGroupMembershipCreateNestedManyWithoutPropertyTypeInput
    properties?: PropertyCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeUncheckedCreateWithoutLookupValuesInput = {
    id?: number
    order?: number | null
    name?: string | null
    description?: string | null
    valueDataType?: string | null
    valueDataTypeModifier?: string | null
    variation?: string | null
    groups?: PropertyGroupMembershipUncheckedCreateNestedManyWithoutPropertyTypeInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeCreateOrConnectWithoutLookupValuesInput = {
    where: PropertyTypeWhereUniqueInput
    create: XOR<PropertyTypeCreateWithoutLookupValuesInput, PropertyTypeUncheckedCreateWithoutLookupValuesInput>
  }

  export type PropertyTypeUpsertWithoutLookupValuesInput = {
    update: XOR<PropertyTypeUpdateWithoutLookupValuesInput, PropertyTypeUncheckedUpdateWithoutLookupValuesInput>
    create: XOR<PropertyTypeCreateWithoutLookupValuesInput, PropertyTypeUncheckedCreateWithoutLookupValuesInput>
    where?: PropertyTypeWhereInput
  }

  export type PropertyTypeUpdateToOneWithWhereWithoutLookupValuesInput = {
    where?: PropertyTypeWhereInput
    data: XOR<PropertyTypeUpdateWithoutLookupValuesInput, PropertyTypeUncheckedUpdateWithoutLookupValuesInput>
  }

  export type PropertyTypeUpdateWithoutLookupValuesInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: PropertyGroupMembershipUpdateManyWithoutPropertyTypeNestedInput
    properties?: PropertyUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeUncheckedUpdateWithoutLookupValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: PropertyGroupMembershipUncheckedUpdateManyWithoutPropertyTypeNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PartClassMembershipCreateWithoutPartClassInput = {
    partType?: PartTypeCreateNestedOneWithoutClassesInput
  }

  export type PartClassMembershipUncheckedCreateWithoutPartClassInput = {
    id?: number
    partTypeId?: number | null
  }

  export type PartClassMembershipCreateOrConnectWithoutPartClassInput = {
    where: PartClassMembershipWhereUniqueInput
    create: XOR<PartClassMembershipCreateWithoutPartClassInput, PartClassMembershipUncheckedCreateWithoutPartClassInput>
  }

  export type PartClassMembershipCreateManyPartClassInputEnvelope = {
    data: PartClassMembershipCreateManyPartClassInput | PartClassMembershipCreateManyPartClassInput[]
    skipDuplicates?: boolean
  }

  export type PartClassMembershipUpsertWithWhereUniqueWithoutPartClassInput = {
    where: PartClassMembershipWhereUniqueInput
    update: XOR<PartClassMembershipUpdateWithoutPartClassInput, PartClassMembershipUncheckedUpdateWithoutPartClassInput>
    create: XOR<PartClassMembershipCreateWithoutPartClassInput, PartClassMembershipUncheckedCreateWithoutPartClassInput>
  }

  export type PartClassMembershipUpdateWithWhereUniqueWithoutPartClassInput = {
    where: PartClassMembershipWhereUniqueInput
    data: XOR<PartClassMembershipUpdateWithoutPartClassInput, PartClassMembershipUncheckedUpdateWithoutPartClassInput>
  }

  export type PartClassMembershipUpdateManyWithWhereWithoutPartClassInput = {
    where: PartClassMembershipScalarWhereInput
    data: XOR<PartClassMembershipUpdateManyMutationInput, PartClassMembershipUncheckedUpdateManyWithoutPartClassInput>
  }

  export type PartClassMembershipScalarWhereInput = {
    AND?: PartClassMembershipScalarWhereInput | PartClassMembershipScalarWhereInput[]
    OR?: PartClassMembershipScalarWhereInput[]
    NOT?: PartClassMembershipScalarWhereInput | PartClassMembershipScalarWhereInput[]
    id?: IntFilter<"PartClassMembership"> | number
    partClassId?: IntNullableFilter<"PartClassMembership"> | number | null
    partTypeId?: IntNullableFilter<"PartClassMembership"> | number | null
  }

  export type PartClassCreateWithoutPartTypesInput = {
    order?: number | null
    name: string
  }

  export type PartClassUncheckedCreateWithoutPartTypesInput = {
    id?: number
    order?: number | null
    name: string
  }

  export type PartClassCreateOrConnectWithoutPartTypesInput = {
    where: PartClassWhereUniqueInput
    create: XOR<PartClassCreateWithoutPartTypesInput, PartClassUncheckedCreateWithoutPartTypesInput>
  }

  export type PartTypeCreateWithoutClassesInput = {
    order?: number | null
    name: string
    description?: string | null
    propertyTypes?: PropertyGroupMembershipCreateNestedManyWithoutPartTypeInput
  }

  export type PartTypeUncheckedCreateWithoutClassesInput = {
    id?: number
    order?: number | null
    name: string
    description?: string | null
    propertyTypes?: PropertyGroupMembershipUncheckedCreateNestedManyWithoutPartTypeInput
  }

  export type PartTypeCreateOrConnectWithoutClassesInput = {
    where: PartTypeWhereUniqueInput
    create: XOR<PartTypeCreateWithoutClassesInput, PartTypeUncheckedCreateWithoutClassesInput>
  }

  export type PartClassUpsertWithoutPartTypesInput = {
    update: XOR<PartClassUpdateWithoutPartTypesInput, PartClassUncheckedUpdateWithoutPartTypesInput>
    create: XOR<PartClassCreateWithoutPartTypesInput, PartClassUncheckedCreateWithoutPartTypesInput>
    where?: PartClassWhereInput
  }

  export type PartClassUpdateToOneWithWhereWithoutPartTypesInput = {
    where?: PartClassWhereInput
    data: XOR<PartClassUpdateWithoutPartTypesInput, PartClassUncheckedUpdateWithoutPartTypesInput>
  }

  export type PartClassUpdateWithoutPartTypesInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PartClassUncheckedUpdateWithoutPartTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PartTypeUpsertWithoutClassesInput = {
    update: XOR<PartTypeUpdateWithoutClassesInput, PartTypeUncheckedUpdateWithoutClassesInput>
    create: XOR<PartTypeCreateWithoutClassesInput, PartTypeUncheckedCreateWithoutClassesInput>
    where?: PartTypeWhereInput
  }

  export type PartTypeUpdateToOneWithWhereWithoutClassesInput = {
    where?: PartTypeWhereInput
    data: XOR<PartTypeUpdateWithoutClassesInput, PartTypeUncheckedUpdateWithoutClassesInput>
  }

  export type PartTypeUpdateWithoutClassesInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypes?: PropertyGroupMembershipUpdateManyWithoutPartTypeNestedInput
  }

  export type PartTypeUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypes?: PropertyGroupMembershipUncheckedUpdateManyWithoutPartTypeNestedInput
  }

  export type PropertyGroupMembershipCreateWithoutPartTypeInput = {
    propertyType?: PropertyTypeCreateNestedOneWithoutGroupsInput
    group?: PropertyGroupCreateNestedOneWithoutPropertyTypesInput
  }

  export type PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput = {
    id?: number
    propertyTypeId?: number | null
    groupId?: number | null
  }

  export type PropertyGroupMembershipCreateOrConnectWithoutPartTypeInput = {
    where: PropertyGroupMembershipWhereUniqueInput
    create: XOR<PropertyGroupMembershipCreateWithoutPartTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput>
  }

  export type PropertyGroupMembershipCreateManyPartTypeInputEnvelope = {
    data: PropertyGroupMembershipCreateManyPartTypeInput | PropertyGroupMembershipCreateManyPartTypeInput[]
    skipDuplicates?: boolean
  }

  export type PartClassMembershipCreateWithoutPartTypeInput = {
    partClass?: PartClassCreateNestedOneWithoutPartTypesInput
  }

  export type PartClassMembershipUncheckedCreateWithoutPartTypeInput = {
    id?: number
    partClassId?: number | null
  }

  export type PartClassMembershipCreateOrConnectWithoutPartTypeInput = {
    where: PartClassMembershipWhereUniqueInput
    create: XOR<PartClassMembershipCreateWithoutPartTypeInput, PartClassMembershipUncheckedCreateWithoutPartTypeInput>
  }

  export type PartClassMembershipCreateManyPartTypeInputEnvelope = {
    data: PartClassMembershipCreateManyPartTypeInput | PartClassMembershipCreateManyPartTypeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyGroupMembershipUpsertWithWhereUniqueWithoutPartTypeInput = {
    where: PropertyGroupMembershipWhereUniqueInput
    update: XOR<PropertyGroupMembershipUpdateWithoutPartTypeInput, PropertyGroupMembershipUncheckedUpdateWithoutPartTypeInput>
    create: XOR<PropertyGroupMembershipCreateWithoutPartTypeInput, PropertyGroupMembershipUncheckedCreateWithoutPartTypeInput>
  }

  export type PropertyGroupMembershipUpdateWithWhereUniqueWithoutPartTypeInput = {
    where: PropertyGroupMembershipWhereUniqueInput
    data: XOR<PropertyGroupMembershipUpdateWithoutPartTypeInput, PropertyGroupMembershipUncheckedUpdateWithoutPartTypeInput>
  }

  export type PropertyGroupMembershipUpdateManyWithWhereWithoutPartTypeInput = {
    where: PropertyGroupMembershipScalarWhereInput
    data: XOR<PropertyGroupMembershipUpdateManyMutationInput, PropertyGroupMembershipUncheckedUpdateManyWithoutPartTypeInput>
  }

  export type PartClassMembershipUpsertWithWhereUniqueWithoutPartTypeInput = {
    where: PartClassMembershipWhereUniqueInput
    update: XOR<PartClassMembershipUpdateWithoutPartTypeInput, PartClassMembershipUncheckedUpdateWithoutPartTypeInput>
    create: XOR<PartClassMembershipCreateWithoutPartTypeInput, PartClassMembershipUncheckedCreateWithoutPartTypeInput>
  }

  export type PartClassMembershipUpdateWithWhereUniqueWithoutPartTypeInput = {
    where: PartClassMembershipWhereUniqueInput
    data: XOR<PartClassMembershipUpdateWithoutPartTypeInput, PartClassMembershipUncheckedUpdateWithoutPartTypeInput>
  }

  export type PartClassMembershipUpdateManyWithWhereWithoutPartTypeInput = {
    where: PartClassMembershipScalarWhereInput
    data: XOR<PartClassMembershipUpdateManyMutationInput, PartClassMembershipUncheckedUpdateManyWithoutPartTypeInput>
  }

  export type PartGroupMembershipCreateWithoutGroupInput = {
    part?: PartCreateNestedOneWithoutGroupsInput
  }

  export type PartGroupMembershipUncheckedCreateWithoutGroupInput = {
    id?: number
    partId?: number | null
  }

  export type PartGroupMembershipCreateOrConnectWithoutGroupInput = {
    where: PartGroupMembershipWhereUniqueInput
    create: XOR<PartGroupMembershipCreateWithoutGroupInput, PartGroupMembershipUncheckedCreateWithoutGroupInput>
  }

  export type PartGroupMembershipCreateManyGroupInputEnvelope = {
    data: PartGroupMembershipCreateManyGroupInput | PartGroupMembershipCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type PartGroupMembershipUpsertWithWhereUniqueWithoutGroupInput = {
    where: PartGroupMembershipWhereUniqueInput
    update: XOR<PartGroupMembershipUpdateWithoutGroupInput, PartGroupMembershipUncheckedUpdateWithoutGroupInput>
    create: XOR<PartGroupMembershipCreateWithoutGroupInput, PartGroupMembershipUncheckedCreateWithoutGroupInput>
  }

  export type PartGroupMembershipUpdateWithWhereUniqueWithoutGroupInput = {
    where: PartGroupMembershipWhereUniqueInput
    data: XOR<PartGroupMembershipUpdateWithoutGroupInput, PartGroupMembershipUncheckedUpdateWithoutGroupInput>
  }

  export type PartGroupMembershipUpdateManyWithWhereWithoutGroupInput = {
    where: PartGroupMembershipScalarWhereInput
    data: XOR<PartGroupMembershipUpdateManyMutationInput, PartGroupMembershipUncheckedUpdateManyWithoutGroupInput>
  }

  export type PartGroupMembershipScalarWhereInput = {
    AND?: PartGroupMembershipScalarWhereInput | PartGroupMembershipScalarWhereInput[]
    OR?: PartGroupMembershipScalarWhereInput[]
    NOT?: PartGroupMembershipScalarWhereInput | PartGroupMembershipScalarWhereInput[]
    id?: IntFilter<"PartGroupMembership"> | number
    partId?: IntNullableFilter<"PartGroupMembership"> | number | null
    groupId?: IntNullableFilter<"PartGroupMembership"> | number | null
  }

  export type PartCreateWithoutGroupsInput = {
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLine?: ProductLineCreateNestedOneWithoutItemsInput
    wheelHubs?: WheelCreateNestedManyWithoutHubInput
    wheelRims?: WheelCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeCreateNestedManyWithoutSpokeInput
    properties?: PropertyCreateNestedManyWithoutPartInput
    claims?: ClaimCreateNestedManyWithoutPartInput
    builds?: BuildPartCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutGroupsInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLineId?: number | null
    wheelHubs?: WheelUncheckedCreateNestedManyWithoutHubInput
    wheelRims?: WheelUncheckedCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeUncheckedCreateNestedManyWithoutSpokeInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPartInput
    claims?: ClaimUncheckedCreateNestedManyWithoutPartInput
    builds?: BuildPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutGroupsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutGroupsInput, PartUncheckedCreateWithoutGroupsInput>
  }

  export type PartGroupCreateWithoutPartsInput = {
    name?: string | null
  }

  export type PartGroupUncheckedCreateWithoutPartsInput = {
    id?: number
    name?: string | null
  }

  export type PartGroupCreateOrConnectWithoutPartsInput = {
    where: PartGroupWhereUniqueInput
    create: XOR<PartGroupCreateWithoutPartsInput, PartGroupUncheckedCreateWithoutPartsInput>
  }

  export type PartUpsertWithoutGroupsInput = {
    update: XOR<PartUpdateWithoutGroupsInput, PartUncheckedUpdateWithoutGroupsInput>
    create: XOR<PartCreateWithoutGroupsInput, PartUncheckedCreateWithoutGroupsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutGroupsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutGroupsInput, PartUncheckedUpdateWithoutGroupsInput>
  }

  export type PartUpdateWithoutGroupsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLine?: ProductLineUpdateOneWithoutItemsNestedInput
    wheelHubs?: WheelUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUpdateManyWithoutPartNestedInput
    claims?: ClaimUpdateManyWithoutPartNestedInput
    builds?: BuildPartUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelHubs?: WheelUncheckedUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUncheckedUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUncheckedUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPartNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutPartNestedInput
    builds?: BuildPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartGroupUpsertWithoutPartsInput = {
    update: XOR<PartGroupUpdateWithoutPartsInput, PartGroupUncheckedUpdateWithoutPartsInput>
    create: XOR<PartGroupCreateWithoutPartsInput, PartGroupUncheckedCreateWithoutPartsInput>
    where?: PartGroupWhereInput
  }

  export type PartGroupUpdateToOneWithWhereWithoutPartsInput = {
    where?: PartGroupWhereInput
    data: XOR<PartGroupUpdateWithoutPartsInput, PartGroupUncheckedUpdateWithoutPartsInput>
  }

  export type PartGroupUpdateWithoutPartsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartGroupUncheckedUpdateWithoutPartsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductLineCreateWithoutItemsInput = {
    type?: string | null
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
    labelMemberships?: BrandMemberCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineUncheckedCreateWithoutItemsInput = {
    id?: number
    type?: string | null
    name?: string | null
    nameShort?: string | null
    nameAbbreviation?: string | null
    notes?: string | null
    webAddress?: string | null
    labelMemberships?: BrandMemberUncheckedCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineCreateOrConnectWithoutItemsInput = {
    where: ProductLineWhereUniqueInput
    create: XOR<ProductLineCreateWithoutItemsInput, ProductLineUncheckedCreateWithoutItemsInput>
  }

  export type WheelCreateWithoutHubInput = {
    name?: string | null
    notes?: string | null
    rim?: PartCreateNestedOneWithoutWheelRimsInput
    spokes?: WheelSpokeCreateNestedManyWithoutWheelInput
  }

  export type WheelUncheckedCreateWithoutHubInput = {
    id?: number
    name?: string | null
    notes?: string | null
    rimId?: number | null
    spokes?: WheelSpokeUncheckedCreateNestedManyWithoutWheelInput
  }

  export type WheelCreateOrConnectWithoutHubInput = {
    where: WheelWhereUniqueInput
    create: XOR<WheelCreateWithoutHubInput, WheelUncheckedCreateWithoutHubInput>
  }

  export type WheelCreateManyHubInputEnvelope = {
    data: WheelCreateManyHubInput | WheelCreateManyHubInput[]
    skipDuplicates?: boolean
  }

  export type WheelCreateWithoutRimInput = {
    name?: string | null
    notes?: string | null
    hub?: PartCreateNestedOneWithoutWheelHubsInput
    spokes?: WheelSpokeCreateNestedManyWithoutWheelInput
  }

  export type WheelUncheckedCreateWithoutRimInput = {
    id?: number
    name?: string | null
    notes?: string | null
    hubId?: number | null
    spokes?: WheelSpokeUncheckedCreateNestedManyWithoutWheelInput
  }

  export type WheelCreateOrConnectWithoutRimInput = {
    where: WheelWhereUniqueInput
    create: XOR<WheelCreateWithoutRimInput, WheelUncheckedCreateWithoutRimInput>
  }

  export type WheelCreateManyRimInputEnvelope = {
    data: WheelCreateManyRimInput | WheelCreateManyRimInput[]
    skipDuplicates?: boolean
  }

  export type WheelSpokeCreateWithoutSpokeInput = {
    quantity?: number | null
    length?: Decimal | DecimalJsLike | number | string | null
    tensionApplied?: Decimal | DecimalJsLike | number | string | null
    tensionUnit?: string | null
    preparation?: string | null
    notes?: string | null
    wheel?: WheelCreateNestedOneWithoutSpokesInput
  }

  export type WheelSpokeUncheckedCreateWithoutSpokeInput = {
    id?: number
    quantity?: number | null
    length?: Decimal | DecimalJsLike | number | string | null
    tensionApplied?: Decimal | DecimalJsLike | number | string | null
    tensionUnit?: string | null
    preparation?: string | null
    notes?: string | null
    wheelId?: number | null
  }

  export type WheelSpokeCreateOrConnectWithoutSpokeInput = {
    where: WheelSpokeWhereUniqueInput
    create: XOR<WheelSpokeCreateWithoutSpokeInput, WheelSpokeUncheckedCreateWithoutSpokeInput>
  }

  export type WheelSpokeCreateManySpokeInputEnvelope = {
    data: WheelSpokeCreateManySpokeInput | WheelSpokeCreateManySpokeInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutPartInput = {
    value?: string | null
    valueDataMethod?: string | null
    propertyType?: PropertyTypeCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyUncheckedCreateWithoutPartInput = {
    id?: number
    value?: string | null
    valueDataMethod?: string | null
    propertyTypeId?: number | null
  }

  export type PropertyCreateOrConnectWithoutPartInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPartInput, PropertyUncheckedCreateWithoutPartInput>
  }

  export type PropertyCreateManyPartInputEnvelope = {
    data: PropertyCreateManyPartInput | PropertyCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type ClaimCreateWithoutPartInput = {
    claimType?: string | null
    acquired?: Date | string | null
    condition?: string | null
    notes?: string | null
    owner?: UserCreateNestedOneWithoutClaimsInput
  }

  export type ClaimUncheckedCreateWithoutPartInput = {
    id?: number
    claimType?: string | null
    acquired?: Date | string | null
    condition?: string | null
    notes?: string | null
    ownerId?: number | null
  }

  export type ClaimCreateOrConnectWithoutPartInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutPartInput, ClaimUncheckedCreateWithoutPartInput>
  }

  export type ClaimCreateManyPartInputEnvelope = {
    data: ClaimCreateManyPartInput | ClaimCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type PartGroupMembershipCreateWithoutPartInput = {
    group?: PartGroupCreateNestedOneWithoutPartsInput
  }

  export type PartGroupMembershipUncheckedCreateWithoutPartInput = {
    id?: number
    groupId?: number | null
  }

  export type PartGroupMembershipCreateOrConnectWithoutPartInput = {
    where: PartGroupMembershipWhereUniqueInput
    create: XOR<PartGroupMembershipCreateWithoutPartInput, PartGroupMembershipUncheckedCreateWithoutPartInput>
  }

  export type PartGroupMembershipCreateManyPartInputEnvelope = {
    data: PartGroupMembershipCreateManyPartInput | PartGroupMembershipCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type BuildPartCreateWithoutPartInput = {
    build?: BuildCreateNestedOneWithoutPartsInput
  }

  export type BuildPartUncheckedCreateWithoutPartInput = {
    id?: number
    buildId?: number | null
  }

  export type BuildPartCreateOrConnectWithoutPartInput = {
    where: BuildPartWhereUniqueInput
    create: XOR<BuildPartCreateWithoutPartInput, BuildPartUncheckedCreateWithoutPartInput>
  }

  export type BuildPartCreateManyPartInputEnvelope = {
    data: BuildPartCreateManyPartInput | BuildPartCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type ProductLineUpsertWithoutItemsInput = {
    update: XOR<ProductLineUpdateWithoutItemsInput, ProductLineUncheckedUpdateWithoutItemsInput>
    create: XOR<ProductLineCreateWithoutItemsInput, ProductLineUncheckedCreateWithoutItemsInput>
    where?: ProductLineWhereInput
  }

  export type ProductLineUpdateToOneWithWhereWithoutItemsInput = {
    where?: ProductLineWhereInput
    data: XOR<ProductLineUpdateWithoutItemsInput, ProductLineUncheckedUpdateWithoutItemsInput>
  }

  export type ProductLineUpdateWithoutItemsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
    labelMemberships?: BrandMemberUpdateManyWithoutProductLineNestedInput
  }

  export type ProductLineUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameShort?: NullableStringFieldUpdateOperationsInput | string | null
    nameAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    webAddress?: NullableStringFieldUpdateOperationsInput | string | null
    labelMemberships?: BrandMemberUncheckedUpdateManyWithoutProductLineNestedInput
  }

  export type WheelUpsertWithWhereUniqueWithoutHubInput = {
    where: WheelWhereUniqueInput
    update: XOR<WheelUpdateWithoutHubInput, WheelUncheckedUpdateWithoutHubInput>
    create: XOR<WheelCreateWithoutHubInput, WheelUncheckedCreateWithoutHubInput>
  }

  export type WheelUpdateWithWhereUniqueWithoutHubInput = {
    where: WheelWhereUniqueInput
    data: XOR<WheelUpdateWithoutHubInput, WheelUncheckedUpdateWithoutHubInput>
  }

  export type WheelUpdateManyWithWhereWithoutHubInput = {
    where: WheelScalarWhereInput
    data: XOR<WheelUpdateManyMutationInput, WheelUncheckedUpdateManyWithoutHubInput>
  }

  export type WheelScalarWhereInput = {
    AND?: WheelScalarWhereInput | WheelScalarWhereInput[]
    OR?: WheelScalarWhereInput[]
    NOT?: WheelScalarWhereInput | WheelScalarWhereInput[]
    id?: IntFilter<"Wheel"> | number
    name?: StringNullableFilter<"Wheel"> | string | null
    notes?: StringNullableFilter<"Wheel"> | string | null
    hubId?: IntNullableFilter<"Wheel"> | number | null
    rimId?: IntNullableFilter<"Wheel"> | number | null
  }

  export type WheelUpsertWithWhereUniqueWithoutRimInput = {
    where: WheelWhereUniqueInput
    update: XOR<WheelUpdateWithoutRimInput, WheelUncheckedUpdateWithoutRimInput>
    create: XOR<WheelCreateWithoutRimInput, WheelUncheckedCreateWithoutRimInput>
  }

  export type WheelUpdateWithWhereUniqueWithoutRimInput = {
    where: WheelWhereUniqueInput
    data: XOR<WheelUpdateWithoutRimInput, WheelUncheckedUpdateWithoutRimInput>
  }

  export type WheelUpdateManyWithWhereWithoutRimInput = {
    where: WheelScalarWhereInput
    data: XOR<WheelUpdateManyMutationInput, WheelUncheckedUpdateManyWithoutRimInput>
  }

  export type WheelSpokeUpsertWithWhereUniqueWithoutSpokeInput = {
    where: WheelSpokeWhereUniqueInput
    update: XOR<WheelSpokeUpdateWithoutSpokeInput, WheelSpokeUncheckedUpdateWithoutSpokeInput>
    create: XOR<WheelSpokeCreateWithoutSpokeInput, WheelSpokeUncheckedCreateWithoutSpokeInput>
  }

  export type WheelSpokeUpdateWithWhereUniqueWithoutSpokeInput = {
    where: WheelSpokeWhereUniqueInput
    data: XOR<WheelSpokeUpdateWithoutSpokeInput, WheelSpokeUncheckedUpdateWithoutSpokeInput>
  }

  export type WheelSpokeUpdateManyWithWhereWithoutSpokeInput = {
    where: WheelSpokeScalarWhereInput
    data: XOR<WheelSpokeUpdateManyMutationInput, WheelSpokeUncheckedUpdateManyWithoutSpokeInput>
  }

  export type WheelSpokeScalarWhereInput = {
    AND?: WheelSpokeScalarWhereInput | WheelSpokeScalarWhereInput[]
    OR?: WheelSpokeScalarWhereInput[]
    NOT?: WheelSpokeScalarWhereInput | WheelSpokeScalarWhereInput[]
    id?: IntFilter<"WheelSpoke"> | number
    quantity?: IntNullableFilter<"WheelSpoke"> | number | null
    length?: DecimalNullableFilter<"WheelSpoke"> | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: DecimalNullableFilter<"WheelSpoke"> | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: StringNullableFilter<"WheelSpoke"> | string | null
    preparation?: StringNullableFilter<"WheelSpoke"> | string | null
    notes?: StringNullableFilter<"WheelSpoke"> | string | null
    spokeId?: IntNullableFilter<"WheelSpoke"> | number | null
    wheelId?: IntNullableFilter<"WheelSpoke"> | number | null
  }

  export type PropertyUpsertWithWhereUniqueWithoutPartInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutPartInput, PropertyUncheckedUpdateWithoutPartInput>
    create: XOR<PropertyCreateWithoutPartInput, PropertyUncheckedCreateWithoutPartInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutPartInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutPartInput, PropertyUncheckedUpdateWithoutPartInput>
  }

  export type PropertyUpdateManyWithWhereWithoutPartInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPartInput>
  }

  export type ClaimUpsertWithWhereUniqueWithoutPartInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutPartInput, ClaimUncheckedUpdateWithoutPartInput>
    create: XOR<ClaimCreateWithoutPartInput, ClaimUncheckedCreateWithoutPartInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutPartInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutPartInput, ClaimUncheckedUpdateWithoutPartInput>
  }

  export type ClaimUpdateManyWithWhereWithoutPartInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutPartInput>
  }

  export type PartGroupMembershipUpsertWithWhereUniqueWithoutPartInput = {
    where: PartGroupMembershipWhereUniqueInput
    update: XOR<PartGroupMembershipUpdateWithoutPartInput, PartGroupMembershipUncheckedUpdateWithoutPartInput>
    create: XOR<PartGroupMembershipCreateWithoutPartInput, PartGroupMembershipUncheckedCreateWithoutPartInput>
  }

  export type PartGroupMembershipUpdateWithWhereUniqueWithoutPartInput = {
    where: PartGroupMembershipWhereUniqueInput
    data: XOR<PartGroupMembershipUpdateWithoutPartInput, PartGroupMembershipUncheckedUpdateWithoutPartInput>
  }

  export type PartGroupMembershipUpdateManyWithWhereWithoutPartInput = {
    where: PartGroupMembershipScalarWhereInput
    data: XOR<PartGroupMembershipUpdateManyMutationInput, PartGroupMembershipUncheckedUpdateManyWithoutPartInput>
  }

  export type BuildPartUpsertWithWhereUniqueWithoutPartInput = {
    where: BuildPartWhereUniqueInput
    update: XOR<BuildPartUpdateWithoutPartInput, BuildPartUncheckedUpdateWithoutPartInput>
    create: XOR<BuildPartCreateWithoutPartInput, BuildPartUncheckedCreateWithoutPartInput>
  }

  export type BuildPartUpdateWithWhereUniqueWithoutPartInput = {
    where: BuildPartWhereUniqueInput
    data: XOR<BuildPartUpdateWithoutPartInput, BuildPartUncheckedUpdateWithoutPartInput>
  }

  export type BuildPartUpdateManyWithWhereWithoutPartInput = {
    where: BuildPartScalarWhereInput
    data: XOR<BuildPartUpdateManyMutationInput, BuildPartUncheckedUpdateManyWithoutPartInput>
  }

  export type BuildPartScalarWhereInput = {
    AND?: BuildPartScalarWhereInput | BuildPartScalarWhereInput[]
    OR?: BuildPartScalarWhereInput[]
    NOT?: BuildPartScalarWhereInput | BuildPartScalarWhereInput[]
    id?: IntFilter<"BuildPart"> | number
    buildId?: IntNullableFilter<"BuildPart"> | number | null
    partId?: IntNullableFilter<"BuildPart"> | number | null
  }

  export type PartCreateWithoutPropertiesInput = {
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLine?: ProductLineCreateNestedOneWithoutItemsInput
    wheelHubs?: WheelCreateNestedManyWithoutHubInput
    wheelRims?: WheelCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeCreateNestedManyWithoutSpokeInput
    claims?: ClaimCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipCreateNestedManyWithoutPartInput
    builds?: BuildPartCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutPropertiesInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLineId?: number | null
    wheelHubs?: WheelUncheckedCreateNestedManyWithoutHubInput
    wheelRims?: WheelUncheckedCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeUncheckedCreateNestedManyWithoutSpokeInput
    claims?: ClaimUncheckedCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipUncheckedCreateNestedManyWithoutPartInput
    builds?: BuildPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutPropertiesInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutPropertiesInput, PartUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyTypeCreateWithoutPropertiesInput = {
    order?: number | null
    name?: string | null
    description?: string | null
    valueDataType?: string | null
    valueDataTypeModifier?: string | null
    variation?: string | null
    groups?: PropertyGroupMembershipCreateNestedManyWithoutPropertyTypeInput
    lookupValues?: PropertyLookupCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeUncheckedCreateWithoutPropertiesInput = {
    id?: number
    order?: number | null
    name?: string | null
    description?: string | null
    valueDataType?: string | null
    valueDataTypeModifier?: string | null
    variation?: string | null
    groups?: PropertyGroupMembershipUncheckedCreateNestedManyWithoutPropertyTypeInput
    lookupValues?: PropertyLookupUncheckedCreateNestedManyWithoutPropertyTypeInput
  }

  export type PropertyTypeCreateOrConnectWithoutPropertiesInput = {
    where: PropertyTypeWhereUniqueInput
    create: XOR<PropertyTypeCreateWithoutPropertiesInput, PropertyTypeUncheckedCreateWithoutPropertiesInput>
  }

  export type PartUpsertWithoutPropertiesInput = {
    update: XOR<PartUpdateWithoutPropertiesInput, PartUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PartCreateWithoutPropertiesInput, PartUncheckedCreateWithoutPropertiesInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutPropertiesInput, PartUncheckedUpdateWithoutPropertiesInput>
  }

  export type PartUpdateWithoutPropertiesInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLine?: ProductLineUpdateOneWithoutItemsNestedInput
    wheelHubs?: WheelUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUpdateManyWithoutSpokeNestedInput
    claims?: ClaimUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUpdateManyWithoutPartNestedInput
    builds?: BuildPartUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelHubs?: WheelUncheckedUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUncheckedUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUncheckedUpdateManyWithoutSpokeNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUncheckedUpdateManyWithoutPartNestedInput
    builds?: BuildPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PropertyTypeUpsertWithoutPropertiesInput = {
    update: XOR<PropertyTypeUpdateWithoutPropertiesInput, PropertyTypeUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyTypeCreateWithoutPropertiesInput, PropertyTypeUncheckedCreateWithoutPropertiesInput>
    where?: PropertyTypeWhereInput
  }

  export type PropertyTypeUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyTypeWhereInput
    data: XOR<PropertyTypeUpdateWithoutPropertiesInput, PropertyTypeUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyTypeUpdateWithoutPropertiesInput = {
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: PropertyGroupMembershipUpdateManyWithoutPropertyTypeNestedInput
    lookupValues?: PropertyLookupUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PropertyTypeUncheckedUpdateWithoutPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataType?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataTypeModifier?: NullableStringFieldUpdateOperationsInput | string | null
    variation?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: PropertyGroupMembershipUncheckedUpdateManyWithoutPropertyTypeNestedInput
    lookupValues?: PropertyLookupUncheckedUpdateManyWithoutPropertyTypeNestedInput
  }

  export type PartCreateWithoutWheelSpokesInput = {
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLine?: ProductLineCreateNestedOneWithoutItemsInput
    wheelHubs?: WheelCreateNestedManyWithoutHubInput
    wheelRims?: WheelCreateNestedManyWithoutRimInput
    properties?: PropertyCreateNestedManyWithoutPartInput
    claims?: ClaimCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipCreateNestedManyWithoutPartInput
    builds?: BuildPartCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutWheelSpokesInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLineId?: number | null
    wheelHubs?: WheelUncheckedCreateNestedManyWithoutHubInput
    wheelRims?: WheelUncheckedCreateNestedManyWithoutRimInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPartInput
    claims?: ClaimUncheckedCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipUncheckedCreateNestedManyWithoutPartInput
    builds?: BuildPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutWheelSpokesInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutWheelSpokesInput, PartUncheckedCreateWithoutWheelSpokesInput>
  }

  export type WheelCreateWithoutSpokesInput = {
    name?: string | null
    notes?: string | null
    hub?: PartCreateNestedOneWithoutWheelHubsInput
    rim?: PartCreateNestedOneWithoutWheelRimsInput
  }

  export type WheelUncheckedCreateWithoutSpokesInput = {
    id?: number
    name?: string | null
    notes?: string | null
    hubId?: number | null
    rimId?: number | null
  }

  export type WheelCreateOrConnectWithoutSpokesInput = {
    where: WheelWhereUniqueInput
    create: XOR<WheelCreateWithoutSpokesInput, WheelUncheckedCreateWithoutSpokesInput>
  }

  export type PartUpsertWithoutWheelSpokesInput = {
    update: XOR<PartUpdateWithoutWheelSpokesInput, PartUncheckedUpdateWithoutWheelSpokesInput>
    create: XOR<PartCreateWithoutWheelSpokesInput, PartUncheckedCreateWithoutWheelSpokesInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutWheelSpokesInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutWheelSpokesInput, PartUncheckedUpdateWithoutWheelSpokesInput>
  }

  export type PartUpdateWithoutWheelSpokesInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLine?: ProductLineUpdateOneWithoutItemsNestedInput
    wheelHubs?: WheelUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUpdateManyWithoutRimNestedInput
    properties?: PropertyUpdateManyWithoutPartNestedInput
    claims?: ClaimUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUpdateManyWithoutPartNestedInput
    builds?: BuildPartUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutWheelSpokesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelHubs?: WheelUncheckedUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUncheckedUpdateManyWithoutRimNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPartNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUncheckedUpdateManyWithoutPartNestedInput
    builds?: BuildPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type WheelUpsertWithoutSpokesInput = {
    update: XOR<WheelUpdateWithoutSpokesInput, WheelUncheckedUpdateWithoutSpokesInput>
    create: XOR<WheelCreateWithoutSpokesInput, WheelUncheckedCreateWithoutSpokesInput>
    where?: WheelWhereInput
  }

  export type WheelUpdateToOneWithWhereWithoutSpokesInput = {
    where?: WheelWhereInput
    data: XOR<WheelUpdateWithoutSpokesInput, WheelUncheckedUpdateWithoutSpokesInput>
  }

  export type WheelUpdateWithoutSpokesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hub?: PartUpdateOneWithoutWheelHubsNestedInput
    rim?: PartUpdateOneWithoutWheelRimsNestedInput
  }

  export type WheelUncheckedUpdateWithoutSpokesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hubId?: NullableIntFieldUpdateOperationsInput | number | null
    rimId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartCreateWithoutWheelHubsInput = {
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLine?: ProductLineCreateNestedOneWithoutItemsInput
    wheelRims?: WheelCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeCreateNestedManyWithoutSpokeInput
    properties?: PropertyCreateNestedManyWithoutPartInput
    claims?: ClaimCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipCreateNestedManyWithoutPartInput
    builds?: BuildPartCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutWheelHubsInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLineId?: number | null
    wheelRims?: WheelUncheckedCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeUncheckedCreateNestedManyWithoutSpokeInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPartInput
    claims?: ClaimUncheckedCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipUncheckedCreateNestedManyWithoutPartInput
    builds?: BuildPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutWheelHubsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutWheelHubsInput, PartUncheckedCreateWithoutWheelHubsInput>
  }

  export type PartCreateWithoutWheelRimsInput = {
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLine?: ProductLineCreateNestedOneWithoutItemsInput
    wheelHubs?: WheelCreateNestedManyWithoutHubInput
    wheelSpokes?: WheelSpokeCreateNestedManyWithoutSpokeInput
    properties?: PropertyCreateNestedManyWithoutPartInput
    claims?: ClaimCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipCreateNestedManyWithoutPartInput
    builds?: BuildPartCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutWheelRimsInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLineId?: number | null
    wheelHubs?: WheelUncheckedCreateNestedManyWithoutHubInput
    wheelSpokes?: WheelSpokeUncheckedCreateNestedManyWithoutSpokeInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPartInput
    claims?: ClaimUncheckedCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipUncheckedCreateNestedManyWithoutPartInput
    builds?: BuildPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutWheelRimsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutWheelRimsInput, PartUncheckedCreateWithoutWheelRimsInput>
  }

  export type WheelSpokeCreateWithoutWheelInput = {
    quantity?: number | null
    length?: Decimal | DecimalJsLike | number | string | null
    tensionApplied?: Decimal | DecimalJsLike | number | string | null
    tensionUnit?: string | null
    preparation?: string | null
    notes?: string | null
    spoke?: PartCreateNestedOneWithoutWheelSpokesInput
  }

  export type WheelSpokeUncheckedCreateWithoutWheelInput = {
    id?: number
    quantity?: number | null
    length?: Decimal | DecimalJsLike | number | string | null
    tensionApplied?: Decimal | DecimalJsLike | number | string | null
    tensionUnit?: string | null
    preparation?: string | null
    notes?: string | null
    spokeId?: number | null
  }

  export type WheelSpokeCreateOrConnectWithoutWheelInput = {
    where: WheelSpokeWhereUniqueInput
    create: XOR<WheelSpokeCreateWithoutWheelInput, WheelSpokeUncheckedCreateWithoutWheelInput>
  }

  export type WheelSpokeCreateManyWheelInputEnvelope = {
    data: WheelSpokeCreateManyWheelInput | WheelSpokeCreateManyWheelInput[]
    skipDuplicates?: boolean
  }

  export type PartUpsertWithoutWheelHubsInput = {
    update: XOR<PartUpdateWithoutWheelHubsInput, PartUncheckedUpdateWithoutWheelHubsInput>
    create: XOR<PartCreateWithoutWheelHubsInput, PartUncheckedCreateWithoutWheelHubsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutWheelHubsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutWheelHubsInput, PartUncheckedUpdateWithoutWheelHubsInput>
  }

  export type PartUpdateWithoutWheelHubsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLine?: ProductLineUpdateOneWithoutItemsNestedInput
    wheelRims?: WheelUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUpdateManyWithoutPartNestedInput
    claims?: ClaimUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUpdateManyWithoutPartNestedInput
    builds?: BuildPartUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutWheelHubsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelRims?: WheelUncheckedUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUncheckedUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPartNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUncheckedUpdateManyWithoutPartNestedInput
    builds?: BuildPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartUpsertWithoutWheelRimsInput = {
    update: XOR<PartUpdateWithoutWheelRimsInput, PartUncheckedUpdateWithoutWheelRimsInput>
    create: XOR<PartCreateWithoutWheelRimsInput, PartUncheckedCreateWithoutWheelRimsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutWheelRimsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutWheelRimsInput, PartUncheckedUpdateWithoutWheelRimsInput>
  }

  export type PartUpdateWithoutWheelRimsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLine?: ProductLineUpdateOneWithoutItemsNestedInput
    wheelHubs?: WheelUpdateManyWithoutHubNestedInput
    wheelSpokes?: WheelSpokeUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUpdateManyWithoutPartNestedInput
    claims?: ClaimUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUpdateManyWithoutPartNestedInput
    builds?: BuildPartUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutWheelRimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelHubs?: WheelUncheckedUpdateManyWithoutHubNestedInput
    wheelSpokes?: WheelSpokeUncheckedUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPartNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUncheckedUpdateManyWithoutPartNestedInput
    builds?: BuildPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type WheelSpokeUpsertWithWhereUniqueWithoutWheelInput = {
    where: WheelSpokeWhereUniqueInput
    update: XOR<WheelSpokeUpdateWithoutWheelInput, WheelSpokeUncheckedUpdateWithoutWheelInput>
    create: XOR<WheelSpokeCreateWithoutWheelInput, WheelSpokeUncheckedCreateWithoutWheelInput>
  }

  export type WheelSpokeUpdateWithWhereUniqueWithoutWheelInput = {
    where: WheelSpokeWhereUniqueInput
    data: XOR<WheelSpokeUpdateWithoutWheelInput, WheelSpokeUncheckedUpdateWithoutWheelInput>
  }

  export type WheelSpokeUpdateManyWithWhereWithoutWheelInput = {
    where: WheelSpokeScalarWhereInput
    data: XOR<WheelSpokeUpdateManyMutationInput, WheelSpokeUncheckedUpdateManyWithoutWheelInput>
  }

  export type BuildCreateWithoutPartsInput = {
    name?: string | null
    status?: string | null
    notes?: string | null
  }

  export type BuildUncheckedCreateWithoutPartsInput = {
    id?: number
    name?: string | null
    status?: string | null
    notes?: string | null
  }

  export type BuildCreateOrConnectWithoutPartsInput = {
    where: BuildWhereUniqueInput
    create: XOR<BuildCreateWithoutPartsInput, BuildUncheckedCreateWithoutPartsInput>
  }

  export type PartCreateWithoutBuildsInput = {
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLine?: ProductLineCreateNestedOneWithoutItemsInput
    wheelHubs?: WheelCreateNestedManyWithoutHubInput
    wheelRims?: WheelCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeCreateNestedManyWithoutSpokeInput
    properties?: PropertyCreateNestedManyWithoutPartInput
    claims?: ClaimCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutBuildsInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
    productLineId?: number | null
    wheelHubs?: WheelUncheckedCreateNestedManyWithoutHubInput
    wheelRims?: WheelUncheckedCreateNestedManyWithoutRimInput
    wheelSpokes?: WheelSpokeUncheckedCreateNestedManyWithoutSpokeInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPartInput
    claims?: ClaimUncheckedCreateNestedManyWithoutPartInput
    groups?: PartGroupMembershipUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutBuildsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutBuildsInput, PartUncheckedCreateWithoutBuildsInput>
  }

  export type BuildUpsertWithoutPartsInput = {
    update: XOR<BuildUpdateWithoutPartsInput, BuildUncheckedUpdateWithoutPartsInput>
    create: XOR<BuildCreateWithoutPartsInput, BuildUncheckedCreateWithoutPartsInput>
    where?: BuildWhereInput
  }

  export type BuildUpdateToOneWithWhereWithoutPartsInput = {
    where?: BuildWhereInput
    data: XOR<BuildUpdateWithoutPartsInput, BuildUncheckedUpdateWithoutPartsInput>
  }

  export type BuildUpdateWithoutPartsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuildUncheckedUpdateWithoutPartsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartUpsertWithoutBuildsInput = {
    update: XOR<PartUpdateWithoutBuildsInput, PartUncheckedUpdateWithoutBuildsInput>
    create: XOR<PartCreateWithoutBuildsInput, PartUncheckedCreateWithoutBuildsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutBuildsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutBuildsInput, PartUncheckedUpdateWithoutBuildsInput>
  }

  export type PartUpdateWithoutBuildsInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLine?: ProductLineUpdateOneWithoutItemsNestedInput
    wheelHubs?: WheelUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUpdateManyWithoutPartNestedInput
    claims?: ClaimUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutBuildsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    wheelHubs?: WheelUncheckedUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUncheckedUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUncheckedUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPartNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUncheckedUpdateManyWithoutPartNestedInput
  }

  export type BuildPartCreateWithoutBuildInput = {
    part?: PartCreateNestedOneWithoutBuildsInput
  }

  export type BuildPartUncheckedCreateWithoutBuildInput = {
    id?: number
    partId?: number | null
  }

  export type BuildPartCreateOrConnectWithoutBuildInput = {
    where: BuildPartWhereUniqueInput
    create: XOR<BuildPartCreateWithoutBuildInput, BuildPartUncheckedCreateWithoutBuildInput>
  }

  export type BuildPartCreateManyBuildInputEnvelope = {
    data: BuildPartCreateManyBuildInput | BuildPartCreateManyBuildInput[]
    skipDuplicates?: boolean
  }

  export type BuildPartUpsertWithWhereUniqueWithoutBuildInput = {
    where: BuildPartWhereUniqueInput
    update: XOR<BuildPartUpdateWithoutBuildInput, BuildPartUncheckedUpdateWithoutBuildInput>
    create: XOR<BuildPartCreateWithoutBuildInput, BuildPartUncheckedCreateWithoutBuildInput>
  }

  export type BuildPartUpdateWithWhereUniqueWithoutBuildInput = {
    where: BuildPartWhereUniqueInput
    data: XOR<BuildPartUpdateWithoutBuildInput, BuildPartUncheckedUpdateWithoutBuildInput>
  }

  export type BuildPartUpdateManyWithWhereWithoutBuildInput = {
    where: BuildPartScalarWhereInput
    data: XOR<BuildPartUpdateManyMutationInput, BuildPartUncheckedUpdateManyWithoutBuildInput>
  }

  export type ClaimCreateManyOwnerInput = {
    id?: number
    claimType?: string | null
    acquired?: Date | string | null
    condition?: string | null
    notes?: string | null
    partId?: number | null
  }

  export type ClaimUpdateWithoutOwnerInput = {
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    part?: PartUpdateOneWithoutClaimsNestedInput
  }

  export type ClaimUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClaimUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BrandMemberCreateManyBrandInput = {
    id?: number
    productLineId?: number | null
  }

  export type BrandMemberUpdateWithoutBrandInput = {
    productLine?: ProductLineUpdateOneWithoutLabelMembershipsNestedInput
  }

  export type BrandMemberUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BrandMemberUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BrandMemberCreateManyProductLineInput = {
    id?: number
    brandId?: number | null
  }

  export type PartCreateManyProductLineInput = {
    id?: number
    type?: string | null
    name?: string | null
    notes?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    weightUnit?: string | null
  }

  export type BrandMemberUpdateWithoutProductLineInput = {
    brand?: BrandUpdateOneWithoutLabelMembershipsNestedInput
  }

  export type BrandMemberUncheckedUpdateWithoutProductLineInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BrandMemberUncheckedUpdateManyWithoutProductLineInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartUpdateWithoutProductLineInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    wheelHubs?: WheelUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUpdateManyWithoutPartNestedInput
    claims?: ClaimUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUpdateManyWithoutPartNestedInput
    builds?: BuildPartUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutProductLineInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    wheelHubs?: WheelUncheckedUpdateManyWithoutHubNestedInput
    wheelRims?: WheelUncheckedUpdateManyWithoutRimNestedInput
    wheelSpokes?: WheelSpokeUncheckedUpdateManyWithoutSpokeNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPartNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutPartNestedInput
    groups?: PartGroupMembershipUncheckedUpdateManyWithoutPartNestedInput
    builds?: BuildPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateManyWithoutProductLineInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyGroupMembershipCreateManyGroupInput = {
    id?: number
    partTypeId?: number | null
    propertyTypeId?: number | null
  }

  export type PropertyGroupMembershipUpdateWithoutGroupInput = {
    partType?: PartTypeUpdateOneWithoutPropertyTypesNestedInput
    propertyType?: PropertyTypeUpdateOneWithoutGroupsNestedInput
  }

  export type PropertyGroupMembershipUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyGroupMembershipUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyGroupMembershipCreateManyPropertyTypeInput = {
    id?: number
    partTypeId?: number | null
    groupId?: number | null
  }

  export type PropertyCreateManyPropertyTypeInput = {
    id?: number
    itemId?: number | null
    value?: string | null
    valueDataMethod?: string | null
  }

  export type PropertyLookupCreateManyPropertyTypeInput = {
    id?: number
    value?: string | null
  }

  export type PropertyGroupMembershipUpdateWithoutPropertyTypeInput = {
    partType?: PartTypeUpdateOneWithoutPropertyTypesNestedInput
    group?: PropertyGroupUpdateOneWithoutPropertyTypesNestedInput
  }

  export type PropertyGroupMembershipUncheckedUpdateWithoutPropertyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyGroupMembershipUncheckedUpdateManyWithoutPropertyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUpdateWithoutPropertyTypeInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
    part?: PartUpdateOneWithoutPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyLookupUpdateWithoutPropertyTypeInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyLookupUncheckedUpdateWithoutPropertyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyLookupUncheckedUpdateManyWithoutPropertyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartClassMembershipCreateManyPartClassInput = {
    id?: number
    partTypeId?: number | null
  }

  export type PartClassMembershipUpdateWithoutPartClassInput = {
    partType?: PartTypeUpdateOneWithoutClassesNestedInput
  }

  export type PartClassMembershipUncheckedUpdateWithoutPartClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartClassMembershipUncheckedUpdateManyWithoutPartClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    partTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyGroupMembershipCreateManyPartTypeInput = {
    id?: number
    propertyTypeId?: number | null
    groupId?: number | null
  }

  export type PartClassMembershipCreateManyPartTypeInput = {
    id?: number
    partClassId?: number | null
  }

  export type PropertyGroupMembershipUpdateWithoutPartTypeInput = {
    propertyType?: PropertyTypeUpdateOneWithoutGroupsNestedInput
    group?: PropertyGroupUpdateOneWithoutPropertyTypesNestedInput
  }

  export type PropertyGroupMembershipUncheckedUpdateWithoutPartTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyGroupMembershipUncheckedUpdateManyWithoutPartTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartClassMembershipUpdateWithoutPartTypeInput = {
    partClass?: PartClassUpdateOneWithoutPartTypesNestedInput
  }

  export type PartClassMembershipUncheckedUpdateWithoutPartTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    partClassId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartClassMembershipUncheckedUpdateManyWithoutPartTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    partClassId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartGroupMembershipCreateManyGroupInput = {
    id?: number
    partId?: number | null
  }

  export type PartGroupMembershipUpdateWithoutGroupInput = {
    part?: PartUpdateOneWithoutGroupsNestedInput
  }

  export type PartGroupMembershipUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartGroupMembershipUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WheelCreateManyHubInput = {
    id?: number
    name?: string | null
    notes?: string | null
    rimId?: number | null
  }

  export type WheelCreateManyRimInput = {
    id?: number
    name?: string | null
    notes?: string | null
    hubId?: number | null
  }

  export type WheelSpokeCreateManySpokeInput = {
    id?: number
    quantity?: number | null
    length?: Decimal | DecimalJsLike | number | string | null
    tensionApplied?: Decimal | DecimalJsLike | number | string | null
    tensionUnit?: string | null
    preparation?: string | null
    notes?: string | null
    wheelId?: number | null
  }

  export type PropertyCreateManyPartInput = {
    id?: number
    value?: string | null
    valueDataMethod?: string | null
    propertyTypeId?: number | null
  }

  export type ClaimCreateManyPartInput = {
    id?: number
    claimType?: string | null
    acquired?: Date | string | null
    condition?: string | null
    notes?: string | null
    ownerId?: number | null
  }

  export type PartGroupMembershipCreateManyPartInput = {
    id?: number
    groupId?: number | null
  }

  export type BuildPartCreateManyPartInput = {
    id?: number
    buildId?: number | null
  }

  export type WheelUpdateWithoutHubInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rim?: PartUpdateOneWithoutWheelRimsNestedInput
    spokes?: WheelSpokeUpdateManyWithoutWheelNestedInput
  }

  export type WheelUncheckedUpdateWithoutHubInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rimId?: NullableIntFieldUpdateOperationsInput | number | null
    spokes?: WheelSpokeUncheckedUpdateManyWithoutWheelNestedInput
  }

  export type WheelUncheckedUpdateManyWithoutHubInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rimId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WheelUpdateWithoutRimInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hub?: PartUpdateOneWithoutWheelHubsNestedInput
    spokes?: WheelSpokeUpdateManyWithoutWheelNestedInput
  }

  export type WheelUncheckedUpdateWithoutRimInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hubId?: NullableIntFieldUpdateOperationsInput | number | null
    spokes?: WheelSpokeUncheckedUpdateManyWithoutWheelNestedInput
  }

  export type WheelUncheckedUpdateManyWithoutRimInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hubId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WheelSpokeUpdateWithoutSpokeInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wheel?: WheelUpdateOneWithoutSpokesNestedInput
  }

  export type WheelSpokeUncheckedUpdateWithoutSpokeInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wheelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WheelSpokeUncheckedUpdateManyWithoutSpokeInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    wheelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUpdateWithoutPartInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: PropertyTypeUpdateOneWithoutPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUncheckedUpdateManyWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    valueDataMethod?: NullableStringFieldUpdateOperationsInput | string | null
    propertyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClaimUpdateWithoutPartInput = {
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneWithoutClaimsNestedInput
  }

  export type ClaimUncheckedUpdateWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClaimUncheckedUpdateManyWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimType?: NullableStringFieldUpdateOperationsInput | string | null
    acquired?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartGroupMembershipUpdateWithoutPartInput = {
    group?: PartGroupUpdateOneWithoutPartsNestedInput
  }

  export type PartGroupMembershipUncheckedUpdateWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartGroupMembershipUncheckedUpdateManyWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuildPartUpdateWithoutPartInput = {
    build?: BuildUpdateOneWithoutPartsNestedInput
  }

  export type BuildPartUncheckedUpdateWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuildPartUncheckedUpdateManyWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    buildId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WheelSpokeCreateManyWheelInput = {
    id?: number
    quantity?: number | null
    length?: Decimal | DecimalJsLike | number | string | null
    tensionApplied?: Decimal | DecimalJsLike | number | string | null
    tensionUnit?: string | null
    preparation?: string | null
    notes?: string | null
    spokeId?: number | null
  }

  export type WheelSpokeUpdateWithoutWheelInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    spoke?: PartUpdateOneWithoutWheelSpokesNestedInput
  }

  export type WheelSpokeUncheckedUpdateWithoutWheelInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    spokeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WheelSpokeUncheckedUpdateManyWithoutWheelInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionApplied?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionUnit?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    spokeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuildPartCreateManyBuildInput = {
    id?: number
    partId?: number | null
  }

  export type BuildPartUpdateWithoutBuildInput = {
    part?: PartUpdateOneWithoutBuildsNestedInput
  }

  export type BuildPartUncheckedUpdateWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuildPartUncheckedUpdateManyWithoutBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    partId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandCountOutputTypeDefaultArgs instead
     */
    export type BrandCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductLineCountOutputTypeDefaultArgs instead
     */
    export type ProductLineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductLineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyGroupCountOutputTypeDefaultArgs instead
     */
    export type PropertyGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyTypeCountOutputTypeDefaultArgs instead
     */
    export type PropertyTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartClassCountOutputTypeDefaultArgs instead
     */
    export type PartClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartTypeCountOutputTypeDefaultArgs instead
     */
    export type PartTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartGroupCountOutputTypeDefaultArgs instead
     */
    export type PartGroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartGroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartCountOutputTypeDefaultArgs instead
     */
    export type PartCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WheelCountOutputTypeDefaultArgs instead
     */
    export type WheelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WheelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildCountOutputTypeDefaultArgs instead
     */
    export type BuildCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimDefaultArgs instead
     */
    export type ClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandDefaultArgs instead
     */
    export type BrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandMemberDefaultArgs instead
     */
    export type BrandMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductLineDefaultArgs instead
     */
    export type ProductLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyGroupDefaultArgs instead
     */
    export type PropertyGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyGroupMembershipDefaultArgs instead
     */
    export type PropertyGroupMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyGroupMembershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyTypeDefaultArgs instead
     */
    export type PropertyTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyLookupDefaultArgs instead
     */
    export type PropertyLookupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyLookupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartClassDefaultArgs instead
     */
    export type PartClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartClassMembershipDefaultArgs instead
     */
    export type PartClassMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartClassMembershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartTypeDefaultArgs instead
     */
    export type PartTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartGroupDefaultArgs instead
     */
    export type PartGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartGroupMembershipDefaultArgs instead
     */
    export type PartGroupMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartGroupMembershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartDefaultArgs instead
     */
    export type PartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyDefaultArgs instead
     */
    export type PropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WheelSpokeDefaultArgs instead
     */
    export type WheelSpokeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WheelSpokeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WheelDefaultArgs instead
     */
    export type WheelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WheelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildPartDefaultArgs instead
     */
    export type BuildPartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildPartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildDefaultArgs instead
     */
    export type BuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}